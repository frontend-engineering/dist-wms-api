
/**
 * Client
**/

import * as runtime from './runtime/library';
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends Prisma.PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};

export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>


/**
 * Model TaskFormRelation
 * @schema.display_name 节点和表单关联关系
 */
export type TaskFormRelation = {
  id: number
  createdAt: Date
  updatedAt: Date
  isDeleted: boolean
  taskDefinitionKey: string
  formKey: string
}

/**
 * Model User
 * @schema.display_name 员工
 * @schema.display_column username
 */
export type User = {
  id: number
  createdAt: Date
  updatedAt: Date
  isDeleted: boolean
  username: string
  hashedPassword: string | null
  hashedRefreshToken: string | null
  status: UserStatus
  role: UserGroup
}

/**
 * Model UserProfile
 * 
 */
export type UserProfile = {
  id: number
  createdAt: Date
  updatedAt: Date
  isDeleted: boolean
  userId: number
  fullName: string
}

/**
 * Model ProductLine
 * @schema.primary_key id
 * @schema.display_name 产线
 * @schema.display_column name
 */
export type ProductLine = {
  id: number
  createdAt: Date
  updatedAt: Date
  isDeleted: boolean
  /**
   * @schema.title 产线名
   */
  name: string
  /**
   * @schema.title 产线描述
   * @schema.column_type textarea
   */
  description: string
}

/**
 * Model Equipment
 * @schema.primary_key id
 * @schema.display_name 设备
 * @schema.display_column name
 */
export type Equipment = {
  id: number
  createdAt: Date
  updatedAt: Date
  isDeleted: boolean
  /**
   * @schema.title 设备名
   */
  name: string
  /**
   * @schema.title 设备描述
   * @schema.column_type textarea
   */
  description: string
  /**
   * @schema.title 维修计划
   * @schema.column_type cron
   */
  repairPlan: string
  /**
   * @schema.title 工位
   */
  workStation: string
  /**
   * @schema.reference ProductLine
   */
  productLineId: number
}

/**
 * Model RepairMaterialInventory
 * @schema.primary_key id
 * @schema.display_name 备品备料库存
 * @schema.display_column name
 */
export type RepairMaterialInventory = {
  id: number
  createdAt: Date
  updatedAt: Date
  isDeleted: boolean
  /**
   * @schema.title 物料名
   */
  name: string
  /**
   * @schema.title 物料描述
   * @schema.column_type textarea
   */
  description: string
  /**
   * @schema.title 库存数量
   */
  quantity: number
  /**
   * @schema.title 最小库存数量
   */
  minimumQuantity: number
  /**
   * @schema.reference Equipment
   */
  equipmentId: number
}

/**
 * Model RepairRecord
 * @schema.primary_key id
 * @schema.display_name 维修记录
 * @schema.display_column equipmentId
 */
export type RepairRecord = {
  id: number
  createdAt: Date
  updatedAt: Date
  isDeleted: boolean
  /**
   * @schema.title 类型
   */
  type: RepairType
  /**
   * @schema.reference Equipment
   * @schema.x-relationField equipment
   */
  equipmentId: number
  /**
   * @schema.title 状态
   */
  status: RepairRecordStatus
  /**
   * @schema.title 备注
   * @schema.column_type textarea
   */
  description: string
}

/**
 * Model Part
 * @schema.display_name 零件
 * @schema.display_column name
 */
export type Part = {
  id: number
  createdAt: Date
  updatedAt: Date
  isDeleted: boolean
  /**
   * @schema.title 零件号
   */
  no: string
  /**
   * @schema.title 零件名称
   */
  name: string
}

/**
 * Model PartVersion
 * @schema.display_name 零件版本
 * @schema.display_column partId,version
 */
export type PartVersion = {
  id: number
  createdAt: Date
  updatedAt: Date
  isDeleted: boolean
  /**
   * @schema.title 版本号
   */
  version: string
  /**
   * @schema.title 备注
   */
  note: string | null
  /**
   * @schema.reference Part
   */
  partId: number
}

/**
 * Model IncomingInspectionSpec
 * @schema.display_name 进料检验规范
 * @schema.display_column version
 */
export type IncomingInspectionSpec = {
  id: number
  createdAt: Date
  updatedAt: Date
  isDeleted: boolean
  /**
   * @schema.title 版本编号
   */
  version: string
  /**
   * @schema.title 附件
   */
  attachment: string
  /**
   * @schema.reference PartVersion
   */
  partVersionId: number
}

/**
 * Model IncomingInspectionSpecItem
 * @schema.display_name 检验项目
 * @schema.display_column name
 * @schema.display_primary_key false
 */
export type IncomingInspectionSpecItem = {
  id: number
  createdAt: Date
  updatedAt: Date
  isDeleted: boolean
  /**
   * @schema.title 序号
   */
  no: number
  /**
   * @schema.title 检验项目
   */
  name: string
  /**
   * @schema.title 规格
   */
  spec: string
  /**
   * @schema.reference IncomingInspectionSpec
   */
  incomingInspectionSpecId: number
}

/**
 * Model NonconformItem
 * @schema.display_name 不合格品记录
 * @schema.display_column partId
 */
export type NonconformItem = {
  id: number
  createdAt: Date
  updatedAt: Date
  isDeleted: boolean
  /**
   * @schema.reference Part
   */
  partId: number
  /**
   * @schema.title 不良描述
   */
  description: string
  /**
   * @schema.title 备注
   */
  note: string | null
}

/**
 * Model PartOperation
 * @schema.display_name 零件总成工序
 * @schema.display_column version
 */
export type PartOperation = {
  id: number
  createdAt: Date
  updatedAt: Date
  isDeleted: boolean
  /**
   * @schema.title 版本号
   */
  version: string
  /**
   * @schema.title 工序号
   */
  no: string
  /**
   * @schema.title 工序名称
   */
  name: string
  /**
   * @schema.reference Part
   */
  partId: number
}

/**
 * Model PartOperationInspectionItem
 * @schema.display_name 零件工序检验项目
 * @schema.display_column version
 */
export type PartOperationInspectionItem = {
  id: number
  createdAt: Date
  updatedAt: Date
  isDeleted: boolean
  /**
   * @schema.title 检验项目
   */
  name: string
  /**
   * @schema.reference PartOperation
   */
  partOperationId: number
}

/**
 * Model Receipt
 * @schema.display_name 收货单
 * @schema.display_column lot
 */
export type Receipt = {
  id: number
  createdAt: Date
  updatedAt: Date
  isDeleted: boolean
  /**
   * @schema.title 零件批号
   */
  lot: string
  /**
   * @schema.reference PartVersion
   */
  partVersionId: number
}

/**
 * Model IncomingInspectionRecord
 * @schema.display_name 进料检记录
 * @schema.display_column receiptId
 */
export type IncomingInspectionRecord = {
  id: number
  createdAt: Date
  updatedAt: Date
  isDeleted: boolean
  /**
   * @schema.title 备注
   */
  note: string
  /**
   * @schema.title 判定
   */
  result: IncomingInspectionResult
  /**
   * @schema.reference Receipt
   */
  receiptId: number
  /**
   * @schema.reference IncomingInspectionSpec
   */
  incomingInspectionSpecId: number
}

/**
 * Model IncomingInspectionRecordItem
 * @schema.display_name 进料检记录详情
 * @schema.display_primary_key false
 */
export type IncomingInspectionRecordItem = {
  id: number
  createdAt: Date
  updatedAt: Date
  isDeleted: boolean
  /**
   * @schema.title 结果
   */
  result: boolean
  /**
   * @schema.title 测量#
   */
  inspectionIteration: string
  /**
   * @schema.reference IncomingInspectionRecord
   */
  incomingInspectionRecordId: number
  /**
   * @schema.reference IncomingInspectionSpecItem
   */
  incomingInspectionSpecItemId: number
}

/**
 * Model WorkerOrder
 * @schema.display_name 工单
 * @schema.display_column no
 */
export type WorkerOrder = {
  id: number
  createdAt: Date
  updatedAt: Date
  isDeleted: boolean
  /**
   * @schema.title 工单号
   */
  no: string
  /**
   * @schema.reference Part
   */
  partId: number
}

/**
 * Model OperationInspectionRecord
 * @schema.display_name 过程检记录
 * @schema.display_column result
 */
export type OperationInspectionRecord = {
  id: number
  createdAt: Date
  updatedAt: Date
  isDeleted: boolean
  /**
   * @schema.title 备注
   */
  note: string | null
  /**
   * @schema.reference WorkerOrder
   */
  workerOrderId: number
  /**
   * @schema.reference User
   * @schema.x-relationField inspector
   * @schema.display_name 检验员
   */
  inspectorId: number
  /**
   * @schema.reference User
   * @schema.x-relationField reviewer
   * @schema.display_name 审核员
   */
  reviewerId: number
}

/**
 * Model OperationInspectionRecordItem
 * @schema.display_name 过程检记录详情
 */
export type OperationInspectionRecordItem = {
  id: number
  createdAt: Date
  updatedAt: Date
  isDeleted: boolean
  /**
   * @schema.title 测量#
   */
  inspectionIteration: string
  /**
   * @schema.reference PartOperationInspectionItem
   */
  partOperationInspectionItemId: number
  /**
   * @schema.reference OperationInspectionRecord
   */
  operationInspectionRecordId: number
}


/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export const IncomingInspectionResult: {
  Pass: 'Pass',
  Reject: 'Reject',
  Downgrade: 'Downgrade'
};

export type IncomingInspectionResult = (typeof IncomingInspectionResult)[keyof typeof IncomingInspectionResult]


export const RepairRecordStatus: {
  TO_ASSIGN: 'TO_ASSIGN',
  DOING: 'DOING',
  TO_REVIEW: 'TO_REVIEW',
  DONE: 'DONE'
};

export type RepairRecordStatus = (typeof RepairRecordStatus)[keyof typeof RepairRecordStatus]


export const RepairType: {
  SCHEDULE: 'SCHEDULE',
  UNSCHEDULE: 'UNSCHEDULE'
};

export type RepairType = (typeof RepairType)[keyof typeof RepairType]


export const UserGroup: {
  ADMIN: 'ADMIN',
  USER: 'USER'
};

export type UserGroup = (typeof UserGroup)[keyof typeof UserGroup]


export const UserStatus: {
  ACTIVE: 'ACTIVE',
  FORBIDDEN: 'FORBIDDEN'
};

export type UserStatus = (typeof UserStatus)[keyof typeof UserStatus]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more TaskFormRelations
 * const taskFormRelations = await prisma.taskFormRelation.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more TaskFormRelations
   * const taskFormRelations = await prisma.taskFormRelation.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<this, "$connect" | "$disconnect" | "$on" | "$transaction" | "$use">) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>

      /**
   * `prisma.taskFormRelation`: Exposes CRUD operations for the **TaskFormRelation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskFormRelations
    * const taskFormRelations = await prisma.taskFormRelation.findMany()
    * ```
    */
  get taskFormRelation(): Prisma.TaskFormRelationDelegate<GlobalReject>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject>;

  /**
   * `prisma.userProfile`: Exposes CRUD operations for the **UserProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserProfiles
    * const userProfiles = await prisma.userProfile.findMany()
    * ```
    */
  get userProfile(): Prisma.UserProfileDelegate<GlobalReject>;

  /**
   * `prisma.productLine`: Exposes CRUD operations for the **ProductLine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductLines
    * const productLines = await prisma.productLine.findMany()
    * ```
    */
  get productLine(): Prisma.ProductLineDelegate<GlobalReject>;

  /**
   * `prisma.equipment`: Exposes CRUD operations for the **Equipment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Equipment
    * const equipment = await prisma.equipment.findMany()
    * ```
    */
  get equipment(): Prisma.EquipmentDelegate<GlobalReject>;

  /**
   * `prisma.repairMaterialInventory`: Exposes CRUD operations for the **RepairMaterialInventory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RepairMaterialInventories
    * const repairMaterialInventories = await prisma.repairMaterialInventory.findMany()
    * ```
    */
  get repairMaterialInventory(): Prisma.RepairMaterialInventoryDelegate<GlobalReject>;

  /**
   * `prisma.repairRecord`: Exposes CRUD operations for the **RepairRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RepairRecords
    * const repairRecords = await prisma.repairRecord.findMany()
    * ```
    */
  get repairRecord(): Prisma.RepairRecordDelegate<GlobalReject>;

  /**
   * `prisma.part`: Exposes CRUD operations for the **Part** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Parts
    * const parts = await prisma.part.findMany()
    * ```
    */
  get part(): Prisma.PartDelegate<GlobalReject>;

  /**
   * `prisma.partVersion`: Exposes CRUD operations for the **PartVersion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PartVersions
    * const partVersions = await prisma.partVersion.findMany()
    * ```
    */
  get partVersion(): Prisma.PartVersionDelegate<GlobalReject>;

  /**
   * `prisma.incomingInspectionSpec`: Exposes CRUD operations for the **IncomingInspectionSpec** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IncomingInspectionSpecs
    * const incomingInspectionSpecs = await prisma.incomingInspectionSpec.findMany()
    * ```
    */
  get incomingInspectionSpec(): Prisma.IncomingInspectionSpecDelegate<GlobalReject>;

  /**
   * `prisma.incomingInspectionSpecItem`: Exposes CRUD operations for the **IncomingInspectionSpecItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IncomingInspectionSpecItems
    * const incomingInspectionSpecItems = await prisma.incomingInspectionSpecItem.findMany()
    * ```
    */
  get incomingInspectionSpecItem(): Prisma.IncomingInspectionSpecItemDelegate<GlobalReject>;

  /**
   * `prisma.nonconformItem`: Exposes CRUD operations for the **NonconformItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NonconformItems
    * const nonconformItems = await prisma.nonconformItem.findMany()
    * ```
    */
  get nonconformItem(): Prisma.NonconformItemDelegate<GlobalReject>;

  /**
   * `prisma.partOperation`: Exposes CRUD operations for the **PartOperation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PartOperations
    * const partOperations = await prisma.partOperation.findMany()
    * ```
    */
  get partOperation(): Prisma.PartOperationDelegate<GlobalReject>;

  /**
   * `prisma.partOperationInspectionItem`: Exposes CRUD operations for the **PartOperationInspectionItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PartOperationInspectionItems
    * const partOperationInspectionItems = await prisma.partOperationInspectionItem.findMany()
    * ```
    */
  get partOperationInspectionItem(): Prisma.PartOperationInspectionItemDelegate<GlobalReject>;

  /**
   * `prisma.receipt`: Exposes CRUD operations for the **Receipt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Receipts
    * const receipts = await prisma.receipt.findMany()
    * ```
    */
  get receipt(): Prisma.ReceiptDelegate<GlobalReject>;

  /**
   * `prisma.incomingInspectionRecord`: Exposes CRUD operations for the **IncomingInspectionRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IncomingInspectionRecords
    * const incomingInspectionRecords = await prisma.incomingInspectionRecord.findMany()
    * ```
    */
  get incomingInspectionRecord(): Prisma.IncomingInspectionRecordDelegate<GlobalReject>;

  /**
   * `prisma.incomingInspectionRecordItem`: Exposes CRUD operations for the **IncomingInspectionRecordItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IncomingInspectionRecordItems
    * const incomingInspectionRecordItems = await prisma.incomingInspectionRecordItem.findMany()
    * ```
    */
  get incomingInspectionRecordItem(): Prisma.IncomingInspectionRecordItemDelegate<GlobalReject>;

  /**
   * `prisma.workerOrder`: Exposes CRUD operations for the **WorkerOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkerOrders
    * const workerOrders = await prisma.workerOrder.findMany()
    * ```
    */
  get workerOrder(): Prisma.WorkerOrderDelegate<GlobalReject>;

  /**
   * `prisma.operationInspectionRecord`: Exposes CRUD operations for the **OperationInspectionRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OperationInspectionRecords
    * const operationInspectionRecords = await prisma.operationInspectionRecord.findMany()
    * ```
    */
  get operationInspectionRecord(): Prisma.OperationInspectionRecordDelegate<GlobalReject>;

  /**
   * `prisma.operationInspectionRecordItem`: Exposes CRUD operations for the **OperationInspectionRecordItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OperationInspectionRecordItems
    * const operationInspectionRecordItems = await prisma.operationInspectionRecordItem.findMany()
    * ```
    */
  get operationInspectionRecordItem(): Prisma.OperationInspectionRecordItemDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket


  /**
   * Prisma Client JS version: 4.14.0
   * Query Engine version: d9a4c5988f480fa576d43970d5a23641aa77bc9c
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: runtime.Types.Utils.LegacyExact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    TaskFormRelation: 'TaskFormRelation',
    User: 'User',
    UserProfile: 'UserProfile',
    ProductLine: 'ProductLine',
    Equipment: 'Equipment',
    RepairMaterialInventory: 'RepairMaterialInventory',
    RepairRecord: 'RepairRecord',
    Part: 'Part',
    PartVersion: 'PartVersion',
    IncomingInspectionSpec: 'IncomingInspectionSpec',
    IncomingInspectionSpecItem: 'IncomingInspectionSpecItem',
    NonconformItem: 'NonconformItem',
    PartOperation: 'PartOperation',
    PartOperationInspectionItem: 'PartOperationInspectionItem',
    Receipt: 'Receipt',
    IncomingInspectionRecord: 'IncomingInspectionRecord',
    IncomingInspectionRecordItem: 'IncomingInspectionRecordItem',
    WorkerOrder: 'WorkerOrder',
    OperationInspectionRecord: 'OperationInspectionRecord',
    OperationInspectionRecordItem: 'OperationInspectionRecordItem'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, '$connect' | '$disconnect' | '$on' | '$transaction' | '$use'>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */


  export type UserCountOutputType = {
    reviewedOperationInspectionRecords: number
    inspectedOperationInspectionRecords: number
  }

  export type UserCountOutputTypeSelect = {
    reviewedOperationInspectionRecords?: boolean
    inspectedOperationInspectionRecords?: boolean
  }

  export type UserCountOutputTypeGetPayload<S extends boolean | null | undefined | UserCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? UserCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (UserCountOutputTypeArgs)
    ? UserCountOutputType 
    : S extends { select: any } & (UserCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof UserCountOutputType ? UserCountOutputType[P] : never
  } 
      : UserCountOutputType




  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect | null
  }



  /**
   * Count Type ProductLineCountOutputType
   */


  export type ProductLineCountOutputType = {
    equipment: number
  }

  export type ProductLineCountOutputTypeSelect = {
    equipment?: boolean
  }

  export type ProductLineCountOutputTypeGetPayload<S extends boolean | null | undefined | ProductLineCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ProductLineCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ProductLineCountOutputTypeArgs)
    ? ProductLineCountOutputType 
    : S extends { select: any } & (ProductLineCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ProductLineCountOutputType ? ProductLineCountOutputType[P] : never
  } 
      : ProductLineCountOutputType




  // Custom InputTypes

  /**
   * ProductLineCountOutputType without action
   */
  export type ProductLineCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ProductLineCountOutputType
     */
    select?: ProductLineCountOutputTypeSelect | null
  }



  /**
   * Count Type EquipmentCountOutputType
   */


  export type EquipmentCountOutputType = {
    repairMaterialInventories: number
    repairRecords: number
  }

  export type EquipmentCountOutputTypeSelect = {
    repairMaterialInventories?: boolean
    repairRecords?: boolean
  }

  export type EquipmentCountOutputTypeGetPayload<S extends boolean | null | undefined | EquipmentCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? EquipmentCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (EquipmentCountOutputTypeArgs)
    ? EquipmentCountOutputType 
    : S extends { select: any } & (EquipmentCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof EquipmentCountOutputType ? EquipmentCountOutputType[P] : never
  } 
      : EquipmentCountOutputType




  // Custom InputTypes

  /**
   * EquipmentCountOutputType without action
   */
  export type EquipmentCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the EquipmentCountOutputType
     */
    select?: EquipmentCountOutputTypeSelect | null
  }



  /**
   * Count Type PartCountOutputType
   */


  export type PartCountOutputType = {
    partVersions: number
    partOperation: number
    workerOrders: number
    nonconformItems: number
  }

  export type PartCountOutputTypeSelect = {
    partVersions?: boolean
    partOperation?: boolean
    workerOrders?: boolean
    nonconformItems?: boolean
  }

  export type PartCountOutputTypeGetPayload<S extends boolean | null | undefined | PartCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? PartCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (PartCountOutputTypeArgs)
    ? PartCountOutputType 
    : S extends { select: any } & (PartCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof PartCountOutputType ? PartCountOutputType[P] : never
  } 
      : PartCountOutputType




  // Custom InputTypes

  /**
   * PartCountOutputType without action
   */
  export type PartCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PartCountOutputType
     */
    select?: PartCountOutputTypeSelect | null
  }



  /**
   * Count Type PartVersionCountOutputType
   */


  export type PartVersionCountOutputType = {
    receipts: number
  }

  export type PartVersionCountOutputTypeSelect = {
    receipts?: boolean
  }

  export type PartVersionCountOutputTypeGetPayload<S extends boolean | null | undefined | PartVersionCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? PartVersionCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (PartVersionCountOutputTypeArgs)
    ? PartVersionCountOutputType 
    : S extends { select: any } & (PartVersionCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof PartVersionCountOutputType ? PartVersionCountOutputType[P] : never
  } 
      : PartVersionCountOutputType




  // Custom InputTypes

  /**
   * PartVersionCountOutputType without action
   */
  export type PartVersionCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PartVersionCountOutputType
     */
    select?: PartVersionCountOutputTypeSelect | null
  }



  /**
   * Count Type IncomingInspectionSpecCountOutputType
   */


  export type IncomingInspectionSpecCountOutputType = {
    incomingInspectionSpecItems: number
    incomingInspectionRecords: number
  }

  export type IncomingInspectionSpecCountOutputTypeSelect = {
    incomingInspectionSpecItems?: boolean
    incomingInspectionRecords?: boolean
  }

  export type IncomingInspectionSpecCountOutputTypeGetPayload<S extends boolean | null | undefined | IncomingInspectionSpecCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? IncomingInspectionSpecCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (IncomingInspectionSpecCountOutputTypeArgs)
    ? IncomingInspectionSpecCountOutputType 
    : S extends { select: any } & (IncomingInspectionSpecCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof IncomingInspectionSpecCountOutputType ? IncomingInspectionSpecCountOutputType[P] : never
  } 
      : IncomingInspectionSpecCountOutputType




  // Custom InputTypes

  /**
   * IncomingInspectionSpecCountOutputType without action
   */
  export type IncomingInspectionSpecCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the IncomingInspectionSpecCountOutputType
     */
    select?: IncomingInspectionSpecCountOutputTypeSelect | null
  }



  /**
   * Count Type IncomingInspectionSpecItemCountOutputType
   */


  export type IncomingInspectionSpecItemCountOutputType = {
    incomingInspectionRecordItem: number
  }

  export type IncomingInspectionSpecItemCountOutputTypeSelect = {
    incomingInspectionRecordItem?: boolean
  }

  export type IncomingInspectionSpecItemCountOutputTypeGetPayload<S extends boolean | null | undefined | IncomingInspectionSpecItemCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? IncomingInspectionSpecItemCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (IncomingInspectionSpecItemCountOutputTypeArgs)
    ? IncomingInspectionSpecItemCountOutputType 
    : S extends { select: any } & (IncomingInspectionSpecItemCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof IncomingInspectionSpecItemCountOutputType ? IncomingInspectionSpecItemCountOutputType[P] : never
  } 
      : IncomingInspectionSpecItemCountOutputType




  // Custom InputTypes

  /**
   * IncomingInspectionSpecItemCountOutputType without action
   */
  export type IncomingInspectionSpecItemCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the IncomingInspectionSpecItemCountOutputType
     */
    select?: IncomingInspectionSpecItemCountOutputTypeSelect | null
  }



  /**
   * Count Type PartOperationCountOutputType
   */


  export type PartOperationCountOutputType = {
    partOperationInspectionItems: number
  }

  export type PartOperationCountOutputTypeSelect = {
    partOperationInspectionItems?: boolean
  }

  export type PartOperationCountOutputTypeGetPayload<S extends boolean | null | undefined | PartOperationCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? PartOperationCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (PartOperationCountOutputTypeArgs)
    ? PartOperationCountOutputType 
    : S extends { select: any } & (PartOperationCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof PartOperationCountOutputType ? PartOperationCountOutputType[P] : never
  } 
      : PartOperationCountOutputType




  // Custom InputTypes

  /**
   * PartOperationCountOutputType without action
   */
  export type PartOperationCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PartOperationCountOutputType
     */
    select?: PartOperationCountOutputTypeSelect | null
  }



  /**
   * Count Type PartOperationInspectionItemCountOutputType
   */


  export type PartOperationInspectionItemCountOutputType = {
    operationInspectionRecordItems: number
  }

  export type PartOperationInspectionItemCountOutputTypeSelect = {
    operationInspectionRecordItems?: boolean
  }

  export type PartOperationInspectionItemCountOutputTypeGetPayload<S extends boolean | null | undefined | PartOperationInspectionItemCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? PartOperationInspectionItemCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (PartOperationInspectionItemCountOutputTypeArgs)
    ? PartOperationInspectionItemCountOutputType 
    : S extends { select: any } & (PartOperationInspectionItemCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof PartOperationInspectionItemCountOutputType ? PartOperationInspectionItemCountOutputType[P] : never
  } 
      : PartOperationInspectionItemCountOutputType




  // Custom InputTypes

  /**
   * PartOperationInspectionItemCountOutputType without action
   */
  export type PartOperationInspectionItemCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PartOperationInspectionItemCountOutputType
     */
    select?: PartOperationInspectionItemCountOutputTypeSelect | null
  }



  /**
   * Count Type IncomingInspectionRecordCountOutputType
   */


  export type IncomingInspectionRecordCountOutputType = {
    incomingInspectionRecordItems: number
  }

  export type IncomingInspectionRecordCountOutputTypeSelect = {
    incomingInspectionRecordItems?: boolean
  }

  export type IncomingInspectionRecordCountOutputTypeGetPayload<S extends boolean | null | undefined | IncomingInspectionRecordCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? IncomingInspectionRecordCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (IncomingInspectionRecordCountOutputTypeArgs)
    ? IncomingInspectionRecordCountOutputType 
    : S extends { select: any } & (IncomingInspectionRecordCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof IncomingInspectionRecordCountOutputType ? IncomingInspectionRecordCountOutputType[P] : never
  } 
      : IncomingInspectionRecordCountOutputType




  // Custom InputTypes

  /**
   * IncomingInspectionRecordCountOutputType without action
   */
  export type IncomingInspectionRecordCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the IncomingInspectionRecordCountOutputType
     */
    select?: IncomingInspectionRecordCountOutputTypeSelect | null
  }



  /**
   * Count Type WorkerOrderCountOutputType
   */


  export type WorkerOrderCountOutputType = {
    operationInspectionRecords: number
  }

  export type WorkerOrderCountOutputTypeSelect = {
    operationInspectionRecords?: boolean
  }

  export type WorkerOrderCountOutputTypeGetPayload<S extends boolean | null | undefined | WorkerOrderCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? WorkerOrderCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (WorkerOrderCountOutputTypeArgs)
    ? WorkerOrderCountOutputType 
    : S extends { select: any } & (WorkerOrderCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof WorkerOrderCountOutputType ? WorkerOrderCountOutputType[P] : never
  } 
      : WorkerOrderCountOutputType




  // Custom InputTypes

  /**
   * WorkerOrderCountOutputType without action
   */
  export type WorkerOrderCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the WorkerOrderCountOutputType
     */
    select?: WorkerOrderCountOutputTypeSelect | null
  }



  /**
   * Count Type OperationInspectionRecordCountOutputType
   */


  export type OperationInspectionRecordCountOutputType = {
    operationInspectionRecordItems: number
  }

  export type OperationInspectionRecordCountOutputTypeSelect = {
    operationInspectionRecordItems?: boolean
  }

  export type OperationInspectionRecordCountOutputTypeGetPayload<S extends boolean | null | undefined | OperationInspectionRecordCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? OperationInspectionRecordCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (OperationInspectionRecordCountOutputTypeArgs)
    ? OperationInspectionRecordCountOutputType 
    : S extends { select: any } & (OperationInspectionRecordCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof OperationInspectionRecordCountOutputType ? OperationInspectionRecordCountOutputType[P] : never
  } 
      : OperationInspectionRecordCountOutputType




  // Custom InputTypes

  /**
   * OperationInspectionRecordCountOutputType without action
   */
  export type OperationInspectionRecordCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the OperationInspectionRecordCountOutputType
     */
    select?: OperationInspectionRecordCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model TaskFormRelation
   */


  export type AggregateTaskFormRelation = {
    _count: TaskFormRelationCountAggregateOutputType | null
    _avg: TaskFormRelationAvgAggregateOutputType | null
    _sum: TaskFormRelationSumAggregateOutputType | null
    _min: TaskFormRelationMinAggregateOutputType | null
    _max: TaskFormRelationMaxAggregateOutputType | null
  }

  export type TaskFormRelationAvgAggregateOutputType = {
    id: number | null
  }

  export type TaskFormRelationSumAggregateOutputType = {
    id: number | null
  }

  export type TaskFormRelationMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    taskDefinitionKey: string | null
    formKey: string | null
  }

  export type TaskFormRelationMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    taskDefinitionKey: string | null
    formKey: string | null
  }

  export type TaskFormRelationCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    isDeleted: number
    taskDefinitionKey: number
    formKey: number
    _all: number
  }


  export type TaskFormRelationAvgAggregateInputType = {
    id?: true
  }

  export type TaskFormRelationSumAggregateInputType = {
    id?: true
  }

  export type TaskFormRelationMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    taskDefinitionKey?: true
    formKey?: true
  }

  export type TaskFormRelationMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    taskDefinitionKey?: true
    formKey?: true
  }

  export type TaskFormRelationCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    taskDefinitionKey?: true
    formKey?: true
    _all?: true
  }

  export type TaskFormRelationAggregateArgs = {
    /**
     * Filter which TaskFormRelation to aggregate.
     */
    where?: TaskFormRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskFormRelations to fetch.
     */
    orderBy?: Enumerable<TaskFormRelationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskFormRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskFormRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskFormRelations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskFormRelations
    **/
    _count?: true | TaskFormRelationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaskFormRelationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaskFormRelationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskFormRelationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskFormRelationMaxAggregateInputType
  }

  export type GetTaskFormRelationAggregateType<T extends TaskFormRelationAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskFormRelation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskFormRelation[P]>
      : GetScalarType<T[P], AggregateTaskFormRelation[P]>
  }




  export type TaskFormRelationGroupByArgs = {
    where?: TaskFormRelationWhereInput
    orderBy?: Enumerable<TaskFormRelationOrderByWithAggregationInput>
    by: TaskFormRelationScalarFieldEnum[]
    having?: TaskFormRelationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskFormRelationCountAggregateInputType | true
    _avg?: TaskFormRelationAvgAggregateInputType
    _sum?: TaskFormRelationSumAggregateInputType
    _min?: TaskFormRelationMinAggregateInputType
    _max?: TaskFormRelationMaxAggregateInputType
  }


  export type TaskFormRelationGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    isDeleted: boolean
    taskDefinitionKey: string
    formKey: string
    _count: TaskFormRelationCountAggregateOutputType | null
    _avg: TaskFormRelationAvgAggregateOutputType | null
    _sum: TaskFormRelationSumAggregateOutputType | null
    _min: TaskFormRelationMinAggregateOutputType | null
    _max: TaskFormRelationMaxAggregateOutputType | null
  }

  type GetTaskFormRelationGroupByPayload<T extends TaskFormRelationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TaskFormRelationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskFormRelationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskFormRelationGroupByOutputType[P]>
            : GetScalarType<T[P], TaskFormRelationGroupByOutputType[P]>
        }
      >
    >


  export type TaskFormRelationSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    taskDefinitionKey?: boolean
    formKey?: boolean
  }


  export type TaskFormRelationGetPayload<S extends boolean | null | undefined | TaskFormRelationArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TaskFormRelation :
    S extends undefined ? never :
    S extends { include: any } & (TaskFormRelationArgs | TaskFormRelationFindManyArgs)
    ? TaskFormRelation 
    : S extends { select: any } & (TaskFormRelationArgs | TaskFormRelationFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TaskFormRelation ? TaskFormRelation[P] : never
  } 
      : TaskFormRelation


  type TaskFormRelationCountArgs = 
    Omit<TaskFormRelationFindManyArgs, 'select' | 'include'> & {
      select?: TaskFormRelationCountAggregateInputType | true
    }

  export interface TaskFormRelationDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one TaskFormRelation that matches the filter.
     * @param {TaskFormRelationFindUniqueArgs} args - Arguments to find a TaskFormRelation
     * @example
     * // Get one TaskFormRelation
     * const taskFormRelation = await prisma.taskFormRelation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TaskFormRelationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TaskFormRelationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TaskFormRelation'> extends True ? Prisma__TaskFormRelationClient<TaskFormRelationGetPayload<T>> : Prisma__TaskFormRelationClient<TaskFormRelationGetPayload<T> | null, null>

    /**
     * Find one TaskFormRelation that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TaskFormRelationFindUniqueOrThrowArgs} args - Arguments to find a TaskFormRelation
     * @example
     * // Get one TaskFormRelation
     * const taskFormRelation = await prisma.taskFormRelation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TaskFormRelationFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TaskFormRelationFindUniqueOrThrowArgs>
    ): Prisma__TaskFormRelationClient<TaskFormRelationGetPayload<T>>

    /**
     * Find the first TaskFormRelation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFormRelationFindFirstArgs} args - Arguments to find a TaskFormRelation
     * @example
     * // Get one TaskFormRelation
     * const taskFormRelation = await prisma.taskFormRelation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TaskFormRelationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TaskFormRelationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TaskFormRelation'> extends True ? Prisma__TaskFormRelationClient<TaskFormRelationGetPayload<T>> : Prisma__TaskFormRelationClient<TaskFormRelationGetPayload<T> | null, null>

    /**
     * Find the first TaskFormRelation that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFormRelationFindFirstOrThrowArgs} args - Arguments to find a TaskFormRelation
     * @example
     * // Get one TaskFormRelation
     * const taskFormRelation = await prisma.taskFormRelation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TaskFormRelationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TaskFormRelationFindFirstOrThrowArgs>
    ): Prisma__TaskFormRelationClient<TaskFormRelationGetPayload<T>>

    /**
     * Find zero or more TaskFormRelations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFormRelationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskFormRelations
     * const taskFormRelations = await prisma.taskFormRelation.findMany()
     * 
     * // Get first 10 TaskFormRelations
     * const taskFormRelations = await prisma.taskFormRelation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskFormRelationWithIdOnly = await prisma.taskFormRelation.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TaskFormRelationFindManyArgs>(
      args?: SelectSubset<T, TaskFormRelationFindManyArgs>
    ): Prisma.PrismaPromise<Array<TaskFormRelationGetPayload<T>>>

    /**
     * Create a TaskFormRelation.
     * @param {TaskFormRelationCreateArgs} args - Arguments to create a TaskFormRelation.
     * @example
     * // Create one TaskFormRelation
     * const TaskFormRelation = await prisma.taskFormRelation.create({
     *   data: {
     *     // ... data to create a TaskFormRelation
     *   }
     * })
     * 
    **/
    create<T extends TaskFormRelationCreateArgs>(
      args: SelectSubset<T, TaskFormRelationCreateArgs>
    ): Prisma__TaskFormRelationClient<TaskFormRelationGetPayload<T>>

    /**
     * Create many TaskFormRelations.
     *     @param {TaskFormRelationCreateManyArgs} args - Arguments to create many TaskFormRelations.
     *     @example
     *     // Create many TaskFormRelations
     *     const taskFormRelation = await prisma.taskFormRelation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TaskFormRelationCreateManyArgs>(
      args?: SelectSubset<T, TaskFormRelationCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TaskFormRelation.
     * @param {TaskFormRelationDeleteArgs} args - Arguments to delete one TaskFormRelation.
     * @example
     * // Delete one TaskFormRelation
     * const TaskFormRelation = await prisma.taskFormRelation.delete({
     *   where: {
     *     // ... filter to delete one TaskFormRelation
     *   }
     * })
     * 
    **/
    delete<T extends TaskFormRelationDeleteArgs>(
      args: SelectSubset<T, TaskFormRelationDeleteArgs>
    ): Prisma__TaskFormRelationClient<TaskFormRelationGetPayload<T>>

    /**
     * Update one TaskFormRelation.
     * @param {TaskFormRelationUpdateArgs} args - Arguments to update one TaskFormRelation.
     * @example
     * // Update one TaskFormRelation
     * const taskFormRelation = await prisma.taskFormRelation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TaskFormRelationUpdateArgs>(
      args: SelectSubset<T, TaskFormRelationUpdateArgs>
    ): Prisma__TaskFormRelationClient<TaskFormRelationGetPayload<T>>

    /**
     * Delete zero or more TaskFormRelations.
     * @param {TaskFormRelationDeleteManyArgs} args - Arguments to filter TaskFormRelations to delete.
     * @example
     * // Delete a few TaskFormRelations
     * const { count } = await prisma.taskFormRelation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TaskFormRelationDeleteManyArgs>(
      args?: SelectSubset<T, TaskFormRelationDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskFormRelations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFormRelationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskFormRelations
     * const taskFormRelation = await prisma.taskFormRelation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TaskFormRelationUpdateManyArgs>(
      args: SelectSubset<T, TaskFormRelationUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TaskFormRelation.
     * @param {TaskFormRelationUpsertArgs} args - Arguments to update or create a TaskFormRelation.
     * @example
     * // Update or create a TaskFormRelation
     * const taskFormRelation = await prisma.taskFormRelation.upsert({
     *   create: {
     *     // ... data to create a TaskFormRelation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskFormRelation we want to update
     *   }
     * })
    **/
    upsert<T extends TaskFormRelationUpsertArgs>(
      args: SelectSubset<T, TaskFormRelationUpsertArgs>
    ): Prisma__TaskFormRelationClient<TaskFormRelationGetPayload<T>>

    /**
     * Count the number of TaskFormRelations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFormRelationCountArgs} args - Arguments to filter TaskFormRelations to count.
     * @example
     * // Count the number of TaskFormRelations
     * const count = await prisma.taskFormRelation.count({
     *   where: {
     *     // ... the filter for the TaskFormRelations we want to count
     *   }
     * })
    **/
    count<T extends TaskFormRelationCountArgs>(
      args?: Subset<T, TaskFormRelationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskFormRelationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskFormRelation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFormRelationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskFormRelationAggregateArgs>(args: Subset<T, TaskFormRelationAggregateArgs>): Prisma.PrismaPromise<GetTaskFormRelationAggregateType<T>>

    /**
     * Group by TaskFormRelation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFormRelationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskFormRelationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskFormRelationGroupByArgs['orderBy'] }
        : { orderBy?: TaskFormRelationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskFormRelationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskFormRelationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskFormRelation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TaskFormRelationClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TaskFormRelation base type for findUnique actions
   */
  export type TaskFormRelationFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TaskFormRelation
     */
    select?: TaskFormRelationSelect | null
    /**
     * Filter, which TaskFormRelation to fetch.
     */
    where: TaskFormRelationWhereUniqueInput
  }

  /**
   * TaskFormRelation findUnique
   */
  export interface TaskFormRelationFindUniqueArgs extends TaskFormRelationFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TaskFormRelation findUniqueOrThrow
   */
  export type TaskFormRelationFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TaskFormRelation
     */
    select?: TaskFormRelationSelect | null
    /**
     * Filter, which TaskFormRelation to fetch.
     */
    where: TaskFormRelationWhereUniqueInput
  }


  /**
   * TaskFormRelation base type for findFirst actions
   */
  export type TaskFormRelationFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TaskFormRelation
     */
    select?: TaskFormRelationSelect | null
    /**
     * Filter, which TaskFormRelation to fetch.
     */
    where?: TaskFormRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskFormRelations to fetch.
     */
    orderBy?: Enumerable<TaskFormRelationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskFormRelations.
     */
    cursor?: TaskFormRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskFormRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskFormRelations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskFormRelations.
     */
    distinct?: Enumerable<TaskFormRelationScalarFieldEnum>
  }

  /**
   * TaskFormRelation findFirst
   */
  export interface TaskFormRelationFindFirstArgs extends TaskFormRelationFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TaskFormRelation findFirstOrThrow
   */
  export type TaskFormRelationFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TaskFormRelation
     */
    select?: TaskFormRelationSelect | null
    /**
     * Filter, which TaskFormRelation to fetch.
     */
    where?: TaskFormRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskFormRelations to fetch.
     */
    orderBy?: Enumerable<TaskFormRelationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskFormRelations.
     */
    cursor?: TaskFormRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskFormRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskFormRelations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskFormRelations.
     */
    distinct?: Enumerable<TaskFormRelationScalarFieldEnum>
  }


  /**
   * TaskFormRelation findMany
   */
  export type TaskFormRelationFindManyArgs = {
    /**
     * Select specific fields to fetch from the TaskFormRelation
     */
    select?: TaskFormRelationSelect | null
    /**
     * Filter, which TaskFormRelations to fetch.
     */
    where?: TaskFormRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskFormRelations to fetch.
     */
    orderBy?: Enumerable<TaskFormRelationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskFormRelations.
     */
    cursor?: TaskFormRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskFormRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskFormRelations.
     */
    skip?: number
    distinct?: Enumerable<TaskFormRelationScalarFieldEnum>
  }


  /**
   * TaskFormRelation create
   */
  export type TaskFormRelationCreateArgs = {
    /**
     * Select specific fields to fetch from the TaskFormRelation
     */
    select?: TaskFormRelationSelect | null
    /**
     * The data needed to create a TaskFormRelation.
     */
    data: XOR<TaskFormRelationCreateInput, TaskFormRelationUncheckedCreateInput>
  }


  /**
   * TaskFormRelation createMany
   */
  export type TaskFormRelationCreateManyArgs = {
    /**
     * The data used to create many TaskFormRelations.
     */
    data: Enumerable<TaskFormRelationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TaskFormRelation update
   */
  export type TaskFormRelationUpdateArgs = {
    /**
     * Select specific fields to fetch from the TaskFormRelation
     */
    select?: TaskFormRelationSelect | null
    /**
     * The data needed to update a TaskFormRelation.
     */
    data: XOR<TaskFormRelationUpdateInput, TaskFormRelationUncheckedUpdateInput>
    /**
     * Choose, which TaskFormRelation to update.
     */
    where: TaskFormRelationWhereUniqueInput
  }


  /**
   * TaskFormRelation updateMany
   */
  export type TaskFormRelationUpdateManyArgs = {
    /**
     * The data used to update TaskFormRelations.
     */
    data: XOR<TaskFormRelationUpdateManyMutationInput, TaskFormRelationUncheckedUpdateManyInput>
    /**
     * Filter which TaskFormRelations to update
     */
    where?: TaskFormRelationWhereInput
  }


  /**
   * TaskFormRelation upsert
   */
  export type TaskFormRelationUpsertArgs = {
    /**
     * Select specific fields to fetch from the TaskFormRelation
     */
    select?: TaskFormRelationSelect | null
    /**
     * The filter to search for the TaskFormRelation to update in case it exists.
     */
    where: TaskFormRelationWhereUniqueInput
    /**
     * In case the TaskFormRelation found by the `where` argument doesn't exist, create a new TaskFormRelation with this data.
     */
    create: XOR<TaskFormRelationCreateInput, TaskFormRelationUncheckedCreateInput>
    /**
     * In case the TaskFormRelation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskFormRelationUpdateInput, TaskFormRelationUncheckedUpdateInput>
  }


  /**
   * TaskFormRelation delete
   */
  export type TaskFormRelationDeleteArgs = {
    /**
     * Select specific fields to fetch from the TaskFormRelation
     */
    select?: TaskFormRelationSelect | null
    /**
     * Filter which TaskFormRelation to delete.
     */
    where: TaskFormRelationWhereUniqueInput
  }


  /**
   * TaskFormRelation deleteMany
   */
  export type TaskFormRelationDeleteManyArgs = {
    /**
     * Filter which TaskFormRelations to delete
     */
    where?: TaskFormRelationWhereInput
  }


  /**
   * TaskFormRelation without action
   */
  export type TaskFormRelationArgs = {
    /**
     * Select specific fields to fetch from the TaskFormRelation
     */
    select?: TaskFormRelationSelect | null
  }



  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    username: string | null
    hashedPassword: string | null
    hashedRefreshToken: string | null
    status: UserStatus | null
    role: UserGroup | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    username: string | null
    hashedPassword: string | null
    hashedRefreshToken: string | null
    status: UserStatus | null
    role: UserGroup | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    isDeleted: number
    username: number
    hashedPassword: number
    hashedRefreshToken: number
    status: number
    role: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    username?: true
    hashedPassword?: true
    hashedRefreshToken?: true
    status?: true
    role?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    username?: true
    hashedPassword?: true
    hashedRefreshToken?: true
    status?: true
    role?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    username?: true
    hashedPassword?: true
    hashedRefreshToken?: true
    status?: true
    role?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithAggregationInput>
    by: UserScalarFieldEnum[]
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    isDeleted: boolean
    username: string
    hashedPassword: string | null
    hashedRefreshToken: string | null
    status: UserStatus
    role: UserGroup
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    username?: boolean
    hashedPassword?: boolean
    hashedRefreshToken?: boolean
    status?: boolean
    role?: boolean
    profile?: boolean | UserProfileArgs
    reviewedOperationInspectionRecords?: boolean | User$reviewedOperationInspectionRecordsArgs
    inspectedOperationInspectionRecords?: boolean | User$inspectedOperationInspectionRecordsArgs
    _count?: boolean | UserCountOutputTypeArgs
  }


  export type UserInclude = {
    profile?: boolean | UserProfileArgs
    reviewedOperationInspectionRecords?: boolean | User$reviewedOperationInspectionRecordsArgs
    inspectedOperationInspectionRecords?: boolean | User$inspectedOperationInspectionRecordsArgs
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type UserGetPayload<S extends boolean | null | undefined | UserArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? User :
    S extends undefined ? never :
    S extends { include: any } & (UserArgs | UserFindManyArgs)
    ? User  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'profile' ? UserProfileGetPayload<S['include'][P]> | null :
        P extends 'reviewedOperationInspectionRecords' ? Array < OperationInspectionRecordGetPayload<S['include'][P]>>  :
        P extends 'inspectedOperationInspectionRecords' ? Array < OperationInspectionRecordGetPayload<S['include'][P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (UserArgs | UserFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'profile' ? UserProfileGetPayload<S['select'][P]> | null :
        P extends 'reviewedOperationInspectionRecords' ? Array < OperationInspectionRecordGetPayload<S['select'][P]>>  :
        P extends 'inspectedOperationInspectionRecords' ? Array < OperationInspectionRecordGetPayload<S['select'][P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof User ? User[P] : never
  } 
      : User


  type UserCountArgs = 
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? Prisma__UserClient<UserGetPayload<T>> : Prisma__UserClient<UserGetPayload<T> | null, null>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? Prisma__UserClient<UserGetPayload<T>> : Prisma__UserClient<UserGetPayload<T> | null, null>

    /**
     * Find the first User that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs>
    ): Prisma.PrismaPromise<Array<UserGetPayload<T>>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    profile<T extends UserProfileArgs= {}>(args?: Subset<T, UserProfileArgs>): Prisma__UserProfileClient<UserProfileGetPayload<T> | Null>;

    reviewedOperationInspectionRecords<T extends User$reviewedOperationInspectionRecordsArgs= {}>(args?: Subset<T, User$reviewedOperationInspectionRecordsArgs>): Prisma.PrismaPromise<Array<OperationInspectionRecordGetPayload<T>>| Null>;

    inspectedOperationInspectionRecords<T extends User$inspectedOperationInspectionRecordsArgs= {}>(args?: Subset<T, User$inspectedOperationInspectionRecordsArgs>): Prisma.PrismaPromise<Array<OperationInspectionRecordGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * User base type for findUnique actions
   */
  export type UserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUnique
   */
  export interface UserFindUniqueArgs extends UserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User base type for findFirst actions
   */
  export type UserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }

  /**
   * User findFirst
   */
  export interface UserFindFirstArgs extends UserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs = {
    /**
     * The data used to create many Users.
     */
    data: Enumerable<UserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User.reviewedOperationInspectionRecords
   */
  export type User$reviewedOperationInspectionRecordsArgs = {
    /**
     * Select specific fields to fetch from the OperationInspectionRecord
     */
    select?: OperationInspectionRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OperationInspectionRecordInclude | null
    where?: OperationInspectionRecordWhereInput
    orderBy?: Enumerable<OperationInspectionRecordOrderByWithRelationInput>
    cursor?: OperationInspectionRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<OperationInspectionRecordScalarFieldEnum>
  }


  /**
   * User.inspectedOperationInspectionRecords
   */
  export type User$inspectedOperationInspectionRecordsArgs = {
    /**
     * Select specific fields to fetch from the OperationInspectionRecord
     */
    select?: OperationInspectionRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OperationInspectionRecordInclude | null
    where?: OperationInspectionRecordWhereInput
    orderBy?: Enumerable<OperationInspectionRecordOrderByWithRelationInput>
    cursor?: OperationInspectionRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<OperationInspectionRecordScalarFieldEnum>
  }


  /**
   * User without action
   */
  export type UserArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
  }



  /**
   * Model UserProfile
   */


  export type AggregateUserProfile = {
    _count: UserProfileCountAggregateOutputType | null
    _avg: UserProfileAvgAggregateOutputType | null
    _sum: UserProfileSumAggregateOutputType | null
    _min: UserProfileMinAggregateOutputType | null
    _max: UserProfileMaxAggregateOutputType | null
  }

  export type UserProfileAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type UserProfileSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type UserProfileMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    userId: number | null
    fullName: string | null
  }

  export type UserProfileMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    userId: number | null
    fullName: string | null
  }

  export type UserProfileCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    isDeleted: number
    userId: number
    fullName: number
    _all: number
  }


  export type UserProfileAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type UserProfileSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type UserProfileMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    userId?: true
    fullName?: true
  }

  export type UserProfileMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    userId?: true
    fullName?: true
  }

  export type UserProfileCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    userId?: true
    fullName?: true
    _all?: true
  }

  export type UserProfileAggregateArgs = {
    /**
     * Filter which UserProfile to aggregate.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: Enumerable<UserProfileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserProfiles
    **/
    _count?: true | UserProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserProfileMaxAggregateInputType
  }

  export type GetUserProfileAggregateType<T extends UserProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateUserProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserProfile[P]>
      : GetScalarType<T[P], AggregateUserProfile[P]>
  }




  export type UserProfileGroupByArgs = {
    where?: UserProfileWhereInput
    orderBy?: Enumerable<UserProfileOrderByWithAggregationInput>
    by: UserProfileScalarFieldEnum[]
    having?: UserProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserProfileCountAggregateInputType | true
    _avg?: UserProfileAvgAggregateInputType
    _sum?: UserProfileSumAggregateInputType
    _min?: UserProfileMinAggregateInputType
    _max?: UserProfileMaxAggregateInputType
  }


  export type UserProfileGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    isDeleted: boolean
    userId: number
    fullName: string
    _count: UserProfileCountAggregateOutputType | null
    _avg: UserProfileAvgAggregateOutputType | null
    _sum: UserProfileSumAggregateOutputType | null
    _min: UserProfileMinAggregateOutputType | null
    _max: UserProfileMaxAggregateOutputType | null
  }

  type GetUserProfileGroupByPayload<T extends UserProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserProfileGroupByOutputType[P]>
            : GetScalarType<T[P], UserProfileGroupByOutputType[P]>
        }
      >
    >


  export type UserProfileSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    userId?: boolean
    fullName?: boolean
    user?: boolean | UserArgs
  }


  export type UserProfileInclude = {
    user?: boolean | UserArgs
  }

  export type UserProfileGetPayload<S extends boolean | null | undefined | UserProfileArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? UserProfile :
    S extends undefined ? never :
    S extends { include: any } & (UserProfileArgs | UserProfileFindManyArgs)
    ? UserProfile  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (UserProfileArgs | UserProfileFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :  P extends keyof UserProfile ? UserProfile[P] : never
  } 
      : UserProfile


  type UserProfileCountArgs = 
    Omit<UserProfileFindManyArgs, 'select' | 'include'> & {
      select?: UserProfileCountAggregateInputType | true
    }

  export interface UserProfileDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one UserProfile that matches the filter.
     * @param {UserProfileFindUniqueArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserProfileFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserProfileFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserProfile'> extends True ? Prisma__UserProfileClient<UserProfileGetPayload<T>> : Prisma__UserProfileClient<UserProfileGetPayload<T> | null, null>

    /**
     * Find one UserProfile that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserProfileFindUniqueOrThrowArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserProfileFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserProfileFindUniqueOrThrowArgs>
    ): Prisma__UserProfileClient<UserProfileGetPayload<T>>

    /**
     * Find the first UserProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFindFirstArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserProfileFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserProfileFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserProfile'> extends True ? Prisma__UserProfileClient<UserProfileGetPayload<T>> : Prisma__UserProfileClient<UserProfileGetPayload<T> | null, null>

    /**
     * Find the first UserProfile that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFindFirstOrThrowArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserProfileFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserProfileFindFirstOrThrowArgs>
    ): Prisma__UserProfileClient<UserProfileGetPayload<T>>

    /**
     * Find zero or more UserProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserProfiles
     * const userProfiles = await prisma.userProfile.findMany()
     * 
     * // Get first 10 UserProfiles
     * const userProfiles = await prisma.userProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userProfileWithIdOnly = await prisma.userProfile.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserProfileFindManyArgs>(
      args?: SelectSubset<T, UserProfileFindManyArgs>
    ): Prisma.PrismaPromise<Array<UserProfileGetPayload<T>>>

    /**
     * Create a UserProfile.
     * @param {UserProfileCreateArgs} args - Arguments to create a UserProfile.
     * @example
     * // Create one UserProfile
     * const UserProfile = await prisma.userProfile.create({
     *   data: {
     *     // ... data to create a UserProfile
     *   }
     * })
     * 
    **/
    create<T extends UserProfileCreateArgs>(
      args: SelectSubset<T, UserProfileCreateArgs>
    ): Prisma__UserProfileClient<UserProfileGetPayload<T>>

    /**
     * Create many UserProfiles.
     *     @param {UserProfileCreateManyArgs} args - Arguments to create many UserProfiles.
     *     @example
     *     // Create many UserProfiles
     *     const userProfile = await prisma.userProfile.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserProfileCreateManyArgs>(
      args?: SelectSubset<T, UserProfileCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserProfile.
     * @param {UserProfileDeleteArgs} args - Arguments to delete one UserProfile.
     * @example
     * // Delete one UserProfile
     * const UserProfile = await prisma.userProfile.delete({
     *   where: {
     *     // ... filter to delete one UserProfile
     *   }
     * })
     * 
    **/
    delete<T extends UserProfileDeleteArgs>(
      args: SelectSubset<T, UserProfileDeleteArgs>
    ): Prisma__UserProfileClient<UserProfileGetPayload<T>>

    /**
     * Update one UserProfile.
     * @param {UserProfileUpdateArgs} args - Arguments to update one UserProfile.
     * @example
     * // Update one UserProfile
     * const userProfile = await prisma.userProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserProfileUpdateArgs>(
      args: SelectSubset<T, UserProfileUpdateArgs>
    ): Prisma__UserProfileClient<UserProfileGetPayload<T>>

    /**
     * Delete zero or more UserProfiles.
     * @param {UserProfileDeleteManyArgs} args - Arguments to filter UserProfiles to delete.
     * @example
     * // Delete a few UserProfiles
     * const { count } = await prisma.userProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserProfileDeleteManyArgs>(
      args?: SelectSubset<T, UserProfileDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserProfiles
     * const userProfile = await prisma.userProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserProfileUpdateManyArgs>(
      args: SelectSubset<T, UserProfileUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserProfile.
     * @param {UserProfileUpsertArgs} args - Arguments to update or create a UserProfile.
     * @example
     * // Update or create a UserProfile
     * const userProfile = await prisma.userProfile.upsert({
     *   create: {
     *     // ... data to create a UserProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserProfile we want to update
     *   }
     * })
    **/
    upsert<T extends UserProfileUpsertArgs>(
      args: SelectSubset<T, UserProfileUpsertArgs>
    ): Prisma__UserProfileClient<UserProfileGetPayload<T>>

    /**
     * Count the number of UserProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileCountArgs} args - Arguments to filter UserProfiles to count.
     * @example
     * // Count the number of UserProfiles
     * const count = await prisma.userProfile.count({
     *   where: {
     *     // ... the filter for the UserProfiles we want to count
     *   }
     * })
    **/
    count<T extends UserProfileCountArgs>(
      args?: Subset<T, UserProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserProfileAggregateArgs>(args: Subset<T, UserProfileAggregateArgs>): Prisma.PrismaPromise<GetUserProfileAggregateType<T>>

    /**
     * Group by UserProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserProfileGroupByArgs['orderBy'] }
        : { orderBy?: UserProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for UserProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserProfileClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * UserProfile base type for findUnique actions
   */
  export type UserProfileFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserProfileInclude | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile findUnique
   */
  export interface UserProfileFindUniqueArgs extends UserProfileFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserProfile findUniqueOrThrow
   */
  export type UserProfileFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserProfileInclude | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where: UserProfileWhereUniqueInput
  }


  /**
   * UserProfile base type for findFirst actions
   */
  export type UserProfileFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserProfileInclude | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: Enumerable<UserProfileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProfiles.
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProfiles.
     */
    distinct?: Enumerable<UserProfileScalarFieldEnum>
  }

  /**
   * UserProfile findFirst
   */
  export interface UserProfileFindFirstArgs extends UserProfileFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserProfile findFirstOrThrow
   */
  export type UserProfileFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserProfileInclude | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: Enumerable<UserProfileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProfiles.
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProfiles.
     */
    distinct?: Enumerable<UserProfileScalarFieldEnum>
  }


  /**
   * UserProfile findMany
   */
  export type UserProfileFindManyArgs = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserProfileInclude | null
    /**
     * Filter, which UserProfiles to fetch.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: Enumerable<UserProfileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserProfiles.
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    distinct?: Enumerable<UserProfileScalarFieldEnum>
  }


  /**
   * UserProfile create
   */
  export type UserProfileCreateArgs = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserProfileInclude | null
    /**
     * The data needed to create a UserProfile.
     */
    data: XOR<UserProfileCreateInput, UserProfileUncheckedCreateInput>
  }


  /**
   * UserProfile createMany
   */
  export type UserProfileCreateManyArgs = {
    /**
     * The data used to create many UserProfiles.
     */
    data: Enumerable<UserProfileCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UserProfile update
   */
  export type UserProfileUpdateArgs = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserProfileInclude | null
    /**
     * The data needed to update a UserProfile.
     */
    data: XOR<UserProfileUpdateInput, UserProfileUncheckedUpdateInput>
    /**
     * Choose, which UserProfile to update.
     */
    where: UserProfileWhereUniqueInput
  }


  /**
   * UserProfile updateMany
   */
  export type UserProfileUpdateManyArgs = {
    /**
     * The data used to update UserProfiles.
     */
    data: XOR<UserProfileUpdateManyMutationInput, UserProfileUncheckedUpdateManyInput>
    /**
     * Filter which UserProfiles to update
     */
    where?: UserProfileWhereInput
  }


  /**
   * UserProfile upsert
   */
  export type UserProfileUpsertArgs = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserProfileInclude | null
    /**
     * The filter to search for the UserProfile to update in case it exists.
     */
    where: UserProfileWhereUniqueInput
    /**
     * In case the UserProfile found by the `where` argument doesn't exist, create a new UserProfile with this data.
     */
    create: XOR<UserProfileCreateInput, UserProfileUncheckedCreateInput>
    /**
     * In case the UserProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserProfileUpdateInput, UserProfileUncheckedUpdateInput>
  }


  /**
   * UserProfile delete
   */
  export type UserProfileDeleteArgs = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserProfileInclude | null
    /**
     * Filter which UserProfile to delete.
     */
    where: UserProfileWhereUniqueInput
  }


  /**
   * UserProfile deleteMany
   */
  export type UserProfileDeleteManyArgs = {
    /**
     * Filter which UserProfiles to delete
     */
    where?: UserProfileWhereInput
  }


  /**
   * UserProfile without action
   */
  export type UserProfileArgs = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserProfileInclude | null
  }



  /**
   * Model ProductLine
   */


  export type AggregateProductLine = {
    _count: ProductLineCountAggregateOutputType | null
    _avg: ProductLineAvgAggregateOutputType | null
    _sum: ProductLineSumAggregateOutputType | null
    _min: ProductLineMinAggregateOutputType | null
    _max: ProductLineMaxAggregateOutputType | null
  }

  export type ProductLineAvgAggregateOutputType = {
    id: number | null
  }

  export type ProductLineSumAggregateOutputType = {
    id: number | null
  }

  export type ProductLineMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    name: string | null
    description: string | null
  }

  export type ProductLineMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    name: string | null
    description: string | null
  }

  export type ProductLineCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    isDeleted: number
    name: number
    description: number
    _all: number
  }


  export type ProductLineAvgAggregateInputType = {
    id?: true
  }

  export type ProductLineSumAggregateInputType = {
    id?: true
  }

  export type ProductLineMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    name?: true
    description?: true
  }

  export type ProductLineMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    name?: true
    description?: true
  }

  export type ProductLineCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    name?: true
    description?: true
    _all?: true
  }

  export type ProductLineAggregateArgs = {
    /**
     * Filter which ProductLine to aggregate.
     */
    where?: ProductLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductLines to fetch.
     */
    orderBy?: Enumerable<ProductLineOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductLines
    **/
    _count?: true | ProductLineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductLineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductLineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductLineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductLineMaxAggregateInputType
  }

  export type GetProductLineAggregateType<T extends ProductLineAggregateArgs> = {
        [P in keyof T & keyof AggregateProductLine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductLine[P]>
      : GetScalarType<T[P], AggregateProductLine[P]>
  }




  export type ProductLineGroupByArgs = {
    where?: ProductLineWhereInput
    orderBy?: Enumerable<ProductLineOrderByWithAggregationInput>
    by: ProductLineScalarFieldEnum[]
    having?: ProductLineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductLineCountAggregateInputType | true
    _avg?: ProductLineAvgAggregateInputType
    _sum?: ProductLineSumAggregateInputType
    _min?: ProductLineMinAggregateInputType
    _max?: ProductLineMaxAggregateInputType
  }


  export type ProductLineGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    isDeleted: boolean
    name: string
    description: string
    _count: ProductLineCountAggregateOutputType | null
    _avg: ProductLineAvgAggregateOutputType | null
    _sum: ProductLineSumAggregateOutputType | null
    _min: ProductLineMinAggregateOutputType | null
    _max: ProductLineMaxAggregateOutputType | null
  }

  type GetProductLineGroupByPayload<T extends ProductLineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ProductLineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductLineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductLineGroupByOutputType[P]>
            : GetScalarType<T[P], ProductLineGroupByOutputType[P]>
        }
      >
    >


  export type ProductLineSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    name?: boolean
    description?: boolean
    equipment?: boolean | ProductLine$equipmentArgs
    _count?: boolean | ProductLineCountOutputTypeArgs
  }


  export type ProductLineInclude = {
    equipment?: boolean | ProductLine$equipmentArgs
    _count?: boolean | ProductLineCountOutputTypeArgs
  }

  export type ProductLineGetPayload<S extends boolean | null | undefined | ProductLineArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ProductLine :
    S extends undefined ? never :
    S extends { include: any } & (ProductLineArgs | ProductLineFindManyArgs)
    ? ProductLine  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'equipment' ? Array < EquipmentGetPayload<S['include'][P]>>  :
        P extends '_count' ? ProductLineCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ProductLineArgs | ProductLineFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'equipment' ? Array < EquipmentGetPayload<S['select'][P]>>  :
        P extends '_count' ? ProductLineCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof ProductLine ? ProductLine[P] : never
  } 
      : ProductLine


  type ProductLineCountArgs = 
    Omit<ProductLineFindManyArgs, 'select' | 'include'> & {
      select?: ProductLineCountAggregateInputType | true
    }

  export interface ProductLineDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one ProductLine that matches the filter.
     * @param {ProductLineFindUniqueArgs} args - Arguments to find a ProductLine
     * @example
     * // Get one ProductLine
     * const productLine = await prisma.productLine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductLineFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProductLineFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ProductLine'> extends True ? Prisma__ProductLineClient<ProductLineGetPayload<T>> : Prisma__ProductLineClient<ProductLineGetPayload<T> | null, null>

    /**
     * Find one ProductLine that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProductLineFindUniqueOrThrowArgs} args - Arguments to find a ProductLine
     * @example
     * // Get one ProductLine
     * const productLine = await prisma.productLine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProductLineFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ProductLineFindUniqueOrThrowArgs>
    ): Prisma__ProductLineClient<ProductLineGetPayload<T>>

    /**
     * Find the first ProductLine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductLineFindFirstArgs} args - Arguments to find a ProductLine
     * @example
     * // Get one ProductLine
     * const productLine = await prisma.productLine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductLineFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProductLineFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ProductLine'> extends True ? Prisma__ProductLineClient<ProductLineGetPayload<T>> : Prisma__ProductLineClient<ProductLineGetPayload<T> | null, null>

    /**
     * Find the first ProductLine that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductLineFindFirstOrThrowArgs} args - Arguments to find a ProductLine
     * @example
     * // Get one ProductLine
     * const productLine = await prisma.productLine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProductLineFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ProductLineFindFirstOrThrowArgs>
    ): Prisma__ProductLineClient<ProductLineGetPayload<T>>

    /**
     * Find zero or more ProductLines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductLineFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductLines
     * const productLines = await prisma.productLine.findMany()
     * 
     * // Get first 10 ProductLines
     * const productLines = await prisma.productLine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productLineWithIdOnly = await prisma.productLine.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductLineFindManyArgs>(
      args?: SelectSubset<T, ProductLineFindManyArgs>
    ): Prisma.PrismaPromise<Array<ProductLineGetPayload<T>>>

    /**
     * Create a ProductLine.
     * @param {ProductLineCreateArgs} args - Arguments to create a ProductLine.
     * @example
     * // Create one ProductLine
     * const ProductLine = await prisma.productLine.create({
     *   data: {
     *     // ... data to create a ProductLine
     *   }
     * })
     * 
    **/
    create<T extends ProductLineCreateArgs>(
      args: SelectSubset<T, ProductLineCreateArgs>
    ): Prisma__ProductLineClient<ProductLineGetPayload<T>>

    /**
     * Create many ProductLines.
     *     @param {ProductLineCreateManyArgs} args - Arguments to create many ProductLines.
     *     @example
     *     // Create many ProductLines
     *     const productLine = await prisma.productLine.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductLineCreateManyArgs>(
      args?: SelectSubset<T, ProductLineCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProductLine.
     * @param {ProductLineDeleteArgs} args - Arguments to delete one ProductLine.
     * @example
     * // Delete one ProductLine
     * const ProductLine = await prisma.productLine.delete({
     *   where: {
     *     // ... filter to delete one ProductLine
     *   }
     * })
     * 
    **/
    delete<T extends ProductLineDeleteArgs>(
      args: SelectSubset<T, ProductLineDeleteArgs>
    ): Prisma__ProductLineClient<ProductLineGetPayload<T>>

    /**
     * Update one ProductLine.
     * @param {ProductLineUpdateArgs} args - Arguments to update one ProductLine.
     * @example
     * // Update one ProductLine
     * const productLine = await prisma.productLine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductLineUpdateArgs>(
      args: SelectSubset<T, ProductLineUpdateArgs>
    ): Prisma__ProductLineClient<ProductLineGetPayload<T>>

    /**
     * Delete zero or more ProductLines.
     * @param {ProductLineDeleteManyArgs} args - Arguments to filter ProductLines to delete.
     * @example
     * // Delete a few ProductLines
     * const { count } = await prisma.productLine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductLineDeleteManyArgs>(
      args?: SelectSubset<T, ProductLineDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductLineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductLines
     * const productLine = await prisma.productLine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductLineUpdateManyArgs>(
      args: SelectSubset<T, ProductLineUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductLine.
     * @param {ProductLineUpsertArgs} args - Arguments to update or create a ProductLine.
     * @example
     * // Update or create a ProductLine
     * const productLine = await prisma.productLine.upsert({
     *   create: {
     *     // ... data to create a ProductLine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductLine we want to update
     *   }
     * })
    **/
    upsert<T extends ProductLineUpsertArgs>(
      args: SelectSubset<T, ProductLineUpsertArgs>
    ): Prisma__ProductLineClient<ProductLineGetPayload<T>>

    /**
     * Count the number of ProductLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductLineCountArgs} args - Arguments to filter ProductLines to count.
     * @example
     * // Count the number of ProductLines
     * const count = await prisma.productLine.count({
     *   where: {
     *     // ... the filter for the ProductLines we want to count
     *   }
     * })
    **/
    count<T extends ProductLineCountArgs>(
      args?: Subset<T, ProductLineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductLineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductLineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductLineAggregateArgs>(args: Subset<T, ProductLineAggregateArgs>): Prisma.PrismaPromise<GetProductLineAggregateType<T>>

    /**
     * Group by ProductLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductLineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductLineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductLineGroupByArgs['orderBy'] }
        : { orderBy?: ProductLineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductLineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductLineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductLine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProductLineClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    equipment<T extends ProductLine$equipmentArgs= {}>(args?: Subset<T, ProductLine$equipmentArgs>): Prisma.PrismaPromise<Array<EquipmentGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ProductLine base type for findUnique actions
   */
  export type ProductLineFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ProductLine
     */
    select?: ProductLineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductLineInclude | null
    /**
     * Filter, which ProductLine to fetch.
     */
    where: ProductLineWhereUniqueInput
  }

  /**
   * ProductLine findUnique
   */
  export interface ProductLineFindUniqueArgs extends ProductLineFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ProductLine findUniqueOrThrow
   */
  export type ProductLineFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ProductLine
     */
    select?: ProductLineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductLineInclude | null
    /**
     * Filter, which ProductLine to fetch.
     */
    where: ProductLineWhereUniqueInput
  }


  /**
   * ProductLine base type for findFirst actions
   */
  export type ProductLineFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ProductLine
     */
    select?: ProductLineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductLineInclude | null
    /**
     * Filter, which ProductLine to fetch.
     */
    where?: ProductLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductLines to fetch.
     */
    orderBy?: Enumerable<ProductLineOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductLines.
     */
    cursor?: ProductLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductLines.
     */
    distinct?: Enumerable<ProductLineScalarFieldEnum>
  }

  /**
   * ProductLine findFirst
   */
  export interface ProductLineFindFirstArgs extends ProductLineFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ProductLine findFirstOrThrow
   */
  export type ProductLineFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ProductLine
     */
    select?: ProductLineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductLineInclude | null
    /**
     * Filter, which ProductLine to fetch.
     */
    where?: ProductLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductLines to fetch.
     */
    orderBy?: Enumerable<ProductLineOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductLines.
     */
    cursor?: ProductLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductLines.
     */
    distinct?: Enumerable<ProductLineScalarFieldEnum>
  }


  /**
   * ProductLine findMany
   */
  export type ProductLineFindManyArgs = {
    /**
     * Select specific fields to fetch from the ProductLine
     */
    select?: ProductLineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductLineInclude | null
    /**
     * Filter, which ProductLines to fetch.
     */
    where?: ProductLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductLines to fetch.
     */
    orderBy?: Enumerable<ProductLineOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductLines.
     */
    cursor?: ProductLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductLines.
     */
    skip?: number
    distinct?: Enumerable<ProductLineScalarFieldEnum>
  }


  /**
   * ProductLine create
   */
  export type ProductLineCreateArgs = {
    /**
     * Select specific fields to fetch from the ProductLine
     */
    select?: ProductLineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductLineInclude | null
    /**
     * The data needed to create a ProductLine.
     */
    data: XOR<ProductLineCreateInput, ProductLineUncheckedCreateInput>
  }


  /**
   * ProductLine createMany
   */
  export type ProductLineCreateManyArgs = {
    /**
     * The data used to create many ProductLines.
     */
    data: Enumerable<ProductLineCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ProductLine update
   */
  export type ProductLineUpdateArgs = {
    /**
     * Select specific fields to fetch from the ProductLine
     */
    select?: ProductLineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductLineInclude | null
    /**
     * The data needed to update a ProductLine.
     */
    data: XOR<ProductLineUpdateInput, ProductLineUncheckedUpdateInput>
    /**
     * Choose, which ProductLine to update.
     */
    where: ProductLineWhereUniqueInput
  }


  /**
   * ProductLine updateMany
   */
  export type ProductLineUpdateManyArgs = {
    /**
     * The data used to update ProductLines.
     */
    data: XOR<ProductLineUpdateManyMutationInput, ProductLineUncheckedUpdateManyInput>
    /**
     * Filter which ProductLines to update
     */
    where?: ProductLineWhereInput
  }


  /**
   * ProductLine upsert
   */
  export type ProductLineUpsertArgs = {
    /**
     * Select specific fields to fetch from the ProductLine
     */
    select?: ProductLineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductLineInclude | null
    /**
     * The filter to search for the ProductLine to update in case it exists.
     */
    where: ProductLineWhereUniqueInput
    /**
     * In case the ProductLine found by the `where` argument doesn't exist, create a new ProductLine with this data.
     */
    create: XOR<ProductLineCreateInput, ProductLineUncheckedCreateInput>
    /**
     * In case the ProductLine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductLineUpdateInput, ProductLineUncheckedUpdateInput>
  }


  /**
   * ProductLine delete
   */
  export type ProductLineDeleteArgs = {
    /**
     * Select specific fields to fetch from the ProductLine
     */
    select?: ProductLineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductLineInclude | null
    /**
     * Filter which ProductLine to delete.
     */
    where: ProductLineWhereUniqueInput
  }


  /**
   * ProductLine deleteMany
   */
  export type ProductLineDeleteManyArgs = {
    /**
     * Filter which ProductLines to delete
     */
    where?: ProductLineWhereInput
  }


  /**
   * ProductLine.equipment
   */
  export type ProductLine$equipmentArgs = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EquipmentInclude | null
    where?: EquipmentWhereInput
    orderBy?: Enumerable<EquipmentOrderByWithRelationInput>
    cursor?: EquipmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<EquipmentScalarFieldEnum>
  }


  /**
   * ProductLine without action
   */
  export type ProductLineArgs = {
    /**
     * Select specific fields to fetch from the ProductLine
     */
    select?: ProductLineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductLineInclude | null
  }



  /**
   * Model Equipment
   */


  export type AggregateEquipment = {
    _count: EquipmentCountAggregateOutputType | null
    _avg: EquipmentAvgAggregateOutputType | null
    _sum: EquipmentSumAggregateOutputType | null
    _min: EquipmentMinAggregateOutputType | null
    _max: EquipmentMaxAggregateOutputType | null
  }

  export type EquipmentAvgAggregateOutputType = {
    id: number | null
    productLineId: number | null
  }

  export type EquipmentSumAggregateOutputType = {
    id: number | null
    productLineId: number | null
  }

  export type EquipmentMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    name: string | null
    description: string | null
    repairPlan: string | null
    workStation: string | null
    productLineId: number | null
  }

  export type EquipmentMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    name: string | null
    description: string | null
    repairPlan: string | null
    workStation: string | null
    productLineId: number | null
  }

  export type EquipmentCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    isDeleted: number
    name: number
    description: number
    repairPlan: number
    workStation: number
    productLineId: number
    _all: number
  }


  export type EquipmentAvgAggregateInputType = {
    id?: true
    productLineId?: true
  }

  export type EquipmentSumAggregateInputType = {
    id?: true
    productLineId?: true
  }

  export type EquipmentMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    name?: true
    description?: true
    repairPlan?: true
    workStation?: true
    productLineId?: true
  }

  export type EquipmentMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    name?: true
    description?: true
    repairPlan?: true
    workStation?: true
    productLineId?: true
  }

  export type EquipmentCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    name?: true
    description?: true
    repairPlan?: true
    workStation?: true
    productLineId?: true
    _all?: true
  }

  export type EquipmentAggregateArgs = {
    /**
     * Filter which Equipment to aggregate.
     */
    where?: EquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equipment to fetch.
     */
    orderBy?: Enumerable<EquipmentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equipment from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equipment.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Equipment
    **/
    _count?: true | EquipmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EquipmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EquipmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EquipmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EquipmentMaxAggregateInputType
  }

  export type GetEquipmentAggregateType<T extends EquipmentAggregateArgs> = {
        [P in keyof T & keyof AggregateEquipment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEquipment[P]>
      : GetScalarType<T[P], AggregateEquipment[P]>
  }




  export type EquipmentGroupByArgs = {
    where?: EquipmentWhereInput
    orderBy?: Enumerable<EquipmentOrderByWithAggregationInput>
    by: EquipmentScalarFieldEnum[]
    having?: EquipmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EquipmentCountAggregateInputType | true
    _avg?: EquipmentAvgAggregateInputType
    _sum?: EquipmentSumAggregateInputType
    _min?: EquipmentMinAggregateInputType
    _max?: EquipmentMaxAggregateInputType
  }


  export type EquipmentGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    isDeleted: boolean
    name: string
    description: string
    repairPlan: string
    workStation: string
    productLineId: number
    _count: EquipmentCountAggregateOutputType | null
    _avg: EquipmentAvgAggregateOutputType | null
    _sum: EquipmentSumAggregateOutputType | null
    _min: EquipmentMinAggregateOutputType | null
    _max: EquipmentMaxAggregateOutputType | null
  }

  type GetEquipmentGroupByPayload<T extends EquipmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<EquipmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EquipmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EquipmentGroupByOutputType[P]>
            : GetScalarType<T[P], EquipmentGroupByOutputType[P]>
        }
      >
    >


  export type EquipmentSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    name?: boolean
    description?: boolean
    repairPlan?: boolean
    workStation?: boolean
    productLineId?: boolean
    productLine?: boolean | ProductLineArgs
    repairMaterialInventories?: boolean | Equipment$repairMaterialInventoriesArgs
    repairRecords?: boolean | Equipment$repairRecordsArgs
    _count?: boolean | EquipmentCountOutputTypeArgs
  }


  export type EquipmentInclude = {
    productLine?: boolean | ProductLineArgs
    repairMaterialInventories?: boolean | Equipment$repairMaterialInventoriesArgs
    repairRecords?: boolean | Equipment$repairRecordsArgs
    _count?: boolean | EquipmentCountOutputTypeArgs
  }

  export type EquipmentGetPayload<S extends boolean | null | undefined | EquipmentArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Equipment :
    S extends undefined ? never :
    S extends { include: any } & (EquipmentArgs | EquipmentFindManyArgs)
    ? Equipment  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'productLine' ? ProductLineGetPayload<S['include'][P]> :
        P extends 'repairMaterialInventories' ? Array < RepairMaterialInventoryGetPayload<S['include'][P]>>  :
        P extends 'repairRecords' ? Array < RepairRecordGetPayload<S['include'][P]>>  :
        P extends '_count' ? EquipmentCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (EquipmentArgs | EquipmentFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'productLine' ? ProductLineGetPayload<S['select'][P]> :
        P extends 'repairMaterialInventories' ? Array < RepairMaterialInventoryGetPayload<S['select'][P]>>  :
        P extends 'repairRecords' ? Array < RepairRecordGetPayload<S['select'][P]>>  :
        P extends '_count' ? EquipmentCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Equipment ? Equipment[P] : never
  } 
      : Equipment


  type EquipmentCountArgs = 
    Omit<EquipmentFindManyArgs, 'select' | 'include'> & {
      select?: EquipmentCountAggregateInputType | true
    }

  export interface EquipmentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Equipment that matches the filter.
     * @param {EquipmentFindUniqueArgs} args - Arguments to find a Equipment
     * @example
     * // Get one Equipment
     * const equipment = await prisma.equipment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EquipmentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, EquipmentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Equipment'> extends True ? Prisma__EquipmentClient<EquipmentGetPayload<T>> : Prisma__EquipmentClient<EquipmentGetPayload<T> | null, null>

    /**
     * Find one Equipment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EquipmentFindUniqueOrThrowArgs} args - Arguments to find a Equipment
     * @example
     * // Get one Equipment
     * const equipment = await prisma.equipment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EquipmentFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, EquipmentFindUniqueOrThrowArgs>
    ): Prisma__EquipmentClient<EquipmentGetPayload<T>>

    /**
     * Find the first Equipment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentFindFirstArgs} args - Arguments to find a Equipment
     * @example
     * // Get one Equipment
     * const equipment = await prisma.equipment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EquipmentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, EquipmentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Equipment'> extends True ? Prisma__EquipmentClient<EquipmentGetPayload<T>> : Prisma__EquipmentClient<EquipmentGetPayload<T> | null, null>

    /**
     * Find the first Equipment that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentFindFirstOrThrowArgs} args - Arguments to find a Equipment
     * @example
     * // Get one Equipment
     * const equipment = await prisma.equipment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EquipmentFindFirstOrThrowArgs>(
      args?: SelectSubset<T, EquipmentFindFirstOrThrowArgs>
    ): Prisma__EquipmentClient<EquipmentGetPayload<T>>

    /**
     * Find zero or more Equipment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Equipment
     * const equipment = await prisma.equipment.findMany()
     * 
     * // Get first 10 Equipment
     * const equipment = await prisma.equipment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const equipmentWithIdOnly = await prisma.equipment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EquipmentFindManyArgs>(
      args?: SelectSubset<T, EquipmentFindManyArgs>
    ): Prisma.PrismaPromise<Array<EquipmentGetPayload<T>>>

    /**
     * Create a Equipment.
     * @param {EquipmentCreateArgs} args - Arguments to create a Equipment.
     * @example
     * // Create one Equipment
     * const Equipment = await prisma.equipment.create({
     *   data: {
     *     // ... data to create a Equipment
     *   }
     * })
     * 
    **/
    create<T extends EquipmentCreateArgs>(
      args: SelectSubset<T, EquipmentCreateArgs>
    ): Prisma__EquipmentClient<EquipmentGetPayload<T>>

    /**
     * Create many Equipment.
     *     @param {EquipmentCreateManyArgs} args - Arguments to create many Equipment.
     *     @example
     *     // Create many Equipment
     *     const equipment = await prisma.equipment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EquipmentCreateManyArgs>(
      args?: SelectSubset<T, EquipmentCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Equipment.
     * @param {EquipmentDeleteArgs} args - Arguments to delete one Equipment.
     * @example
     * // Delete one Equipment
     * const Equipment = await prisma.equipment.delete({
     *   where: {
     *     // ... filter to delete one Equipment
     *   }
     * })
     * 
    **/
    delete<T extends EquipmentDeleteArgs>(
      args: SelectSubset<T, EquipmentDeleteArgs>
    ): Prisma__EquipmentClient<EquipmentGetPayload<T>>

    /**
     * Update one Equipment.
     * @param {EquipmentUpdateArgs} args - Arguments to update one Equipment.
     * @example
     * // Update one Equipment
     * const equipment = await prisma.equipment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EquipmentUpdateArgs>(
      args: SelectSubset<T, EquipmentUpdateArgs>
    ): Prisma__EquipmentClient<EquipmentGetPayload<T>>

    /**
     * Delete zero or more Equipment.
     * @param {EquipmentDeleteManyArgs} args - Arguments to filter Equipment to delete.
     * @example
     * // Delete a few Equipment
     * const { count } = await prisma.equipment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EquipmentDeleteManyArgs>(
      args?: SelectSubset<T, EquipmentDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Equipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Equipment
     * const equipment = await prisma.equipment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EquipmentUpdateManyArgs>(
      args: SelectSubset<T, EquipmentUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Equipment.
     * @param {EquipmentUpsertArgs} args - Arguments to update or create a Equipment.
     * @example
     * // Update or create a Equipment
     * const equipment = await prisma.equipment.upsert({
     *   create: {
     *     // ... data to create a Equipment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Equipment we want to update
     *   }
     * })
    **/
    upsert<T extends EquipmentUpsertArgs>(
      args: SelectSubset<T, EquipmentUpsertArgs>
    ): Prisma__EquipmentClient<EquipmentGetPayload<T>>

    /**
     * Count the number of Equipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentCountArgs} args - Arguments to filter Equipment to count.
     * @example
     * // Count the number of Equipment
     * const count = await prisma.equipment.count({
     *   where: {
     *     // ... the filter for the Equipment we want to count
     *   }
     * })
    **/
    count<T extends EquipmentCountArgs>(
      args?: Subset<T, EquipmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EquipmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Equipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EquipmentAggregateArgs>(args: Subset<T, EquipmentAggregateArgs>): Prisma.PrismaPromise<GetEquipmentAggregateType<T>>

    /**
     * Group by Equipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EquipmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EquipmentGroupByArgs['orderBy'] }
        : { orderBy?: EquipmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EquipmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEquipmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Equipment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__EquipmentClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    productLine<T extends ProductLineArgs= {}>(args?: Subset<T, ProductLineArgs>): Prisma__ProductLineClient<ProductLineGetPayload<T> | Null>;

    repairMaterialInventories<T extends Equipment$repairMaterialInventoriesArgs= {}>(args?: Subset<T, Equipment$repairMaterialInventoriesArgs>): Prisma.PrismaPromise<Array<RepairMaterialInventoryGetPayload<T>>| Null>;

    repairRecords<T extends Equipment$repairRecordsArgs= {}>(args?: Subset<T, Equipment$repairRecordsArgs>): Prisma.PrismaPromise<Array<RepairRecordGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Equipment base type for findUnique actions
   */
  export type EquipmentFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EquipmentInclude | null
    /**
     * Filter, which Equipment to fetch.
     */
    where: EquipmentWhereUniqueInput
  }

  /**
   * Equipment findUnique
   */
  export interface EquipmentFindUniqueArgs extends EquipmentFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Equipment findUniqueOrThrow
   */
  export type EquipmentFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EquipmentInclude | null
    /**
     * Filter, which Equipment to fetch.
     */
    where: EquipmentWhereUniqueInput
  }


  /**
   * Equipment base type for findFirst actions
   */
  export type EquipmentFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EquipmentInclude | null
    /**
     * Filter, which Equipment to fetch.
     */
    where?: EquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equipment to fetch.
     */
    orderBy?: Enumerable<EquipmentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Equipment.
     */
    cursor?: EquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equipment from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equipment.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Equipment.
     */
    distinct?: Enumerable<EquipmentScalarFieldEnum>
  }

  /**
   * Equipment findFirst
   */
  export interface EquipmentFindFirstArgs extends EquipmentFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Equipment findFirstOrThrow
   */
  export type EquipmentFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EquipmentInclude | null
    /**
     * Filter, which Equipment to fetch.
     */
    where?: EquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equipment to fetch.
     */
    orderBy?: Enumerable<EquipmentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Equipment.
     */
    cursor?: EquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equipment from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equipment.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Equipment.
     */
    distinct?: Enumerable<EquipmentScalarFieldEnum>
  }


  /**
   * Equipment findMany
   */
  export type EquipmentFindManyArgs = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EquipmentInclude | null
    /**
     * Filter, which Equipment to fetch.
     */
    where?: EquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equipment to fetch.
     */
    orderBy?: Enumerable<EquipmentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Equipment.
     */
    cursor?: EquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equipment from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equipment.
     */
    skip?: number
    distinct?: Enumerable<EquipmentScalarFieldEnum>
  }


  /**
   * Equipment create
   */
  export type EquipmentCreateArgs = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EquipmentInclude | null
    /**
     * The data needed to create a Equipment.
     */
    data: XOR<EquipmentCreateInput, EquipmentUncheckedCreateInput>
  }


  /**
   * Equipment createMany
   */
  export type EquipmentCreateManyArgs = {
    /**
     * The data used to create many Equipment.
     */
    data: Enumerable<EquipmentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Equipment update
   */
  export type EquipmentUpdateArgs = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EquipmentInclude | null
    /**
     * The data needed to update a Equipment.
     */
    data: XOR<EquipmentUpdateInput, EquipmentUncheckedUpdateInput>
    /**
     * Choose, which Equipment to update.
     */
    where: EquipmentWhereUniqueInput
  }


  /**
   * Equipment updateMany
   */
  export type EquipmentUpdateManyArgs = {
    /**
     * The data used to update Equipment.
     */
    data: XOR<EquipmentUpdateManyMutationInput, EquipmentUncheckedUpdateManyInput>
    /**
     * Filter which Equipment to update
     */
    where?: EquipmentWhereInput
  }


  /**
   * Equipment upsert
   */
  export type EquipmentUpsertArgs = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EquipmentInclude | null
    /**
     * The filter to search for the Equipment to update in case it exists.
     */
    where: EquipmentWhereUniqueInput
    /**
     * In case the Equipment found by the `where` argument doesn't exist, create a new Equipment with this data.
     */
    create: XOR<EquipmentCreateInput, EquipmentUncheckedCreateInput>
    /**
     * In case the Equipment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EquipmentUpdateInput, EquipmentUncheckedUpdateInput>
  }


  /**
   * Equipment delete
   */
  export type EquipmentDeleteArgs = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EquipmentInclude | null
    /**
     * Filter which Equipment to delete.
     */
    where: EquipmentWhereUniqueInput
  }


  /**
   * Equipment deleteMany
   */
  export type EquipmentDeleteManyArgs = {
    /**
     * Filter which Equipment to delete
     */
    where?: EquipmentWhereInput
  }


  /**
   * Equipment.repairMaterialInventories
   */
  export type Equipment$repairMaterialInventoriesArgs = {
    /**
     * Select specific fields to fetch from the RepairMaterialInventory
     */
    select?: RepairMaterialInventorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairMaterialInventoryInclude | null
    where?: RepairMaterialInventoryWhereInput
    orderBy?: Enumerable<RepairMaterialInventoryOrderByWithRelationInput>
    cursor?: RepairMaterialInventoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<RepairMaterialInventoryScalarFieldEnum>
  }


  /**
   * Equipment.repairRecords
   */
  export type Equipment$repairRecordsArgs = {
    /**
     * Select specific fields to fetch from the RepairRecord
     */
    select?: RepairRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairRecordInclude | null
    where?: RepairRecordWhereInput
    orderBy?: Enumerable<RepairRecordOrderByWithRelationInput>
    cursor?: RepairRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<RepairRecordScalarFieldEnum>
  }


  /**
   * Equipment without action
   */
  export type EquipmentArgs = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EquipmentInclude | null
  }



  /**
   * Model RepairMaterialInventory
   */


  export type AggregateRepairMaterialInventory = {
    _count: RepairMaterialInventoryCountAggregateOutputType | null
    _avg: RepairMaterialInventoryAvgAggregateOutputType | null
    _sum: RepairMaterialInventorySumAggregateOutputType | null
    _min: RepairMaterialInventoryMinAggregateOutputType | null
    _max: RepairMaterialInventoryMaxAggregateOutputType | null
  }

  export type RepairMaterialInventoryAvgAggregateOutputType = {
    id: number | null
    quantity: number | null
    minimumQuantity: number | null
    equipmentId: number | null
  }

  export type RepairMaterialInventorySumAggregateOutputType = {
    id: number | null
    quantity: number | null
    minimumQuantity: number | null
    equipmentId: number | null
  }

  export type RepairMaterialInventoryMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    name: string | null
    description: string | null
    quantity: number | null
    minimumQuantity: number | null
    equipmentId: number | null
  }

  export type RepairMaterialInventoryMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    name: string | null
    description: string | null
    quantity: number | null
    minimumQuantity: number | null
    equipmentId: number | null
  }

  export type RepairMaterialInventoryCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    isDeleted: number
    name: number
    description: number
    quantity: number
    minimumQuantity: number
    equipmentId: number
    _all: number
  }


  export type RepairMaterialInventoryAvgAggregateInputType = {
    id?: true
    quantity?: true
    minimumQuantity?: true
    equipmentId?: true
  }

  export type RepairMaterialInventorySumAggregateInputType = {
    id?: true
    quantity?: true
    minimumQuantity?: true
    equipmentId?: true
  }

  export type RepairMaterialInventoryMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    name?: true
    description?: true
    quantity?: true
    minimumQuantity?: true
    equipmentId?: true
  }

  export type RepairMaterialInventoryMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    name?: true
    description?: true
    quantity?: true
    minimumQuantity?: true
    equipmentId?: true
  }

  export type RepairMaterialInventoryCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    name?: true
    description?: true
    quantity?: true
    minimumQuantity?: true
    equipmentId?: true
    _all?: true
  }

  export type RepairMaterialInventoryAggregateArgs = {
    /**
     * Filter which RepairMaterialInventory to aggregate.
     */
    where?: RepairMaterialInventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RepairMaterialInventories to fetch.
     */
    orderBy?: Enumerable<RepairMaterialInventoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RepairMaterialInventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RepairMaterialInventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RepairMaterialInventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RepairMaterialInventories
    **/
    _count?: true | RepairMaterialInventoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RepairMaterialInventoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RepairMaterialInventorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RepairMaterialInventoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RepairMaterialInventoryMaxAggregateInputType
  }

  export type GetRepairMaterialInventoryAggregateType<T extends RepairMaterialInventoryAggregateArgs> = {
        [P in keyof T & keyof AggregateRepairMaterialInventory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRepairMaterialInventory[P]>
      : GetScalarType<T[P], AggregateRepairMaterialInventory[P]>
  }




  export type RepairMaterialInventoryGroupByArgs = {
    where?: RepairMaterialInventoryWhereInput
    orderBy?: Enumerable<RepairMaterialInventoryOrderByWithAggregationInput>
    by: RepairMaterialInventoryScalarFieldEnum[]
    having?: RepairMaterialInventoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RepairMaterialInventoryCountAggregateInputType | true
    _avg?: RepairMaterialInventoryAvgAggregateInputType
    _sum?: RepairMaterialInventorySumAggregateInputType
    _min?: RepairMaterialInventoryMinAggregateInputType
    _max?: RepairMaterialInventoryMaxAggregateInputType
  }


  export type RepairMaterialInventoryGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    isDeleted: boolean
    name: string
    description: string
    quantity: number
    minimumQuantity: number
    equipmentId: number
    _count: RepairMaterialInventoryCountAggregateOutputType | null
    _avg: RepairMaterialInventoryAvgAggregateOutputType | null
    _sum: RepairMaterialInventorySumAggregateOutputType | null
    _min: RepairMaterialInventoryMinAggregateOutputType | null
    _max: RepairMaterialInventoryMaxAggregateOutputType | null
  }

  type GetRepairMaterialInventoryGroupByPayload<T extends RepairMaterialInventoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<RepairMaterialInventoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RepairMaterialInventoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RepairMaterialInventoryGroupByOutputType[P]>
            : GetScalarType<T[P], RepairMaterialInventoryGroupByOutputType[P]>
        }
      >
    >


  export type RepairMaterialInventorySelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    name?: boolean
    description?: boolean
    quantity?: boolean
    minimumQuantity?: boolean
    equipmentId?: boolean
    equipment?: boolean | EquipmentArgs
  }


  export type RepairMaterialInventoryInclude = {
    equipment?: boolean | EquipmentArgs
  }

  export type RepairMaterialInventoryGetPayload<S extends boolean | null | undefined | RepairMaterialInventoryArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? RepairMaterialInventory :
    S extends undefined ? never :
    S extends { include: any } & (RepairMaterialInventoryArgs | RepairMaterialInventoryFindManyArgs)
    ? RepairMaterialInventory  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'equipment' ? EquipmentGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (RepairMaterialInventoryArgs | RepairMaterialInventoryFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'equipment' ? EquipmentGetPayload<S['select'][P]> :  P extends keyof RepairMaterialInventory ? RepairMaterialInventory[P] : never
  } 
      : RepairMaterialInventory


  type RepairMaterialInventoryCountArgs = 
    Omit<RepairMaterialInventoryFindManyArgs, 'select' | 'include'> & {
      select?: RepairMaterialInventoryCountAggregateInputType | true
    }

  export interface RepairMaterialInventoryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one RepairMaterialInventory that matches the filter.
     * @param {RepairMaterialInventoryFindUniqueArgs} args - Arguments to find a RepairMaterialInventory
     * @example
     * // Get one RepairMaterialInventory
     * const repairMaterialInventory = await prisma.repairMaterialInventory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RepairMaterialInventoryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RepairMaterialInventoryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'RepairMaterialInventory'> extends True ? Prisma__RepairMaterialInventoryClient<RepairMaterialInventoryGetPayload<T>> : Prisma__RepairMaterialInventoryClient<RepairMaterialInventoryGetPayload<T> | null, null>

    /**
     * Find one RepairMaterialInventory that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RepairMaterialInventoryFindUniqueOrThrowArgs} args - Arguments to find a RepairMaterialInventory
     * @example
     * // Get one RepairMaterialInventory
     * const repairMaterialInventory = await prisma.repairMaterialInventory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RepairMaterialInventoryFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, RepairMaterialInventoryFindUniqueOrThrowArgs>
    ): Prisma__RepairMaterialInventoryClient<RepairMaterialInventoryGetPayload<T>>

    /**
     * Find the first RepairMaterialInventory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairMaterialInventoryFindFirstArgs} args - Arguments to find a RepairMaterialInventory
     * @example
     * // Get one RepairMaterialInventory
     * const repairMaterialInventory = await prisma.repairMaterialInventory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RepairMaterialInventoryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RepairMaterialInventoryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'RepairMaterialInventory'> extends True ? Prisma__RepairMaterialInventoryClient<RepairMaterialInventoryGetPayload<T>> : Prisma__RepairMaterialInventoryClient<RepairMaterialInventoryGetPayload<T> | null, null>

    /**
     * Find the first RepairMaterialInventory that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairMaterialInventoryFindFirstOrThrowArgs} args - Arguments to find a RepairMaterialInventory
     * @example
     * // Get one RepairMaterialInventory
     * const repairMaterialInventory = await prisma.repairMaterialInventory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RepairMaterialInventoryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RepairMaterialInventoryFindFirstOrThrowArgs>
    ): Prisma__RepairMaterialInventoryClient<RepairMaterialInventoryGetPayload<T>>

    /**
     * Find zero or more RepairMaterialInventories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairMaterialInventoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RepairMaterialInventories
     * const repairMaterialInventories = await prisma.repairMaterialInventory.findMany()
     * 
     * // Get first 10 RepairMaterialInventories
     * const repairMaterialInventories = await prisma.repairMaterialInventory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const repairMaterialInventoryWithIdOnly = await prisma.repairMaterialInventory.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RepairMaterialInventoryFindManyArgs>(
      args?: SelectSubset<T, RepairMaterialInventoryFindManyArgs>
    ): Prisma.PrismaPromise<Array<RepairMaterialInventoryGetPayload<T>>>

    /**
     * Create a RepairMaterialInventory.
     * @param {RepairMaterialInventoryCreateArgs} args - Arguments to create a RepairMaterialInventory.
     * @example
     * // Create one RepairMaterialInventory
     * const RepairMaterialInventory = await prisma.repairMaterialInventory.create({
     *   data: {
     *     // ... data to create a RepairMaterialInventory
     *   }
     * })
     * 
    **/
    create<T extends RepairMaterialInventoryCreateArgs>(
      args: SelectSubset<T, RepairMaterialInventoryCreateArgs>
    ): Prisma__RepairMaterialInventoryClient<RepairMaterialInventoryGetPayload<T>>

    /**
     * Create many RepairMaterialInventories.
     *     @param {RepairMaterialInventoryCreateManyArgs} args - Arguments to create many RepairMaterialInventories.
     *     @example
     *     // Create many RepairMaterialInventories
     *     const repairMaterialInventory = await prisma.repairMaterialInventory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RepairMaterialInventoryCreateManyArgs>(
      args?: SelectSubset<T, RepairMaterialInventoryCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RepairMaterialInventory.
     * @param {RepairMaterialInventoryDeleteArgs} args - Arguments to delete one RepairMaterialInventory.
     * @example
     * // Delete one RepairMaterialInventory
     * const RepairMaterialInventory = await prisma.repairMaterialInventory.delete({
     *   where: {
     *     // ... filter to delete one RepairMaterialInventory
     *   }
     * })
     * 
    **/
    delete<T extends RepairMaterialInventoryDeleteArgs>(
      args: SelectSubset<T, RepairMaterialInventoryDeleteArgs>
    ): Prisma__RepairMaterialInventoryClient<RepairMaterialInventoryGetPayload<T>>

    /**
     * Update one RepairMaterialInventory.
     * @param {RepairMaterialInventoryUpdateArgs} args - Arguments to update one RepairMaterialInventory.
     * @example
     * // Update one RepairMaterialInventory
     * const repairMaterialInventory = await prisma.repairMaterialInventory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RepairMaterialInventoryUpdateArgs>(
      args: SelectSubset<T, RepairMaterialInventoryUpdateArgs>
    ): Prisma__RepairMaterialInventoryClient<RepairMaterialInventoryGetPayload<T>>

    /**
     * Delete zero or more RepairMaterialInventories.
     * @param {RepairMaterialInventoryDeleteManyArgs} args - Arguments to filter RepairMaterialInventories to delete.
     * @example
     * // Delete a few RepairMaterialInventories
     * const { count } = await prisma.repairMaterialInventory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RepairMaterialInventoryDeleteManyArgs>(
      args?: SelectSubset<T, RepairMaterialInventoryDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RepairMaterialInventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairMaterialInventoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RepairMaterialInventories
     * const repairMaterialInventory = await prisma.repairMaterialInventory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RepairMaterialInventoryUpdateManyArgs>(
      args: SelectSubset<T, RepairMaterialInventoryUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RepairMaterialInventory.
     * @param {RepairMaterialInventoryUpsertArgs} args - Arguments to update or create a RepairMaterialInventory.
     * @example
     * // Update or create a RepairMaterialInventory
     * const repairMaterialInventory = await prisma.repairMaterialInventory.upsert({
     *   create: {
     *     // ... data to create a RepairMaterialInventory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RepairMaterialInventory we want to update
     *   }
     * })
    **/
    upsert<T extends RepairMaterialInventoryUpsertArgs>(
      args: SelectSubset<T, RepairMaterialInventoryUpsertArgs>
    ): Prisma__RepairMaterialInventoryClient<RepairMaterialInventoryGetPayload<T>>

    /**
     * Count the number of RepairMaterialInventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairMaterialInventoryCountArgs} args - Arguments to filter RepairMaterialInventories to count.
     * @example
     * // Count the number of RepairMaterialInventories
     * const count = await prisma.repairMaterialInventory.count({
     *   where: {
     *     // ... the filter for the RepairMaterialInventories we want to count
     *   }
     * })
    **/
    count<T extends RepairMaterialInventoryCountArgs>(
      args?: Subset<T, RepairMaterialInventoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RepairMaterialInventoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RepairMaterialInventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairMaterialInventoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RepairMaterialInventoryAggregateArgs>(args: Subset<T, RepairMaterialInventoryAggregateArgs>): Prisma.PrismaPromise<GetRepairMaterialInventoryAggregateType<T>>

    /**
     * Group by RepairMaterialInventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairMaterialInventoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RepairMaterialInventoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RepairMaterialInventoryGroupByArgs['orderBy'] }
        : { orderBy?: RepairMaterialInventoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RepairMaterialInventoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRepairMaterialInventoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for RepairMaterialInventory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RepairMaterialInventoryClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    equipment<T extends EquipmentArgs= {}>(args?: Subset<T, EquipmentArgs>): Prisma__EquipmentClient<EquipmentGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * RepairMaterialInventory base type for findUnique actions
   */
  export type RepairMaterialInventoryFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the RepairMaterialInventory
     */
    select?: RepairMaterialInventorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairMaterialInventoryInclude | null
    /**
     * Filter, which RepairMaterialInventory to fetch.
     */
    where: RepairMaterialInventoryWhereUniqueInput
  }

  /**
   * RepairMaterialInventory findUnique
   */
  export interface RepairMaterialInventoryFindUniqueArgs extends RepairMaterialInventoryFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RepairMaterialInventory findUniqueOrThrow
   */
  export type RepairMaterialInventoryFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the RepairMaterialInventory
     */
    select?: RepairMaterialInventorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairMaterialInventoryInclude | null
    /**
     * Filter, which RepairMaterialInventory to fetch.
     */
    where: RepairMaterialInventoryWhereUniqueInput
  }


  /**
   * RepairMaterialInventory base type for findFirst actions
   */
  export type RepairMaterialInventoryFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the RepairMaterialInventory
     */
    select?: RepairMaterialInventorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairMaterialInventoryInclude | null
    /**
     * Filter, which RepairMaterialInventory to fetch.
     */
    where?: RepairMaterialInventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RepairMaterialInventories to fetch.
     */
    orderBy?: Enumerable<RepairMaterialInventoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RepairMaterialInventories.
     */
    cursor?: RepairMaterialInventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RepairMaterialInventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RepairMaterialInventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RepairMaterialInventories.
     */
    distinct?: Enumerable<RepairMaterialInventoryScalarFieldEnum>
  }

  /**
   * RepairMaterialInventory findFirst
   */
  export interface RepairMaterialInventoryFindFirstArgs extends RepairMaterialInventoryFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RepairMaterialInventory findFirstOrThrow
   */
  export type RepairMaterialInventoryFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the RepairMaterialInventory
     */
    select?: RepairMaterialInventorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairMaterialInventoryInclude | null
    /**
     * Filter, which RepairMaterialInventory to fetch.
     */
    where?: RepairMaterialInventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RepairMaterialInventories to fetch.
     */
    orderBy?: Enumerable<RepairMaterialInventoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RepairMaterialInventories.
     */
    cursor?: RepairMaterialInventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RepairMaterialInventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RepairMaterialInventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RepairMaterialInventories.
     */
    distinct?: Enumerable<RepairMaterialInventoryScalarFieldEnum>
  }


  /**
   * RepairMaterialInventory findMany
   */
  export type RepairMaterialInventoryFindManyArgs = {
    /**
     * Select specific fields to fetch from the RepairMaterialInventory
     */
    select?: RepairMaterialInventorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairMaterialInventoryInclude | null
    /**
     * Filter, which RepairMaterialInventories to fetch.
     */
    where?: RepairMaterialInventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RepairMaterialInventories to fetch.
     */
    orderBy?: Enumerable<RepairMaterialInventoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RepairMaterialInventories.
     */
    cursor?: RepairMaterialInventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RepairMaterialInventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RepairMaterialInventories.
     */
    skip?: number
    distinct?: Enumerable<RepairMaterialInventoryScalarFieldEnum>
  }


  /**
   * RepairMaterialInventory create
   */
  export type RepairMaterialInventoryCreateArgs = {
    /**
     * Select specific fields to fetch from the RepairMaterialInventory
     */
    select?: RepairMaterialInventorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairMaterialInventoryInclude | null
    /**
     * The data needed to create a RepairMaterialInventory.
     */
    data: XOR<RepairMaterialInventoryCreateInput, RepairMaterialInventoryUncheckedCreateInput>
  }


  /**
   * RepairMaterialInventory createMany
   */
  export type RepairMaterialInventoryCreateManyArgs = {
    /**
     * The data used to create many RepairMaterialInventories.
     */
    data: Enumerable<RepairMaterialInventoryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * RepairMaterialInventory update
   */
  export type RepairMaterialInventoryUpdateArgs = {
    /**
     * Select specific fields to fetch from the RepairMaterialInventory
     */
    select?: RepairMaterialInventorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairMaterialInventoryInclude | null
    /**
     * The data needed to update a RepairMaterialInventory.
     */
    data: XOR<RepairMaterialInventoryUpdateInput, RepairMaterialInventoryUncheckedUpdateInput>
    /**
     * Choose, which RepairMaterialInventory to update.
     */
    where: RepairMaterialInventoryWhereUniqueInput
  }


  /**
   * RepairMaterialInventory updateMany
   */
  export type RepairMaterialInventoryUpdateManyArgs = {
    /**
     * The data used to update RepairMaterialInventories.
     */
    data: XOR<RepairMaterialInventoryUpdateManyMutationInput, RepairMaterialInventoryUncheckedUpdateManyInput>
    /**
     * Filter which RepairMaterialInventories to update
     */
    where?: RepairMaterialInventoryWhereInput
  }


  /**
   * RepairMaterialInventory upsert
   */
  export type RepairMaterialInventoryUpsertArgs = {
    /**
     * Select specific fields to fetch from the RepairMaterialInventory
     */
    select?: RepairMaterialInventorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairMaterialInventoryInclude | null
    /**
     * The filter to search for the RepairMaterialInventory to update in case it exists.
     */
    where: RepairMaterialInventoryWhereUniqueInput
    /**
     * In case the RepairMaterialInventory found by the `where` argument doesn't exist, create a new RepairMaterialInventory with this data.
     */
    create: XOR<RepairMaterialInventoryCreateInput, RepairMaterialInventoryUncheckedCreateInput>
    /**
     * In case the RepairMaterialInventory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RepairMaterialInventoryUpdateInput, RepairMaterialInventoryUncheckedUpdateInput>
  }


  /**
   * RepairMaterialInventory delete
   */
  export type RepairMaterialInventoryDeleteArgs = {
    /**
     * Select specific fields to fetch from the RepairMaterialInventory
     */
    select?: RepairMaterialInventorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairMaterialInventoryInclude | null
    /**
     * Filter which RepairMaterialInventory to delete.
     */
    where: RepairMaterialInventoryWhereUniqueInput
  }


  /**
   * RepairMaterialInventory deleteMany
   */
  export type RepairMaterialInventoryDeleteManyArgs = {
    /**
     * Filter which RepairMaterialInventories to delete
     */
    where?: RepairMaterialInventoryWhereInput
  }


  /**
   * RepairMaterialInventory without action
   */
  export type RepairMaterialInventoryArgs = {
    /**
     * Select specific fields to fetch from the RepairMaterialInventory
     */
    select?: RepairMaterialInventorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairMaterialInventoryInclude | null
  }



  /**
   * Model RepairRecord
   */


  export type AggregateRepairRecord = {
    _count: RepairRecordCountAggregateOutputType | null
    _avg: RepairRecordAvgAggregateOutputType | null
    _sum: RepairRecordSumAggregateOutputType | null
    _min: RepairRecordMinAggregateOutputType | null
    _max: RepairRecordMaxAggregateOutputType | null
  }

  export type RepairRecordAvgAggregateOutputType = {
    id: number | null
    equipmentId: number | null
  }

  export type RepairRecordSumAggregateOutputType = {
    id: number | null
    equipmentId: number | null
  }

  export type RepairRecordMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    type: RepairType | null
    equipmentId: number | null
    status: RepairRecordStatus | null
    description: string | null
  }

  export type RepairRecordMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    type: RepairType | null
    equipmentId: number | null
    status: RepairRecordStatus | null
    description: string | null
  }

  export type RepairRecordCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    isDeleted: number
    type: number
    equipmentId: number
    status: number
    description: number
    _all: number
  }


  export type RepairRecordAvgAggregateInputType = {
    id?: true
    equipmentId?: true
  }

  export type RepairRecordSumAggregateInputType = {
    id?: true
    equipmentId?: true
  }

  export type RepairRecordMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    type?: true
    equipmentId?: true
    status?: true
    description?: true
  }

  export type RepairRecordMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    type?: true
    equipmentId?: true
    status?: true
    description?: true
  }

  export type RepairRecordCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    type?: true
    equipmentId?: true
    status?: true
    description?: true
    _all?: true
  }

  export type RepairRecordAggregateArgs = {
    /**
     * Filter which RepairRecord to aggregate.
     */
    where?: RepairRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RepairRecords to fetch.
     */
    orderBy?: Enumerable<RepairRecordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RepairRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RepairRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RepairRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RepairRecords
    **/
    _count?: true | RepairRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RepairRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RepairRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RepairRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RepairRecordMaxAggregateInputType
  }

  export type GetRepairRecordAggregateType<T extends RepairRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateRepairRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRepairRecord[P]>
      : GetScalarType<T[P], AggregateRepairRecord[P]>
  }




  export type RepairRecordGroupByArgs = {
    where?: RepairRecordWhereInput
    orderBy?: Enumerable<RepairRecordOrderByWithAggregationInput>
    by: RepairRecordScalarFieldEnum[]
    having?: RepairRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RepairRecordCountAggregateInputType | true
    _avg?: RepairRecordAvgAggregateInputType
    _sum?: RepairRecordSumAggregateInputType
    _min?: RepairRecordMinAggregateInputType
    _max?: RepairRecordMaxAggregateInputType
  }


  export type RepairRecordGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    isDeleted: boolean
    type: RepairType
    equipmentId: number
    status: RepairRecordStatus
    description: string
    _count: RepairRecordCountAggregateOutputType | null
    _avg: RepairRecordAvgAggregateOutputType | null
    _sum: RepairRecordSumAggregateOutputType | null
    _min: RepairRecordMinAggregateOutputType | null
    _max: RepairRecordMaxAggregateOutputType | null
  }

  type GetRepairRecordGroupByPayload<T extends RepairRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<RepairRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RepairRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RepairRecordGroupByOutputType[P]>
            : GetScalarType<T[P], RepairRecordGroupByOutputType[P]>
        }
      >
    >


  export type RepairRecordSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    type?: boolean
    equipmentId?: boolean
    status?: boolean
    description?: boolean
    equipment?: boolean | EquipmentArgs
  }


  export type RepairRecordInclude = {
    equipment?: boolean | EquipmentArgs
  }

  export type RepairRecordGetPayload<S extends boolean | null | undefined | RepairRecordArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? RepairRecord :
    S extends undefined ? never :
    S extends { include: any } & (RepairRecordArgs | RepairRecordFindManyArgs)
    ? RepairRecord  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'equipment' ? EquipmentGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (RepairRecordArgs | RepairRecordFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'equipment' ? EquipmentGetPayload<S['select'][P]> :  P extends keyof RepairRecord ? RepairRecord[P] : never
  } 
      : RepairRecord


  type RepairRecordCountArgs = 
    Omit<RepairRecordFindManyArgs, 'select' | 'include'> & {
      select?: RepairRecordCountAggregateInputType | true
    }

  export interface RepairRecordDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one RepairRecord that matches the filter.
     * @param {RepairRecordFindUniqueArgs} args - Arguments to find a RepairRecord
     * @example
     * // Get one RepairRecord
     * const repairRecord = await prisma.repairRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RepairRecordFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RepairRecordFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'RepairRecord'> extends True ? Prisma__RepairRecordClient<RepairRecordGetPayload<T>> : Prisma__RepairRecordClient<RepairRecordGetPayload<T> | null, null>

    /**
     * Find one RepairRecord that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RepairRecordFindUniqueOrThrowArgs} args - Arguments to find a RepairRecord
     * @example
     * // Get one RepairRecord
     * const repairRecord = await prisma.repairRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RepairRecordFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, RepairRecordFindUniqueOrThrowArgs>
    ): Prisma__RepairRecordClient<RepairRecordGetPayload<T>>

    /**
     * Find the first RepairRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairRecordFindFirstArgs} args - Arguments to find a RepairRecord
     * @example
     * // Get one RepairRecord
     * const repairRecord = await prisma.repairRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RepairRecordFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RepairRecordFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'RepairRecord'> extends True ? Prisma__RepairRecordClient<RepairRecordGetPayload<T>> : Prisma__RepairRecordClient<RepairRecordGetPayload<T> | null, null>

    /**
     * Find the first RepairRecord that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairRecordFindFirstOrThrowArgs} args - Arguments to find a RepairRecord
     * @example
     * // Get one RepairRecord
     * const repairRecord = await prisma.repairRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RepairRecordFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RepairRecordFindFirstOrThrowArgs>
    ): Prisma__RepairRecordClient<RepairRecordGetPayload<T>>

    /**
     * Find zero or more RepairRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairRecordFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RepairRecords
     * const repairRecords = await prisma.repairRecord.findMany()
     * 
     * // Get first 10 RepairRecords
     * const repairRecords = await prisma.repairRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const repairRecordWithIdOnly = await prisma.repairRecord.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RepairRecordFindManyArgs>(
      args?: SelectSubset<T, RepairRecordFindManyArgs>
    ): Prisma.PrismaPromise<Array<RepairRecordGetPayload<T>>>

    /**
     * Create a RepairRecord.
     * @param {RepairRecordCreateArgs} args - Arguments to create a RepairRecord.
     * @example
     * // Create one RepairRecord
     * const RepairRecord = await prisma.repairRecord.create({
     *   data: {
     *     // ... data to create a RepairRecord
     *   }
     * })
     * 
    **/
    create<T extends RepairRecordCreateArgs>(
      args: SelectSubset<T, RepairRecordCreateArgs>
    ): Prisma__RepairRecordClient<RepairRecordGetPayload<T>>

    /**
     * Create many RepairRecords.
     *     @param {RepairRecordCreateManyArgs} args - Arguments to create many RepairRecords.
     *     @example
     *     // Create many RepairRecords
     *     const repairRecord = await prisma.repairRecord.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RepairRecordCreateManyArgs>(
      args?: SelectSubset<T, RepairRecordCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RepairRecord.
     * @param {RepairRecordDeleteArgs} args - Arguments to delete one RepairRecord.
     * @example
     * // Delete one RepairRecord
     * const RepairRecord = await prisma.repairRecord.delete({
     *   where: {
     *     // ... filter to delete one RepairRecord
     *   }
     * })
     * 
    **/
    delete<T extends RepairRecordDeleteArgs>(
      args: SelectSubset<T, RepairRecordDeleteArgs>
    ): Prisma__RepairRecordClient<RepairRecordGetPayload<T>>

    /**
     * Update one RepairRecord.
     * @param {RepairRecordUpdateArgs} args - Arguments to update one RepairRecord.
     * @example
     * // Update one RepairRecord
     * const repairRecord = await prisma.repairRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RepairRecordUpdateArgs>(
      args: SelectSubset<T, RepairRecordUpdateArgs>
    ): Prisma__RepairRecordClient<RepairRecordGetPayload<T>>

    /**
     * Delete zero or more RepairRecords.
     * @param {RepairRecordDeleteManyArgs} args - Arguments to filter RepairRecords to delete.
     * @example
     * // Delete a few RepairRecords
     * const { count } = await prisma.repairRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RepairRecordDeleteManyArgs>(
      args?: SelectSubset<T, RepairRecordDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RepairRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RepairRecords
     * const repairRecord = await prisma.repairRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RepairRecordUpdateManyArgs>(
      args: SelectSubset<T, RepairRecordUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RepairRecord.
     * @param {RepairRecordUpsertArgs} args - Arguments to update or create a RepairRecord.
     * @example
     * // Update or create a RepairRecord
     * const repairRecord = await prisma.repairRecord.upsert({
     *   create: {
     *     // ... data to create a RepairRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RepairRecord we want to update
     *   }
     * })
    **/
    upsert<T extends RepairRecordUpsertArgs>(
      args: SelectSubset<T, RepairRecordUpsertArgs>
    ): Prisma__RepairRecordClient<RepairRecordGetPayload<T>>

    /**
     * Count the number of RepairRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairRecordCountArgs} args - Arguments to filter RepairRecords to count.
     * @example
     * // Count the number of RepairRecords
     * const count = await prisma.repairRecord.count({
     *   where: {
     *     // ... the filter for the RepairRecords we want to count
     *   }
     * })
    **/
    count<T extends RepairRecordCountArgs>(
      args?: Subset<T, RepairRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RepairRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RepairRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RepairRecordAggregateArgs>(args: Subset<T, RepairRecordAggregateArgs>): Prisma.PrismaPromise<GetRepairRecordAggregateType<T>>

    /**
     * Group by RepairRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RepairRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RepairRecordGroupByArgs['orderBy'] }
        : { orderBy?: RepairRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RepairRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRepairRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for RepairRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RepairRecordClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    equipment<T extends EquipmentArgs= {}>(args?: Subset<T, EquipmentArgs>): Prisma__EquipmentClient<EquipmentGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * RepairRecord base type for findUnique actions
   */
  export type RepairRecordFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the RepairRecord
     */
    select?: RepairRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairRecordInclude | null
    /**
     * Filter, which RepairRecord to fetch.
     */
    where: RepairRecordWhereUniqueInput
  }

  /**
   * RepairRecord findUnique
   */
  export interface RepairRecordFindUniqueArgs extends RepairRecordFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RepairRecord findUniqueOrThrow
   */
  export type RepairRecordFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the RepairRecord
     */
    select?: RepairRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairRecordInclude | null
    /**
     * Filter, which RepairRecord to fetch.
     */
    where: RepairRecordWhereUniqueInput
  }


  /**
   * RepairRecord base type for findFirst actions
   */
  export type RepairRecordFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the RepairRecord
     */
    select?: RepairRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairRecordInclude | null
    /**
     * Filter, which RepairRecord to fetch.
     */
    where?: RepairRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RepairRecords to fetch.
     */
    orderBy?: Enumerable<RepairRecordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RepairRecords.
     */
    cursor?: RepairRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RepairRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RepairRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RepairRecords.
     */
    distinct?: Enumerable<RepairRecordScalarFieldEnum>
  }

  /**
   * RepairRecord findFirst
   */
  export interface RepairRecordFindFirstArgs extends RepairRecordFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RepairRecord findFirstOrThrow
   */
  export type RepairRecordFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the RepairRecord
     */
    select?: RepairRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairRecordInclude | null
    /**
     * Filter, which RepairRecord to fetch.
     */
    where?: RepairRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RepairRecords to fetch.
     */
    orderBy?: Enumerable<RepairRecordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RepairRecords.
     */
    cursor?: RepairRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RepairRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RepairRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RepairRecords.
     */
    distinct?: Enumerable<RepairRecordScalarFieldEnum>
  }


  /**
   * RepairRecord findMany
   */
  export type RepairRecordFindManyArgs = {
    /**
     * Select specific fields to fetch from the RepairRecord
     */
    select?: RepairRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairRecordInclude | null
    /**
     * Filter, which RepairRecords to fetch.
     */
    where?: RepairRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RepairRecords to fetch.
     */
    orderBy?: Enumerable<RepairRecordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RepairRecords.
     */
    cursor?: RepairRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RepairRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RepairRecords.
     */
    skip?: number
    distinct?: Enumerable<RepairRecordScalarFieldEnum>
  }


  /**
   * RepairRecord create
   */
  export type RepairRecordCreateArgs = {
    /**
     * Select specific fields to fetch from the RepairRecord
     */
    select?: RepairRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairRecordInclude | null
    /**
     * The data needed to create a RepairRecord.
     */
    data: XOR<RepairRecordCreateInput, RepairRecordUncheckedCreateInput>
  }


  /**
   * RepairRecord createMany
   */
  export type RepairRecordCreateManyArgs = {
    /**
     * The data used to create many RepairRecords.
     */
    data: Enumerable<RepairRecordCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * RepairRecord update
   */
  export type RepairRecordUpdateArgs = {
    /**
     * Select specific fields to fetch from the RepairRecord
     */
    select?: RepairRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairRecordInclude | null
    /**
     * The data needed to update a RepairRecord.
     */
    data: XOR<RepairRecordUpdateInput, RepairRecordUncheckedUpdateInput>
    /**
     * Choose, which RepairRecord to update.
     */
    where: RepairRecordWhereUniqueInput
  }


  /**
   * RepairRecord updateMany
   */
  export type RepairRecordUpdateManyArgs = {
    /**
     * The data used to update RepairRecords.
     */
    data: XOR<RepairRecordUpdateManyMutationInput, RepairRecordUncheckedUpdateManyInput>
    /**
     * Filter which RepairRecords to update
     */
    where?: RepairRecordWhereInput
  }


  /**
   * RepairRecord upsert
   */
  export type RepairRecordUpsertArgs = {
    /**
     * Select specific fields to fetch from the RepairRecord
     */
    select?: RepairRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairRecordInclude | null
    /**
     * The filter to search for the RepairRecord to update in case it exists.
     */
    where: RepairRecordWhereUniqueInput
    /**
     * In case the RepairRecord found by the `where` argument doesn't exist, create a new RepairRecord with this data.
     */
    create: XOR<RepairRecordCreateInput, RepairRecordUncheckedCreateInput>
    /**
     * In case the RepairRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RepairRecordUpdateInput, RepairRecordUncheckedUpdateInput>
  }


  /**
   * RepairRecord delete
   */
  export type RepairRecordDeleteArgs = {
    /**
     * Select specific fields to fetch from the RepairRecord
     */
    select?: RepairRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairRecordInclude | null
    /**
     * Filter which RepairRecord to delete.
     */
    where: RepairRecordWhereUniqueInput
  }


  /**
   * RepairRecord deleteMany
   */
  export type RepairRecordDeleteManyArgs = {
    /**
     * Filter which RepairRecords to delete
     */
    where?: RepairRecordWhereInput
  }


  /**
   * RepairRecord without action
   */
  export type RepairRecordArgs = {
    /**
     * Select specific fields to fetch from the RepairRecord
     */
    select?: RepairRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairRecordInclude | null
  }



  /**
   * Model Part
   */


  export type AggregatePart = {
    _count: PartCountAggregateOutputType | null
    _avg: PartAvgAggregateOutputType | null
    _sum: PartSumAggregateOutputType | null
    _min: PartMinAggregateOutputType | null
    _max: PartMaxAggregateOutputType | null
  }

  export type PartAvgAggregateOutputType = {
    id: number | null
  }

  export type PartSumAggregateOutputType = {
    id: number | null
  }

  export type PartMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    no: string | null
    name: string | null
  }

  export type PartMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    no: string | null
    name: string | null
  }

  export type PartCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    isDeleted: number
    no: number
    name: number
    _all: number
  }


  export type PartAvgAggregateInputType = {
    id?: true
  }

  export type PartSumAggregateInputType = {
    id?: true
  }

  export type PartMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    no?: true
    name?: true
  }

  export type PartMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    no?: true
    name?: true
  }

  export type PartCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    no?: true
    name?: true
    _all?: true
  }

  export type PartAggregateArgs = {
    /**
     * Filter which Part to aggregate.
     */
    where?: PartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parts to fetch.
     */
    orderBy?: Enumerable<PartOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Parts
    **/
    _count?: true | PartCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PartAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PartSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PartMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PartMaxAggregateInputType
  }

  export type GetPartAggregateType<T extends PartAggregateArgs> = {
        [P in keyof T & keyof AggregatePart]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePart[P]>
      : GetScalarType<T[P], AggregatePart[P]>
  }




  export type PartGroupByArgs = {
    where?: PartWhereInput
    orderBy?: Enumerable<PartOrderByWithAggregationInput>
    by: PartScalarFieldEnum[]
    having?: PartScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PartCountAggregateInputType | true
    _avg?: PartAvgAggregateInputType
    _sum?: PartSumAggregateInputType
    _min?: PartMinAggregateInputType
    _max?: PartMaxAggregateInputType
  }


  export type PartGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    isDeleted: boolean
    no: string
    name: string
    _count: PartCountAggregateOutputType | null
    _avg: PartAvgAggregateOutputType | null
    _sum: PartSumAggregateOutputType | null
    _min: PartMinAggregateOutputType | null
    _max: PartMaxAggregateOutputType | null
  }

  type GetPartGroupByPayload<T extends PartGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PartGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PartGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PartGroupByOutputType[P]>
            : GetScalarType<T[P], PartGroupByOutputType[P]>
        }
      >
    >


  export type PartSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    no?: boolean
    name?: boolean
    partVersions?: boolean | Part$partVersionsArgs
    partOperation?: boolean | Part$partOperationArgs
    workerOrders?: boolean | Part$workerOrdersArgs
    nonconformItems?: boolean | Part$nonconformItemsArgs
    _count?: boolean | PartCountOutputTypeArgs
  }


  export type PartInclude = {
    partVersions?: boolean | Part$partVersionsArgs
    partOperation?: boolean | Part$partOperationArgs
    workerOrders?: boolean | Part$workerOrdersArgs
    nonconformItems?: boolean | Part$nonconformItemsArgs
    _count?: boolean | PartCountOutputTypeArgs
  }

  export type PartGetPayload<S extends boolean | null | undefined | PartArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Part :
    S extends undefined ? never :
    S extends { include: any } & (PartArgs | PartFindManyArgs)
    ? Part  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'partVersions' ? Array < PartVersionGetPayload<S['include'][P]>>  :
        P extends 'partOperation' ? Array < PartOperationGetPayload<S['include'][P]>>  :
        P extends 'workerOrders' ? Array < WorkerOrderGetPayload<S['include'][P]>>  :
        P extends 'nonconformItems' ? Array < NonconformItemGetPayload<S['include'][P]>>  :
        P extends '_count' ? PartCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (PartArgs | PartFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'partVersions' ? Array < PartVersionGetPayload<S['select'][P]>>  :
        P extends 'partOperation' ? Array < PartOperationGetPayload<S['select'][P]>>  :
        P extends 'workerOrders' ? Array < WorkerOrderGetPayload<S['select'][P]>>  :
        P extends 'nonconformItems' ? Array < NonconformItemGetPayload<S['select'][P]>>  :
        P extends '_count' ? PartCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Part ? Part[P] : never
  } 
      : Part


  type PartCountArgs = 
    Omit<PartFindManyArgs, 'select' | 'include'> & {
      select?: PartCountAggregateInputType | true
    }

  export interface PartDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Part that matches the filter.
     * @param {PartFindUniqueArgs} args - Arguments to find a Part
     * @example
     * // Get one Part
     * const part = await prisma.part.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PartFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PartFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Part'> extends True ? Prisma__PartClient<PartGetPayload<T>> : Prisma__PartClient<PartGetPayload<T> | null, null>

    /**
     * Find one Part that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PartFindUniqueOrThrowArgs} args - Arguments to find a Part
     * @example
     * // Get one Part
     * const part = await prisma.part.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PartFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PartFindUniqueOrThrowArgs>
    ): Prisma__PartClient<PartGetPayload<T>>

    /**
     * Find the first Part that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartFindFirstArgs} args - Arguments to find a Part
     * @example
     * // Get one Part
     * const part = await prisma.part.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PartFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PartFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Part'> extends True ? Prisma__PartClient<PartGetPayload<T>> : Prisma__PartClient<PartGetPayload<T> | null, null>

    /**
     * Find the first Part that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartFindFirstOrThrowArgs} args - Arguments to find a Part
     * @example
     * // Get one Part
     * const part = await prisma.part.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PartFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PartFindFirstOrThrowArgs>
    ): Prisma__PartClient<PartGetPayload<T>>

    /**
     * Find zero or more Parts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Parts
     * const parts = await prisma.part.findMany()
     * 
     * // Get first 10 Parts
     * const parts = await prisma.part.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const partWithIdOnly = await prisma.part.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PartFindManyArgs>(
      args?: SelectSubset<T, PartFindManyArgs>
    ): Prisma.PrismaPromise<Array<PartGetPayload<T>>>

    /**
     * Create a Part.
     * @param {PartCreateArgs} args - Arguments to create a Part.
     * @example
     * // Create one Part
     * const Part = await prisma.part.create({
     *   data: {
     *     // ... data to create a Part
     *   }
     * })
     * 
    **/
    create<T extends PartCreateArgs>(
      args: SelectSubset<T, PartCreateArgs>
    ): Prisma__PartClient<PartGetPayload<T>>

    /**
     * Create many Parts.
     *     @param {PartCreateManyArgs} args - Arguments to create many Parts.
     *     @example
     *     // Create many Parts
     *     const part = await prisma.part.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PartCreateManyArgs>(
      args?: SelectSubset<T, PartCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Part.
     * @param {PartDeleteArgs} args - Arguments to delete one Part.
     * @example
     * // Delete one Part
     * const Part = await prisma.part.delete({
     *   where: {
     *     // ... filter to delete one Part
     *   }
     * })
     * 
    **/
    delete<T extends PartDeleteArgs>(
      args: SelectSubset<T, PartDeleteArgs>
    ): Prisma__PartClient<PartGetPayload<T>>

    /**
     * Update one Part.
     * @param {PartUpdateArgs} args - Arguments to update one Part.
     * @example
     * // Update one Part
     * const part = await prisma.part.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PartUpdateArgs>(
      args: SelectSubset<T, PartUpdateArgs>
    ): Prisma__PartClient<PartGetPayload<T>>

    /**
     * Delete zero or more Parts.
     * @param {PartDeleteManyArgs} args - Arguments to filter Parts to delete.
     * @example
     * // Delete a few Parts
     * const { count } = await prisma.part.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PartDeleteManyArgs>(
      args?: SelectSubset<T, PartDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Parts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Parts
     * const part = await prisma.part.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PartUpdateManyArgs>(
      args: SelectSubset<T, PartUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Part.
     * @param {PartUpsertArgs} args - Arguments to update or create a Part.
     * @example
     * // Update or create a Part
     * const part = await prisma.part.upsert({
     *   create: {
     *     // ... data to create a Part
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Part we want to update
     *   }
     * })
    **/
    upsert<T extends PartUpsertArgs>(
      args: SelectSubset<T, PartUpsertArgs>
    ): Prisma__PartClient<PartGetPayload<T>>

    /**
     * Count the number of Parts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartCountArgs} args - Arguments to filter Parts to count.
     * @example
     * // Count the number of Parts
     * const count = await prisma.part.count({
     *   where: {
     *     // ... the filter for the Parts we want to count
     *   }
     * })
    **/
    count<T extends PartCountArgs>(
      args?: Subset<T, PartCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PartCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Part.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PartAggregateArgs>(args: Subset<T, PartAggregateArgs>): Prisma.PrismaPromise<GetPartAggregateType<T>>

    /**
     * Group by Part.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PartGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PartGroupByArgs['orderBy'] }
        : { orderBy?: PartGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PartGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPartGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Part.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PartClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    partVersions<T extends Part$partVersionsArgs= {}>(args?: Subset<T, Part$partVersionsArgs>): Prisma.PrismaPromise<Array<PartVersionGetPayload<T>>| Null>;

    partOperation<T extends Part$partOperationArgs= {}>(args?: Subset<T, Part$partOperationArgs>): Prisma.PrismaPromise<Array<PartOperationGetPayload<T>>| Null>;

    workerOrders<T extends Part$workerOrdersArgs= {}>(args?: Subset<T, Part$workerOrdersArgs>): Prisma.PrismaPromise<Array<WorkerOrderGetPayload<T>>| Null>;

    nonconformItems<T extends Part$nonconformItemsArgs= {}>(args?: Subset<T, Part$nonconformItemsArgs>): Prisma.PrismaPromise<Array<NonconformItemGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Part base type for findUnique actions
   */
  export type PartFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Part
     */
    select?: PartSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartInclude | null
    /**
     * Filter, which Part to fetch.
     */
    where: PartWhereUniqueInput
  }

  /**
   * Part findUnique
   */
  export interface PartFindUniqueArgs extends PartFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Part findUniqueOrThrow
   */
  export type PartFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Part
     */
    select?: PartSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartInclude | null
    /**
     * Filter, which Part to fetch.
     */
    where: PartWhereUniqueInput
  }


  /**
   * Part base type for findFirst actions
   */
  export type PartFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Part
     */
    select?: PartSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartInclude | null
    /**
     * Filter, which Part to fetch.
     */
    where?: PartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parts to fetch.
     */
    orderBy?: Enumerable<PartOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Parts.
     */
    cursor?: PartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Parts.
     */
    distinct?: Enumerable<PartScalarFieldEnum>
  }

  /**
   * Part findFirst
   */
  export interface PartFindFirstArgs extends PartFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Part findFirstOrThrow
   */
  export type PartFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Part
     */
    select?: PartSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartInclude | null
    /**
     * Filter, which Part to fetch.
     */
    where?: PartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parts to fetch.
     */
    orderBy?: Enumerable<PartOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Parts.
     */
    cursor?: PartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Parts.
     */
    distinct?: Enumerable<PartScalarFieldEnum>
  }


  /**
   * Part findMany
   */
  export type PartFindManyArgs = {
    /**
     * Select specific fields to fetch from the Part
     */
    select?: PartSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartInclude | null
    /**
     * Filter, which Parts to fetch.
     */
    where?: PartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parts to fetch.
     */
    orderBy?: Enumerable<PartOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Parts.
     */
    cursor?: PartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parts.
     */
    skip?: number
    distinct?: Enumerable<PartScalarFieldEnum>
  }


  /**
   * Part create
   */
  export type PartCreateArgs = {
    /**
     * Select specific fields to fetch from the Part
     */
    select?: PartSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartInclude | null
    /**
     * The data needed to create a Part.
     */
    data: XOR<PartCreateInput, PartUncheckedCreateInput>
  }


  /**
   * Part createMany
   */
  export type PartCreateManyArgs = {
    /**
     * The data used to create many Parts.
     */
    data: Enumerable<PartCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Part update
   */
  export type PartUpdateArgs = {
    /**
     * Select specific fields to fetch from the Part
     */
    select?: PartSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartInclude | null
    /**
     * The data needed to update a Part.
     */
    data: XOR<PartUpdateInput, PartUncheckedUpdateInput>
    /**
     * Choose, which Part to update.
     */
    where: PartWhereUniqueInput
  }


  /**
   * Part updateMany
   */
  export type PartUpdateManyArgs = {
    /**
     * The data used to update Parts.
     */
    data: XOR<PartUpdateManyMutationInput, PartUncheckedUpdateManyInput>
    /**
     * Filter which Parts to update
     */
    where?: PartWhereInput
  }


  /**
   * Part upsert
   */
  export type PartUpsertArgs = {
    /**
     * Select specific fields to fetch from the Part
     */
    select?: PartSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartInclude | null
    /**
     * The filter to search for the Part to update in case it exists.
     */
    where: PartWhereUniqueInput
    /**
     * In case the Part found by the `where` argument doesn't exist, create a new Part with this data.
     */
    create: XOR<PartCreateInput, PartUncheckedCreateInput>
    /**
     * In case the Part was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PartUpdateInput, PartUncheckedUpdateInput>
  }


  /**
   * Part delete
   */
  export type PartDeleteArgs = {
    /**
     * Select specific fields to fetch from the Part
     */
    select?: PartSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartInclude | null
    /**
     * Filter which Part to delete.
     */
    where: PartWhereUniqueInput
  }


  /**
   * Part deleteMany
   */
  export type PartDeleteManyArgs = {
    /**
     * Filter which Parts to delete
     */
    where?: PartWhereInput
  }


  /**
   * Part.partVersions
   */
  export type Part$partVersionsArgs = {
    /**
     * Select specific fields to fetch from the PartVersion
     */
    select?: PartVersionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartVersionInclude | null
    where?: PartVersionWhereInput
    orderBy?: Enumerable<PartVersionOrderByWithRelationInput>
    cursor?: PartVersionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PartVersionScalarFieldEnum>
  }


  /**
   * Part.partOperation
   */
  export type Part$partOperationArgs = {
    /**
     * Select specific fields to fetch from the PartOperation
     */
    select?: PartOperationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartOperationInclude | null
    where?: PartOperationWhereInput
    orderBy?: Enumerable<PartOperationOrderByWithRelationInput>
    cursor?: PartOperationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PartOperationScalarFieldEnum>
  }


  /**
   * Part.workerOrders
   */
  export type Part$workerOrdersArgs = {
    /**
     * Select specific fields to fetch from the WorkerOrder
     */
    select?: WorkerOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkerOrderInclude | null
    where?: WorkerOrderWhereInput
    orderBy?: Enumerable<WorkerOrderOrderByWithRelationInput>
    cursor?: WorkerOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<WorkerOrderScalarFieldEnum>
  }


  /**
   * Part.nonconformItems
   */
  export type Part$nonconformItemsArgs = {
    /**
     * Select specific fields to fetch from the NonconformItem
     */
    select?: NonconformItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NonconformItemInclude | null
    where?: NonconformItemWhereInput
    orderBy?: Enumerable<NonconformItemOrderByWithRelationInput>
    cursor?: NonconformItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<NonconformItemScalarFieldEnum>
  }


  /**
   * Part without action
   */
  export type PartArgs = {
    /**
     * Select specific fields to fetch from the Part
     */
    select?: PartSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartInclude | null
  }



  /**
   * Model PartVersion
   */


  export type AggregatePartVersion = {
    _count: PartVersionCountAggregateOutputType | null
    _avg: PartVersionAvgAggregateOutputType | null
    _sum: PartVersionSumAggregateOutputType | null
    _min: PartVersionMinAggregateOutputType | null
    _max: PartVersionMaxAggregateOutputType | null
  }

  export type PartVersionAvgAggregateOutputType = {
    id: number | null
    partId: number | null
  }

  export type PartVersionSumAggregateOutputType = {
    id: number | null
    partId: number | null
  }

  export type PartVersionMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    version: string | null
    note: string | null
    partId: number | null
  }

  export type PartVersionMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    version: string | null
    note: string | null
    partId: number | null
  }

  export type PartVersionCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    isDeleted: number
    version: number
    note: number
    partId: number
    _all: number
  }


  export type PartVersionAvgAggregateInputType = {
    id?: true
    partId?: true
  }

  export type PartVersionSumAggregateInputType = {
    id?: true
    partId?: true
  }

  export type PartVersionMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    version?: true
    note?: true
    partId?: true
  }

  export type PartVersionMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    version?: true
    note?: true
    partId?: true
  }

  export type PartVersionCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    version?: true
    note?: true
    partId?: true
    _all?: true
  }

  export type PartVersionAggregateArgs = {
    /**
     * Filter which PartVersion to aggregate.
     */
    where?: PartVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PartVersions to fetch.
     */
    orderBy?: Enumerable<PartVersionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PartVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PartVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PartVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PartVersions
    **/
    _count?: true | PartVersionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PartVersionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PartVersionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PartVersionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PartVersionMaxAggregateInputType
  }

  export type GetPartVersionAggregateType<T extends PartVersionAggregateArgs> = {
        [P in keyof T & keyof AggregatePartVersion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePartVersion[P]>
      : GetScalarType<T[P], AggregatePartVersion[P]>
  }




  export type PartVersionGroupByArgs = {
    where?: PartVersionWhereInput
    orderBy?: Enumerable<PartVersionOrderByWithAggregationInput>
    by: PartVersionScalarFieldEnum[]
    having?: PartVersionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PartVersionCountAggregateInputType | true
    _avg?: PartVersionAvgAggregateInputType
    _sum?: PartVersionSumAggregateInputType
    _min?: PartVersionMinAggregateInputType
    _max?: PartVersionMaxAggregateInputType
  }


  export type PartVersionGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    isDeleted: boolean
    version: string
    note: string | null
    partId: number
    _count: PartVersionCountAggregateOutputType | null
    _avg: PartVersionAvgAggregateOutputType | null
    _sum: PartVersionSumAggregateOutputType | null
    _min: PartVersionMinAggregateOutputType | null
    _max: PartVersionMaxAggregateOutputType | null
  }

  type GetPartVersionGroupByPayload<T extends PartVersionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PartVersionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PartVersionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PartVersionGroupByOutputType[P]>
            : GetScalarType<T[P], PartVersionGroupByOutputType[P]>
        }
      >
    >


  export type PartVersionSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    version?: boolean
    note?: boolean
    partId?: boolean
    part?: boolean | PartArgs
    incomingInspectionSpec?: boolean | IncomingInspectionSpecArgs
    receipts?: boolean | PartVersion$receiptsArgs
    _count?: boolean | PartVersionCountOutputTypeArgs
  }


  export type PartVersionInclude = {
    part?: boolean | PartArgs
    incomingInspectionSpec?: boolean | IncomingInspectionSpecArgs
    receipts?: boolean | PartVersion$receiptsArgs
    _count?: boolean | PartVersionCountOutputTypeArgs
  }

  export type PartVersionGetPayload<S extends boolean | null | undefined | PartVersionArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? PartVersion :
    S extends undefined ? never :
    S extends { include: any } & (PartVersionArgs | PartVersionFindManyArgs)
    ? PartVersion  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'part' ? PartGetPayload<S['include'][P]> :
        P extends 'incomingInspectionSpec' ? IncomingInspectionSpecGetPayload<S['include'][P]> | null :
        P extends 'receipts' ? Array < ReceiptGetPayload<S['include'][P]>>  :
        P extends '_count' ? PartVersionCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (PartVersionArgs | PartVersionFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'part' ? PartGetPayload<S['select'][P]> :
        P extends 'incomingInspectionSpec' ? IncomingInspectionSpecGetPayload<S['select'][P]> | null :
        P extends 'receipts' ? Array < ReceiptGetPayload<S['select'][P]>>  :
        P extends '_count' ? PartVersionCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof PartVersion ? PartVersion[P] : never
  } 
      : PartVersion


  type PartVersionCountArgs = 
    Omit<PartVersionFindManyArgs, 'select' | 'include'> & {
      select?: PartVersionCountAggregateInputType | true
    }

  export interface PartVersionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one PartVersion that matches the filter.
     * @param {PartVersionFindUniqueArgs} args - Arguments to find a PartVersion
     * @example
     * // Get one PartVersion
     * const partVersion = await prisma.partVersion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PartVersionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PartVersionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PartVersion'> extends True ? Prisma__PartVersionClient<PartVersionGetPayload<T>> : Prisma__PartVersionClient<PartVersionGetPayload<T> | null, null>

    /**
     * Find one PartVersion that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PartVersionFindUniqueOrThrowArgs} args - Arguments to find a PartVersion
     * @example
     * // Get one PartVersion
     * const partVersion = await prisma.partVersion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PartVersionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PartVersionFindUniqueOrThrowArgs>
    ): Prisma__PartVersionClient<PartVersionGetPayload<T>>

    /**
     * Find the first PartVersion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartVersionFindFirstArgs} args - Arguments to find a PartVersion
     * @example
     * // Get one PartVersion
     * const partVersion = await prisma.partVersion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PartVersionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PartVersionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PartVersion'> extends True ? Prisma__PartVersionClient<PartVersionGetPayload<T>> : Prisma__PartVersionClient<PartVersionGetPayload<T> | null, null>

    /**
     * Find the first PartVersion that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartVersionFindFirstOrThrowArgs} args - Arguments to find a PartVersion
     * @example
     * // Get one PartVersion
     * const partVersion = await prisma.partVersion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PartVersionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PartVersionFindFirstOrThrowArgs>
    ): Prisma__PartVersionClient<PartVersionGetPayload<T>>

    /**
     * Find zero or more PartVersions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartVersionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PartVersions
     * const partVersions = await prisma.partVersion.findMany()
     * 
     * // Get first 10 PartVersions
     * const partVersions = await prisma.partVersion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const partVersionWithIdOnly = await prisma.partVersion.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PartVersionFindManyArgs>(
      args?: SelectSubset<T, PartVersionFindManyArgs>
    ): Prisma.PrismaPromise<Array<PartVersionGetPayload<T>>>

    /**
     * Create a PartVersion.
     * @param {PartVersionCreateArgs} args - Arguments to create a PartVersion.
     * @example
     * // Create one PartVersion
     * const PartVersion = await prisma.partVersion.create({
     *   data: {
     *     // ... data to create a PartVersion
     *   }
     * })
     * 
    **/
    create<T extends PartVersionCreateArgs>(
      args: SelectSubset<T, PartVersionCreateArgs>
    ): Prisma__PartVersionClient<PartVersionGetPayload<T>>

    /**
     * Create many PartVersions.
     *     @param {PartVersionCreateManyArgs} args - Arguments to create many PartVersions.
     *     @example
     *     // Create many PartVersions
     *     const partVersion = await prisma.partVersion.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PartVersionCreateManyArgs>(
      args?: SelectSubset<T, PartVersionCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PartVersion.
     * @param {PartVersionDeleteArgs} args - Arguments to delete one PartVersion.
     * @example
     * // Delete one PartVersion
     * const PartVersion = await prisma.partVersion.delete({
     *   where: {
     *     // ... filter to delete one PartVersion
     *   }
     * })
     * 
    **/
    delete<T extends PartVersionDeleteArgs>(
      args: SelectSubset<T, PartVersionDeleteArgs>
    ): Prisma__PartVersionClient<PartVersionGetPayload<T>>

    /**
     * Update one PartVersion.
     * @param {PartVersionUpdateArgs} args - Arguments to update one PartVersion.
     * @example
     * // Update one PartVersion
     * const partVersion = await prisma.partVersion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PartVersionUpdateArgs>(
      args: SelectSubset<T, PartVersionUpdateArgs>
    ): Prisma__PartVersionClient<PartVersionGetPayload<T>>

    /**
     * Delete zero or more PartVersions.
     * @param {PartVersionDeleteManyArgs} args - Arguments to filter PartVersions to delete.
     * @example
     * // Delete a few PartVersions
     * const { count } = await prisma.partVersion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PartVersionDeleteManyArgs>(
      args?: SelectSubset<T, PartVersionDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PartVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartVersionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PartVersions
     * const partVersion = await prisma.partVersion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PartVersionUpdateManyArgs>(
      args: SelectSubset<T, PartVersionUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PartVersion.
     * @param {PartVersionUpsertArgs} args - Arguments to update or create a PartVersion.
     * @example
     * // Update or create a PartVersion
     * const partVersion = await prisma.partVersion.upsert({
     *   create: {
     *     // ... data to create a PartVersion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PartVersion we want to update
     *   }
     * })
    **/
    upsert<T extends PartVersionUpsertArgs>(
      args: SelectSubset<T, PartVersionUpsertArgs>
    ): Prisma__PartVersionClient<PartVersionGetPayload<T>>

    /**
     * Count the number of PartVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartVersionCountArgs} args - Arguments to filter PartVersions to count.
     * @example
     * // Count the number of PartVersions
     * const count = await prisma.partVersion.count({
     *   where: {
     *     // ... the filter for the PartVersions we want to count
     *   }
     * })
    **/
    count<T extends PartVersionCountArgs>(
      args?: Subset<T, PartVersionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PartVersionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PartVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartVersionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PartVersionAggregateArgs>(args: Subset<T, PartVersionAggregateArgs>): Prisma.PrismaPromise<GetPartVersionAggregateType<T>>

    /**
     * Group by PartVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartVersionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PartVersionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PartVersionGroupByArgs['orderBy'] }
        : { orderBy?: PartVersionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PartVersionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPartVersionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for PartVersion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PartVersionClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    part<T extends PartArgs= {}>(args?: Subset<T, PartArgs>): Prisma__PartClient<PartGetPayload<T> | Null>;

    incomingInspectionSpec<T extends IncomingInspectionSpecArgs= {}>(args?: Subset<T, IncomingInspectionSpecArgs>): Prisma__IncomingInspectionSpecClient<IncomingInspectionSpecGetPayload<T> | Null>;

    receipts<T extends PartVersion$receiptsArgs= {}>(args?: Subset<T, PartVersion$receiptsArgs>): Prisma.PrismaPromise<Array<ReceiptGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * PartVersion base type for findUnique actions
   */
  export type PartVersionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the PartVersion
     */
    select?: PartVersionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartVersionInclude | null
    /**
     * Filter, which PartVersion to fetch.
     */
    where: PartVersionWhereUniqueInput
  }

  /**
   * PartVersion findUnique
   */
  export interface PartVersionFindUniqueArgs extends PartVersionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PartVersion findUniqueOrThrow
   */
  export type PartVersionFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the PartVersion
     */
    select?: PartVersionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartVersionInclude | null
    /**
     * Filter, which PartVersion to fetch.
     */
    where: PartVersionWhereUniqueInput
  }


  /**
   * PartVersion base type for findFirst actions
   */
  export type PartVersionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the PartVersion
     */
    select?: PartVersionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartVersionInclude | null
    /**
     * Filter, which PartVersion to fetch.
     */
    where?: PartVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PartVersions to fetch.
     */
    orderBy?: Enumerable<PartVersionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PartVersions.
     */
    cursor?: PartVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PartVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PartVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PartVersions.
     */
    distinct?: Enumerable<PartVersionScalarFieldEnum>
  }

  /**
   * PartVersion findFirst
   */
  export interface PartVersionFindFirstArgs extends PartVersionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PartVersion findFirstOrThrow
   */
  export type PartVersionFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the PartVersion
     */
    select?: PartVersionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartVersionInclude | null
    /**
     * Filter, which PartVersion to fetch.
     */
    where?: PartVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PartVersions to fetch.
     */
    orderBy?: Enumerable<PartVersionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PartVersions.
     */
    cursor?: PartVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PartVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PartVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PartVersions.
     */
    distinct?: Enumerable<PartVersionScalarFieldEnum>
  }


  /**
   * PartVersion findMany
   */
  export type PartVersionFindManyArgs = {
    /**
     * Select specific fields to fetch from the PartVersion
     */
    select?: PartVersionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartVersionInclude | null
    /**
     * Filter, which PartVersions to fetch.
     */
    where?: PartVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PartVersions to fetch.
     */
    orderBy?: Enumerable<PartVersionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PartVersions.
     */
    cursor?: PartVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PartVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PartVersions.
     */
    skip?: number
    distinct?: Enumerable<PartVersionScalarFieldEnum>
  }


  /**
   * PartVersion create
   */
  export type PartVersionCreateArgs = {
    /**
     * Select specific fields to fetch from the PartVersion
     */
    select?: PartVersionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartVersionInclude | null
    /**
     * The data needed to create a PartVersion.
     */
    data: XOR<PartVersionCreateInput, PartVersionUncheckedCreateInput>
  }


  /**
   * PartVersion createMany
   */
  export type PartVersionCreateManyArgs = {
    /**
     * The data used to create many PartVersions.
     */
    data: Enumerable<PartVersionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * PartVersion update
   */
  export type PartVersionUpdateArgs = {
    /**
     * Select specific fields to fetch from the PartVersion
     */
    select?: PartVersionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartVersionInclude | null
    /**
     * The data needed to update a PartVersion.
     */
    data: XOR<PartVersionUpdateInput, PartVersionUncheckedUpdateInput>
    /**
     * Choose, which PartVersion to update.
     */
    where: PartVersionWhereUniqueInput
  }


  /**
   * PartVersion updateMany
   */
  export type PartVersionUpdateManyArgs = {
    /**
     * The data used to update PartVersions.
     */
    data: XOR<PartVersionUpdateManyMutationInput, PartVersionUncheckedUpdateManyInput>
    /**
     * Filter which PartVersions to update
     */
    where?: PartVersionWhereInput
  }


  /**
   * PartVersion upsert
   */
  export type PartVersionUpsertArgs = {
    /**
     * Select specific fields to fetch from the PartVersion
     */
    select?: PartVersionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartVersionInclude | null
    /**
     * The filter to search for the PartVersion to update in case it exists.
     */
    where: PartVersionWhereUniqueInput
    /**
     * In case the PartVersion found by the `where` argument doesn't exist, create a new PartVersion with this data.
     */
    create: XOR<PartVersionCreateInput, PartVersionUncheckedCreateInput>
    /**
     * In case the PartVersion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PartVersionUpdateInput, PartVersionUncheckedUpdateInput>
  }


  /**
   * PartVersion delete
   */
  export type PartVersionDeleteArgs = {
    /**
     * Select specific fields to fetch from the PartVersion
     */
    select?: PartVersionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartVersionInclude | null
    /**
     * Filter which PartVersion to delete.
     */
    where: PartVersionWhereUniqueInput
  }


  /**
   * PartVersion deleteMany
   */
  export type PartVersionDeleteManyArgs = {
    /**
     * Filter which PartVersions to delete
     */
    where?: PartVersionWhereInput
  }


  /**
   * PartVersion.receipts
   */
  export type PartVersion$receiptsArgs = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReceiptInclude | null
    where?: ReceiptWhereInput
    orderBy?: Enumerable<ReceiptOrderByWithRelationInput>
    cursor?: ReceiptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ReceiptScalarFieldEnum>
  }


  /**
   * PartVersion without action
   */
  export type PartVersionArgs = {
    /**
     * Select specific fields to fetch from the PartVersion
     */
    select?: PartVersionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartVersionInclude | null
  }



  /**
   * Model IncomingInspectionSpec
   */


  export type AggregateIncomingInspectionSpec = {
    _count: IncomingInspectionSpecCountAggregateOutputType | null
    _avg: IncomingInspectionSpecAvgAggregateOutputType | null
    _sum: IncomingInspectionSpecSumAggregateOutputType | null
    _min: IncomingInspectionSpecMinAggregateOutputType | null
    _max: IncomingInspectionSpecMaxAggregateOutputType | null
  }

  export type IncomingInspectionSpecAvgAggregateOutputType = {
    id: number | null
    partVersionId: number | null
  }

  export type IncomingInspectionSpecSumAggregateOutputType = {
    id: number | null
    partVersionId: number | null
  }

  export type IncomingInspectionSpecMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    version: string | null
    attachment: string | null
    partVersionId: number | null
  }

  export type IncomingInspectionSpecMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    version: string | null
    attachment: string | null
    partVersionId: number | null
  }

  export type IncomingInspectionSpecCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    isDeleted: number
    version: number
    attachment: number
    partVersionId: number
    _all: number
  }


  export type IncomingInspectionSpecAvgAggregateInputType = {
    id?: true
    partVersionId?: true
  }

  export type IncomingInspectionSpecSumAggregateInputType = {
    id?: true
    partVersionId?: true
  }

  export type IncomingInspectionSpecMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    version?: true
    attachment?: true
    partVersionId?: true
  }

  export type IncomingInspectionSpecMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    version?: true
    attachment?: true
    partVersionId?: true
  }

  export type IncomingInspectionSpecCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    version?: true
    attachment?: true
    partVersionId?: true
    _all?: true
  }

  export type IncomingInspectionSpecAggregateArgs = {
    /**
     * Filter which IncomingInspectionSpec to aggregate.
     */
    where?: IncomingInspectionSpecWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncomingInspectionSpecs to fetch.
     */
    orderBy?: Enumerable<IncomingInspectionSpecOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IncomingInspectionSpecWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncomingInspectionSpecs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncomingInspectionSpecs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IncomingInspectionSpecs
    **/
    _count?: true | IncomingInspectionSpecCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IncomingInspectionSpecAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IncomingInspectionSpecSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IncomingInspectionSpecMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IncomingInspectionSpecMaxAggregateInputType
  }

  export type GetIncomingInspectionSpecAggregateType<T extends IncomingInspectionSpecAggregateArgs> = {
        [P in keyof T & keyof AggregateIncomingInspectionSpec]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIncomingInspectionSpec[P]>
      : GetScalarType<T[P], AggregateIncomingInspectionSpec[P]>
  }




  export type IncomingInspectionSpecGroupByArgs = {
    where?: IncomingInspectionSpecWhereInput
    orderBy?: Enumerable<IncomingInspectionSpecOrderByWithAggregationInput>
    by: IncomingInspectionSpecScalarFieldEnum[]
    having?: IncomingInspectionSpecScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IncomingInspectionSpecCountAggregateInputType | true
    _avg?: IncomingInspectionSpecAvgAggregateInputType
    _sum?: IncomingInspectionSpecSumAggregateInputType
    _min?: IncomingInspectionSpecMinAggregateInputType
    _max?: IncomingInspectionSpecMaxAggregateInputType
  }


  export type IncomingInspectionSpecGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    isDeleted: boolean
    version: string
    attachment: string
    partVersionId: number
    _count: IncomingInspectionSpecCountAggregateOutputType | null
    _avg: IncomingInspectionSpecAvgAggregateOutputType | null
    _sum: IncomingInspectionSpecSumAggregateOutputType | null
    _min: IncomingInspectionSpecMinAggregateOutputType | null
    _max: IncomingInspectionSpecMaxAggregateOutputType | null
  }

  type GetIncomingInspectionSpecGroupByPayload<T extends IncomingInspectionSpecGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<IncomingInspectionSpecGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IncomingInspectionSpecGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IncomingInspectionSpecGroupByOutputType[P]>
            : GetScalarType<T[P], IncomingInspectionSpecGroupByOutputType[P]>
        }
      >
    >


  export type IncomingInspectionSpecSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    version?: boolean
    attachment?: boolean
    partVersionId?: boolean
    incomingInspectionSpecItems?: boolean | IncomingInspectionSpec$incomingInspectionSpecItemsArgs
    incomingInspectionRecords?: boolean | IncomingInspectionSpec$incomingInspectionRecordsArgs
    partVersion?: boolean | PartVersionArgs
    _count?: boolean | IncomingInspectionSpecCountOutputTypeArgs
  }


  export type IncomingInspectionSpecInclude = {
    incomingInspectionSpecItems?: boolean | IncomingInspectionSpec$incomingInspectionSpecItemsArgs
    incomingInspectionRecords?: boolean | IncomingInspectionSpec$incomingInspectionRecordsArgs
    partVersion?: boolean | PartVersionArgs
    _count?: boolean | IncomingInspectionSpecCountOutputTypeArgs
  }

  export type IncomingInspectionSpecGetPayload<S extends boolean | null | undefined | IncomingInspectionSpecArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? IncomingInspectionSpec :
    S extends undefined ? never :
    S extends { include: any } & (IncomingInspectionSpecArgs | IncomingInspectionSpecFindManyArgs)
    ? IncomingInspectionSpec  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'incomingInspectionSpecItems' ? Array < IncomingInspectionSpecItemGetPayload<S['include'][P]>>  :
        P extends 'incomingInspectionRecords' ? Array < IncomingInspectionRecordGetPayload<S['include'][P]>>  :
        P extends 'partVersion' ? PartVersionGetPayload<S['include'][P]> :
        P extends '_count' ? IncomingInspectionSpecCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (IncomingInspectionSpecArgs | IncomingInspectionSpecFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'incomingInspectionSpecItems' ? Array < IncomingInspectionSpecItemGetPayload<S['select'][P]>>  :
        P extends 'incomingInspectionRecords' ? Array < IncomingInspectionRecordGetPayload<S['select'][P]>>  :
        P extends 'partVersion' ? PartVersionGetPayload<S['select'][P]> :
        P extends '_count' ? IncomingInspectionSpecCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof IncomingInspectionSpec ? IncomingInspectionSpec[P] : never
  } 
      : IncomingInspectionSpec


  type IncomingInspectionSpecCountArgs = 
    Omit<IncomingInspectionSpecFindManyArgs, 'select' | 'include'> & {
      select?: IncomingInspectionSpecCountAggregateInputType | true
    }

  export interface IncomingInspectionSpecDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one IncomingInspectionSpec that matches the filter.
     * @param {IncomingInspectionSpecFindUniqueArgs} args - Arguments to find a IncomingInspectionSpec
     * @example
     * // Get one IncomingInspectionSpec
     * const incomingInspectionSpec = await prisma.incomingInspectionSpec.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends IncomingInspectionSpecFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, IncomingInspectionSpecFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'IncomingInspectionSpec'> extends True ? Prisma__IncomingInspectionSpecClient<IncomingInspectionSpecGetPayload<T>> : Prisma__IncomingInspectionSpecClient<IncomingInspectionSpecGetPayload<T> | null, null>

    /**
     * Find one IncomingInspectionSpec that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {IncomingInspectionSpecFindUniqueOrThrowArgs} args - Arguments to find a IncomingInspectionSpec
     * @example
     * // Get one IncomingInspectionSpec
     * const incomingInspectionSpec = await prisma.incomingInspectionSpec.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends IncomingInspectionSpecFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, IncomingInspectionSpecFindUniqueOrThrowArgs>
    ): Prisma__IncomingInspectionSpecClient<IncomingInspectionSpecGetPayload<T>>

    /**
     * Find the first IncomingInspectionSpec that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomingInspectionSpecFindFirstArgs} args - Arguments to find a IncomingInspectionSpec
     * @example
     * // Get one IncomingInspectionSpec
     * const incomingInspectionSpec = await prisma.incomingInspectionSpec.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends IncomingInspectionSpecFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, IncomingInspectionSpecFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'IncomingInspectionSpec'> extends True ? Prisma__IncomingInspectionSpecClient<IncomingInspectionSpecGetPayload<T>> : Prisma__IncomingInspectionSpecClient<IncomingInspectionSpecGetPayload<T> | null, null>

    /**
     * Find the first IncomingInspectionSpec that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomingInspectionSpecFindFirstOrThrowArgs} args - Arguments to find a IncomingInspectionSpec
     * @example
     * // Get one IncomingInspectionSpec
     * const incomingInspectionSpec = await prisma.incomingInspectionSpec.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends IncomingInspectionSpecFindFirstOrThrowArgs>(
      args?: SelectSubset<T, IncomingInspectionSpecFindFirstOrThrowArgs>
    ): Prisma__IncomingInspectionSpecClient<IncomingInspectionSpecGetPayload<T>>

    /**
     * Find zero or more IncomingInspectionSpecs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomingInspectionSpecFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IncomingInspectionSpecs
     * const incomingInspectionSpecs = await prisma.incomingInspectionSpec.findMany()
     * 
     * // Get first 10 IncomingInspectionSpecs
     * const incomingInspectionSpecs = await prisma.incomingInspectionSpec.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const incomingInspectionSpecWithIdOnly = await prisma.incomingInspectionSpec.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends IncomingInspectionSpecFindManyArgs>(
      args?: SelectSubset<T, IncomingInspectionSpecFindManyArgs>
    ): Prisma.PrismaPromise<Array<IncomingInspectionSpecGetPayload<T>>>

    /**
     * Create a IncomingInspectionSpec.
     * @param {IncomingInspectionSpecCreateArgs} args - Arguments to create a IncomingInspectionSpec.
     * @example
     * // Create one IncomingInspectionSpec
     * const IncomingInspectionSpec = await prisma.incomingInspectionSpec.create({
     *   data: {
     *     // ... data to create a IncomingInspectionSpec
     *   }
     * })
     * 
    **/
    create<T extends IncomingInspectionSpecCreateArgs>(
      args: SelectSubset<T, IncomingInspectionSpecCreateArgs>
    ): Prisma__IncomingInspectionSpecClient<IncomingInspectionSpecGetPayload<T>>

    /**
     * Create many IncomingInspectionSpecs.
     *     @param {IncomingInspectionSpecCreateManyArgs} args - Arguments to create many IncomingInspectionSpecs.
     *     @example
     *     // Create many IncomingInspectionSpecs
     *     const incomingInspectionSpec = await prisma.incomingInspectionSpec.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends IncomingInspectionSpecCreateManyArgs>(
      args?: SelectSubset<T, IncomingInspectionSpecCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a IncomingInspectionSpec.
     * @param {IncomingInspectionSpecDeleteArgs} args - Arguments to delete one IncomingInspectionSpec.
     * @example
     * // Delete one IncomingInspectionSpec
     * const IncomingInspectionSpec = await prisma.incomingInspectionSpec.delete({
     *   where: {
     *     // ... filter to delete one IncomingInspectionSpec
     *   }
     * })
     * 
    **/
    delete<T extends IncomingInspectionSpecDeleteArgs>(
      args: SelectSubset<T, IncomingInspectionSpecDeleteArgs>
    ): Prisma__IncomingInspectionSpecClient<IncomingInspectionSpecGetPayload<T>>

    /**
     * Update one IncomingInspectionSpec.
     * @param {IncomingInspectionSpecUpdateArgs} args - Arguments to update one IncomingInspectionSpec.
     * @example
     * // Update one IncomingInspectionSpec
     * const incomingInspectionSpec = await prisma.incomingInspectionSpec.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends IncomingInspectionSpecUpdateArgs>(
      args: SelectSubset<T, IncomingInspectionSpecUpdateArgs>
    ): Prisma__IncomingInspectionSpecClient<IncomingInspectionSpecGetPayload<T>>

    /**
     * Delete zero or more IncomingInspectionSpecs.
     * @param {IncomingInspectionSpecDeleteManyArgs} args - Arguments to filter IncomingInspectionSpecs to delete.
     * @example
     * // Delete a few IncomingInspectionSpecs
     * const { count } = await prisma.incomingInspectionSpec.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends IncomingInspectionSpecDeleteManyArgs>(
      args?: SelectSubset<T, IncomingInspectionSpecDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IncomingInspectionSpecs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomingInspectionSpecUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IncomingInspectionSpecs
     * const incomingInspectionSpec = await prisma.incomingInspectionSpec.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends IncomingInspectionSpecUpdateManyArgs>(
      args: SelectSubset<T, IncomingInspectionSpecUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one IncomingInspectionSpec.
     * @param {IncomingInspectionSpecUpsertArgs} args - Arguments to update or create a IncomingInspectionSpec.
     * @example
     * // Update or create a IncomingInspectionSpec
     * const incomingInspectionSpec = await prisma.incomingInspectionSpec.upsert({
     *   create: {
     *     // ... data to create a IncomingInspectionSpec
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IncomingInspectionSpec we want to update
     *   }
     * })
    **/
    upsert<T extends IncomingInspectionSpecUpsertArgs>(
      args: SelectSubset<T, IncomingInspectionSpecUpsertArgs>
    ): Prisma__IncomingInspectionSpecClient<IncomingInspectionSpecGetPayload<T>>

    /**
     * Count the number of IncomingInspectionSpecs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomingInspectionSpecCountArgs} args - Arguments to filter IncomingInspectionSpecs to count.
     * @example
     * // Count the number of IncomingInspectionSpecs
     * const count = await prisma.incomingInspectionSpec.count({
     *   where: {
     *     // ... the filter for the IncomingInspectionSpecs we want to count
     *   }
     * })
    **/
    count<T extends IncomingInspectionSpecCountArgs>(
      args?: Subset<T, IncomingInspectionSpecCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IncomingInspectionSpecCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IncomingInspectionSpec.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomingInspectionSpecAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IncomingInspectionSpecAggregateArgs>(args: Subset<T, IncomingInspectionSpecAggregateArgs>): Prisma.PrismaPromise<GetIncomingInspectionSpecAggregateType<T>>

    /**
     * Group by IncomingInspectionSpec.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomingInspectionSpecGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IncomingInspectionSpecGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IncomingInspectionSpecGroupByArgs['orderBy'] }
        : { orderBy?: IncomingInspectionSpecGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IncomingInspectionSpecGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIncomingInspectionSpecGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for IncomingInspectionSpec.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__IncomingInspectionSpecClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    incomingInspectionSpecItems<T extends IncomingInspectionSpec$incomingInspectionSpecItemsArgs= {}>(args?: Subset<T, IncomingInspectionSpec$incomingInspectionSpecItemsArgs>): Prisma.PrismaPromise<Array<IncomingInspectionSpecItemGetPayload<T>>| Null>;

    incomingInspectionRecords<T extends IncomingInspectionSpec$incomingInspectionRecordsArgs= {}>(args?: Subset<T, IncomingInspectionSpec$incomingInspectionRecordsArgs>): Prisma.PrismaPromise<Array<IncomingInspectionRecordGetPayload<T>>| Null>;

    partVersion<T extends PartVersionArgs= {}>(args?: Subset<T, PartVersionArgs>): Prisma__PartVersionClient<PartVersionGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * IncomingInspectionSpec base type for findUnique actions
   */
  export type IncomingInspectionSpecFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the IncomingInspectionSpec
     */
    select?: IncomingInspectionSpecSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IncomingInspectionSpecInclude | null
    /**
     * Filter, which IncomingInspectionSpec to fetch.
     */
    where: IncomingInspectionSpecWhereUniqueInput
  }

  /**
   * IncomingInspectionSpec findUnique
   */
  export interface IncomingInspectionSpecFindUniqueArgs extends IncomingInspectionSpecFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * IncomingInspectionSpec findUniqueOrThrow
   */
  export type IncomingInspectionSpecFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the IncomingInspectionSpec
     */
    select?: IncomingInspectionSpecSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IncomingInspectionSpecInclude | null
    /**
     * Filter, which IncomingInspectionSpec to fetch.
     */
    where: IncomingInspectionSpecWhereUniqueInput
  }


  /**
   * IncomingInspectionSpec base type for findFirst actions
   */
  export type IncomingInspectionSpecFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the IncomingInspectionSpec
     */
    select?: IncomingInspectionSpecSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IncomingInspectionSpecInclude | null
    /**
     * Filter, which IncomingInspectionSpec to fetch.
     */
    where?: IncomingInspectionSpecWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncomingInspectionSpecs to fetch.
     */
    orderBy?: Enumerable<IncomingInspectionSpecOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IncomingInspectionSpecs.
     */
    cursor?: IncomingInspectionSpecWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncomingInspectionSpecs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncomingInspectionSpecs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IncomingInspectionSpecs.
     */
    distinct?: Enumerable<IncomingInspectionSpecScalarFieldEnum>
  }

  /**
   * IncomingInspectionSpec findFirst
   */
  export interface IncomingInspectionSpecFindFirstArgs extends IncomingInspectionSpecFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * IncomingInspectionSpec findFirstOrThrow
   */
  export type IncomingInspectionSpecFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the IncomingInspectionSpec
     */
    select?: IncomingInspectionSpecSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IncomingInspectionSpecInclude | null
    /**
     * Filter, which IncomingInspectionSpec to fetch.
     */
    where?: IncomingInspectionSpecWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncomingInspectionSpecs to fetch.
     */
    orderBy?: Enumerable<IncomingInspectionSpecOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IncomingInspectionSpecs.
     */
    cursor?: IncomingInspectionSpecWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncomingInspectionSpecs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncomingInspectionSpecs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IncomingInspectionSpecs.
     */
    distinct?: Enumerable<IncomingInspectionSpecScalarFieldEnum>
  }


  /**
   * IncomingInspectionSpec findMany
   */
  export type IncomingInspectionSpecFindManyArgs = {
    /**
     * Select specific fields to fetch from the IncomingInspectionSpec
     */
    select?: IncomingInspectionSpecSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IncomingInspectionSpecInclude | null
    /**
     * Filter, which IncomingInspectionSpecs to fetch.
     */
    where?: IncomingInspectionSpecWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncomingInspectionSpecs to fetch.
     */
    orderBy?: Enumerable<IncomingInspectionSpecOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IncomingInspectionSpecs.
     */
    cursor?: IncomingInspectionSpecWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncomingInspectionSpecs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncomingInspectionSpecs.
     */
    skip?: number
    distinct?: Enumerable<IncomingInspectionSpecScalarFieldEnum>
  }


  /**
   * IncomingInspectionSpec create
   */
  export type IncomingInspectionSpecCreateArgs = {
    /**
     * Select specific fields to fetch from the IncomingInspectionSpec
     */
    select?: IncomingInspectionSpecSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IncomingInspectionSpecInclude | null
    /**
     * The data needed to create a IncomingInspectionSpec.
     */
    data: XOR<IncomingInspectionSpecCreateInput, IncomingInspectionSpecUncheckedCreateInput>
  }


  /**
   * IncomingInspectionSpec createMany
   */
  export type IncomingInspectionSpecCreateManyArgs = {
    /**
     * The data used to create many IncomingInspectionSpecs.
     */
    data: Enumerable<IncomingInspectionSpecCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * IncomingInspectionSpec update
   */
  export type IncomingInspectionSpecUpdateArgs = {
    /**
     * Select specific fields to fetch from the IncomingInspectionSpec
     */
    select?: IncomingInspectionSpecSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IncomingInspectionSpecInclude | null
    /**
     * The data needed to update a IncomingInspectionSpec.
     */
    data: XOR<IncomingInspectionSpecUpdateInput, IncomingInspectionSpecUncheckedUpdateInput>
    /**
     * Choose, which IncomingInspectionSpec to update.
     */
    where: IncomingInspectionSpecWhereUniqueInput
  }


  /**
   * IncomingInspectionSpec updateMany
   */
  export type IncomingInspectionSpecUpdateManyArgs = {
    /**
     * The data used to update IncomingInspectionSpecs.
     */
    data: XOR<IncomingInspectionSpecUpdateManyMutationInput, IncomingInspectionSpecUncheckedUpdateManyInput>
    /**
     * Filter which IncomingInspectionSpecs to update
     */
    where?: IncomingInspectionSpecWhereInput
  }


  /**
   * IncomingInspectionSpec upsert
   */
  export type IncomingInspectionSpecUpsertArgs = {
    /**
     * Select specific fields to fetch from the IncomingInspectionSpec
     */
    select?: IncomingInspectionSpecSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IncomingInspectionSpecInclude | null
    /**
     * The filter to search for the IncomingInspectionSpec to update in case it exists.
     */
    where: IncomingInspectionSpecWhereUniqueInput
    /**
     * In case the IncomingInspectionSpec found by the `where` argument doesn't exist, create a new IncomingInspectionSpec with this data.
     */
    create: XOR<IncomingInspectionSpecCreateInput, IncomingInspectionSpecUncheckedCreateInput>
    /**
     * In case the IncomingInspectionSpec was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IncomingInspectionSpecUpdateInput, IncomingInspectionSpecUncheckedUpdateInput>
  }


  /**
   * IncomingInspectionSpec delete
   */
  export type IncomingInspectionSpecDeleteArgs = {
    /**
     * Select specific fields to fetch from the IncomingInspectionSpec
     */
    select?: IncomingInspectionSpecSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IncomingInspectionSpecInclude | null
    /**
     * Filter which IncomingInspectionSpec to delete.
     */
    where: IncomingInspectionSpecWhereUniqueInput
  }


  /**
   * IncomingInspectionSpec deleteMany
   */
  export type IncomingInspectionSpecDeleteManyArgs = {
    /**
     * Filter which IncomingInspectionSpecs to delete
     */
    where?: IncomingInspectionSpecWhereInput
  }


  /**
   * IncomingInspectionSpec.incomingInspectionSpecItems
   */
  export type IncomingInspectionSpec$incomingInspectionSpecItemsArgs = {
    /**
     * Select specific fields to fetch from the IncomingInspectionSpecItem
     */
    select?: IncomingInspectionSpecItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IncomingInspectionSpecItemInclude | null
    where?: IncomingInspectionSpecItemWhereInput
    orderBy?: Enumerable<IncomingInspectionSpecItemOrderByWithRelationInput>
    cursor?: IncomingInspectionSpecItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<IncomingInspectionSpecItemScalarFieldEnum>
  }


  /**
   * IncomingInspectionSpec.incomingInspectionRecords
   */
  export type IncomingInspectionSpec$incomingInspectionRecordsArgs = {
    /**
     * Select specific fields to fetch from the IncomingInspectionRecord
     */
    select?: IncomingInspectionRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IncomingInspectionRecordInclude | null
    where?: IncomingInspectionRecordWhereInput
    orderBy?: Enumerable<IncomingInspectionRecordOrderByWithRelationInput>
    cursor?: IncomingInspectionRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<IncomingInspectionRecordScalarFieldEnum>
  }


  /**
   * IncomingInspectionSpec without action
   */
  export type IncomingInspectionSpecArgs = {
    /**
     * Select specific fields to fetch from the IncomingInspectionSpec
     */
    select?: IncomingInspectionSpecSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IncomingInspectionSpecInclude | null
  }



  /**
   * Model IncomingInspectionSpecItem
   */


  export type AggregateIncomingInspectionSpecItem = {
    _count: IncomingInspectionSpecItemCountAggregateOutputType | null
    _avg: IncomingInspectionSpecItemAvgAggregateOutputType | null
    _sum: IncomingInspectionSpecItemSumAggregateOutputType | null
    _min: IncomingInspectionSpecItemMinAggregateOutputType | null
    _max: IncomingInspectionSpecItemMaxAggregateOutputType | null
  }

  export type IncomingInspectionSpecItemAvgAggregateOutputType = {
    id: number | null
    no: number | null
    incomingInspectionSpecId: number | null
  }

  export type IncomingInspectionSpecItemSumAggregateOutputType = {
    id: number | null
    no: number | null
    incomingInspectionSpecId: number | null
  }

  export type IncomingInspectionSpecItemMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    no: number | null
    name: string | null
    spec: string | null
    incomingInspectionSpecId: number | null
  }

  export type IncomingInspectionSpecItemMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    no: number | null
    name: string | null
    spec: string | null
    incomingInspectionSpecId: number | null
  }

  export type IncomingInspectionSpecItemCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    isDeleted: number
    no: number
    name: number
    spec: number
    incomingInspectionSpecId: number
    _all: number
  }


  export type IncomingInspectionSpecItemAvgAggregateInputType = {
    id?: true
    no?: true
    incomingInspectionSpecId?: true
  }

  export type IncomingInspectionSpecItemSumAggregateInputType = {
    id?: true
    no?: true
    incomingInspectionSpecId?: true
  }

  export type IncomingInspectionSpecItemMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    no?: true
    name?: true
    spec?: true
    incomingInspectionSpecId?: true
  }

  export type IncomingInspectionSpecItemMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    no?: true
    name?: true
    spec?: true
    incomingInspectionSpecId?: true
  }

  export type IncomingInspectionSpecItemCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    no?: true
    name?: true
    spec?: true
    incomingInspectionSpecId?: true
    _all?: true
  }

  export type IncomingInspectionSpecItemAggregateArgs = {
    /**
     * Filter which IncomingInspectionSpecItem to aggregate.
     */
    where?: IncomingInspectionSpecItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncomingInspectionSpecItems to fetch.
     */
    orderBy?: Enumerable<IncomingInspectionSpecItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IncomingInspectionSpecItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncomingInspectionSpecItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncomingInspectionSpecItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IncomingInspectionSpecItems
    **/
    _count?: true | IncomingInspectionSpecItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IncomingInspectionSpecItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IncomingInspectionSpecItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IncomingInspectionSpecItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IncomingInspectionSpecItemMaxAggregateInputType
  }

  export type GetIncomingInspectionSpecItemAggregateType<T extends IncomingInspectionSpecItemAggregateArgs> = {
        [P in keyof T & keyof AggregateIncomingInspectionSpecItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIncomingInspectionSpecItem[P]>
      : GetScalarType<T[P], AggregateIncomingInspectionSpecItem[P]>
  }




  export type IncomingInspectionSpecItemGroupByArgs = {
    where?: IncomingInspectionSpecItemWhereInput
    orderBy?: Enumerable<IncomingInspectionSpecItemOrderByWithAggregationInput>
    by: IncomingInspectionSpecItemScalarFieldEnum[]
    having?: IncomingInspectionSpecItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IncomingInspectionSpecItemCountAggregateInputType | true
    _avg?: IncomingInspectionSpecItemAvgAggregateInputType
    _sum?: IncomingInspectionSpecItemSumAggregateInputType
    _min?: IncomingInspectionSpecItemMinAggregateInputType
    _max?: IncomingInspectionSpecItemMaxAggregateInputType
  }


  export type IncomingInspectionSpecItemGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    isDeleted: boolean
    no: number
    name: string
    spec: string
    incomingInspectionSpecId: number
    _count: IncomingInspectionSpecItemCountAggregateOutputType | null
    _avg: IncomingInspectionSpecItemAvgAggregateOutputType | null
    _sum: IncomingInspectionSpecItemSumAggregateOutputType | null
    _min: IncomingInspectionSpecItemMinAggregateOutputType | null
    _max: IncomingInspectionSpecItemMaxAggregateOutputType | null
  }

  type GetIncomingInspectionSpecItemGroupByPayload<T extends IncomingInspectionSpecItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<IncomingInspectionSpecItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IncomingInspectionSpecItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IncomingInspectionSpecItemGroupByOutputType[P]>
            : GetScalarType<T[P], IncomingInspectionSpecItemGroupByOutputType[P]>
        }
      >
    >


  export type IncomingInspectionSpecItemSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    no?: boolean
    name?: boolean
    spec?: boolean
    incomingInspectionSpecId?: boolean
    incomingInspectionSpec?: boolean | IncomingInspectionSpecArgs
    incomingInspectionRecordItem?: boolean | IncomingInspectionSpecItem$incomingInspectionRecordItemArgs
    _count?: boolean | IncomingInspectionSpecItemCountOutputTypeArgs
  }


  export type IncomingInspectionSpecItemInclude = {
    incomingInspectionSpec?: boolean | IncomingInspectionSpecArgs
    incomingInspectionRecordItem?: boolean | IncomingInspectionSpecItem$incomingInspectionRecordItemArgs
    _count?: boolean | IncomingInspectionSpecItemCountOutputTypeArgs
  }

  export type IncomingInspectionSpecItemGetPayload<S extends boolean | null | undefined | IncomingInspectionSpecItemArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? IncomingInspectionSpecItem :
    S extends undefined ? never :
    S extends { include: any } & (IncomingInspectionSpecItemArgs | IncomingInspectionSpecItemFindManyArgs)
    ? IncomingInspectionSpecItem  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'incomingInspectionSpec' ? IncomingInspectionSpecGetPayload<S['include'][P]> :
        P extends 'incomingInspectionRecordItem' ? Array < IncomingInspectionRecordItemGetPayload<S['include'][P]>>  :
        P extends '_count' ? IncomingInspectionSpecItemCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (IncomingInspectionSpecItemArgs | IncomingInspectionSpecItemFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'incomingInspectionSpec' ? IncomingInspectionSpecGetPayload<S['select'][P]> :
        P extends 'incomingInspectionRecordItem' ? Array < IncomingInspectionRecordItemGetPayload<S['select'][P]>>  :
        P extends '_count' ? IncomingInspectionSpecItemCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof IncomingInspectionSpecItem ? IncomingInspectionSpecItem[P] : never
  } 
      : IncomingInspectionSpecItem


  type IncomingInspectionSpecItemCountArgs = 
    Omit<IncomingInspectionSpecItemFindManyArgs, 'select' | 'include'> & {
      select?: IncomingInspectionSpecItemCountAggregateInputType | true
    }

  export interface IncomingInspectionSpecItemDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one IncomingInspectionSpecItem that matches the filter.
     * @param {IncomingInspectionSpecItemFindUniqueArgs} args - Arguments to find a IncomingInspectionSpecItem
     * @example
     * // Get one IncomingInspectionSpecItem
     * const incomingInspectionSpecItem = await prisma.incomingInspectionSpecItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends IncomingInspectionSpecItemFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, IncomingInspectionSpecItemFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'IncomingInspectionSpecItem'> extends True ? Prisma__IncomingInspectionSpecItemClient<IncomingInspectionSpecItemGetPayload<T>> : Prisma__IncomingInspectionSpecItemClient<IncomingInspectionSpecItemGetPayload<T> | null, null>

    /**
     * Find one IncomingInspectionSpecItem that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {IncomingInspectionSpecItemFindUniqueOrThrowArgs} args - Arguments to find a IncomingInspectionSpecItem
     * @example
     * // Get one IncomingInspectionSpecItem
     * const incomingInspectionSpecItem = await prisma.incomingInspectionSpecItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends IncomingInspectionSpecItemFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, IncomingInspectionSpecItemFindUniqueOrThrowArgs>
    ): Prisma__IncomingInspectionSpecItemClient<IncomingInspectionSpecItemGetPayload<T>>

    /**
     * Find the first IncomingInspectionSpecItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomingInspectionSpecItemFindFirstArgs} args - Arguments to find a IncomingInspectionSpecItem
     * @example
     * // Get one IncomingInspectionSpecItem
     * const incomingInspectionSpecItem = await prisma.incomingInspectionSpecItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends IncomingInspectionSpecItemFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, IncomingInspectionSpecItemFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'IncomingInspectionSpecItem'> extends True ? Prisma__IncomingInspectionSpecItemClient<IncomingInspectionSpecItemGetPayload<T>> : Prisma__IncomingInspectionSpecItemClient<IncomingInspectionSpecItemGetPayload<T> | null, null>

    /**
     * Find the first IncomingInspectionSpecItem that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomingInspectionSpecItemFindFirstOrThrowArgs} args - Arguments to find a IncomingInspectionSpecItem
     * @example
     * // Get one IncomingInspectionSpecItem
     * const incomingInspectionSpecItem = await prisma.incomingInspectionSpecItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends IncomingInspectionSpecItemFindFirstOrThrowArgs>(
      args?: SelectSubset<T, IncomingInspectionSpecItemFindFirstOrThrowArgs>
    ): Prisma__IncomingInspectionSpecItemClient<IncomingInspectionSpecItemGetPayload<T>>

    /**
     * Find zero or more IncomingInspectionSpecItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomingInspectionSpecItemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IncomingInspectionSpecItems
     * const incomingInspectionSpecItems = await prisma.incomingInspectionSpecItem.findMany()
     * 
     * // Get first 10 IncomingInspectionSpecItems
     * const incomingInspectionSpecItems = await prisma.incomingInspectionSpecItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const incomingInspectionSpecItemWithIdOnly = await prisma.incomingInspectionSpecItem.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends IncomingInspectionSpecItemFindManyArgs>(
      args?: SelectSubset<T, IncomingInspectionSpecItemFindManyArgs>
    ): Prisma.PrismaPromise<Array<IncomingInspectionSpecItemGetPayload<T>>>

    /**
     * Create a IncomingInspectionSpecItem.
     * @param {IncomingInspectionSpecItemCreateArgs} args - Arguments to create a IncomingInspectionSpecItem.
     * @example
     * // Create one IncomingInspectionSpecItem
     * const IncomingInspectionSpecItem = await prisma.incomingInspectionSpecItem.create({
     *   data: {
     *     // ... data to create a IncomingInspectionSpecItem
     *   }
     * })
     * 
    **/
    create<T extends IncomingInspectionSpecItemCreateArgs>(
      args: SelectSubset<T, IncomingInspectionSpecItemCreateArgs>
    ): Prisma__IncomingInspectionSpecItemClient<IncomingInspectionSpecItemGetPayload<T>>

    /**
     * Create many IncomingInspectionSpecItems.
     *     @param {IncomingInspectionSpecItemCreateManyArgs} args - Arguments to create many IncomingInspectionSpecItems.
     *     @example
     *     // Create many IncomingInspectionSpecItems
     *     const incomingInspectionSpecItem = await prisma.incomingInspectionSpecItem.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends IncomingInspectionSpecItemCreateManyArgs>(
      args?: SelectSubset<T, IncomingInspectionSpecItemCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a IncomingInspectionSpecItem.
     * @param {IncomingInspectionSpecItemDeleteArgs} args - Arguments to delete one IncomingInspectionSpecItem.
     * @example
     * // Delete one IncomingInspectionSpecItem
     * const IncomingInspectionSpecItem = await prisma.incomingInspectionSpecItem.delete({
     *   where: {
     *     // ... filter to delete one IncomingInspectionSpecItem
     *   }
     * })
     * 
    **/
    delete<T extends IncomingInspectionSpecItemDeleteArgs>(
      args: SelectSubset<T, IncomingInspectionSpecItemDeleteArgs>
    ): Prisma__IncomingInspectionSpecItemClient<IncomingInspectionSpecItemGetPayload<T>>

    /**
     * Update one IncomingInspectionSpecItem.
     * @param {IncomingInspectionSpecItemUpdateArgs} args - Arguments to update one IncomingInspectionSpecItem.
     * @example
     * // Update one IncomingInspectionSpecItem
     * const incomingInspectionSpecItem = await prisma.incomingInspectionSpecItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends IncomingInspectionSpecItemUpdateArgs>(
      args: SelectSubset<T, IncomingInspectionSpecItemUpdateArgs>
    ): Prisma__IncomingInspectionSpecItemClient<IncomingInspectionSpecItemGetPayload<T>>

    /**
     * Delete zero or more IncomingInspectionSpecItems.
     * @param {IncomingInspectionSpecItemDeleteManyArgs} args - Arguments to filter IncomingInspectionSpecItems to delete.
     * @example
     * // Delete a few IncomingInspectionSpecItems
     * const { count } = await prisma.incomingInspectionSpecItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends IncomingInspectionSpecItemDeleteManyArgs>(
      args?: SelectSubset<T, IncomingInspectionSpecItemDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IncomingInspectionSpecItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomingInspectionSpecItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IncomingInspectionSpecItems
     * const incomingInspectionSpecItem = await prisma.incomingInspectionSpecItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends IncomingInspectionSpecItemUpdateManyArgs>(
      args: SelectSubset<T, IncomingInspectionSpecItemUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one IncomingInspectionSpecItem.
     * @param {IncomingInspectionSpecItemUpsertArgs} args - Arguments to update or create a IncomingInspectionSpecItem.
     * @example
     * // Update or create a IncomingInspectionSpecItem
     * const incomingInspectionSpecItem = await prisma.incomingInspectionSpecItem.upsert({
     *   create: {
     *     // ... data to create a IncomingInspectionSpecItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IncomingInspectionSpecItem we want to update
     *   }
     * })
    **/
    upsert<T extends IncomingInspectionSpecItemUpsertArgs>(
      args: SelectSubset<T, IncomingInspectionSpecItemUpsertArgs>
    ): Prisma__IncomingInspectionSpecItemClient<IncomingInspectionSpecItemGetPayload<T>>

    /**
     * Count the number of IncomingInspectionSpecItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomingInspectionSpecItemCountArgs} args - Arguments to filter IncomingInspectionSpecItems to count.
     * @example
     * // Count the number of IncomingInspectionSpecItems
     * const count = await prisma.incomingInspectionSpecItem.count({
     *   where: {
     *     // ... the filter for the IncomingInspectionSpecItems we want to count
     *   }
     * })
    **/
    count<T extends IncomingInspectionSpecItemCountArgs>(
      args?: Subset<T, IncomingInspectionSpecItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IncomingInspectionSpecItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IncomingInspectionSpecItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomingInspectionSpecItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IncomingInspectionSpecItemAggregateArgs>(args: Subset<T, IncomingInspectionSpecItemAggregateArgs>): Prisma.PrismaPromise<GetIncomingInspectionSpecItemAggregateType<T>>

    /**
     * Group by IncomingInspectionSpecItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomingInspectionSpecItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IncomingInspectionSpecItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IncomingInspectionSpecItemGroupByArgs['orderBy'] }
        : { orderBy?: IncomingInspectionSpecItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IncomingInspectionSpecItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIncomingInspectionSpecItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for IncomingInspectionSpecItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__IncomingInspectionSpecItemClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    incomingInspectionSpec<T extends IncomingInspectionSpecArgs= {}>(args?: Subset<T, IncomingInspectionSpecArgs>): Prisma__IncomingInspectionSpecClient<IncomingInspectionSpecGetPayload<T> | Null>;

    incomingInspectionRecordItem<T extends IncomingInspectionSpecItem$incomingInspectionRecordItemArgs= {}>(args?: Subset<T, IncomingInspectionSpecItem$incomingInspectionRecordItemArgs>): Prisma.PrismaPromise<Array<IncomingInspectionRecordItemGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * IncomingInspectionSpecItem base type for findUnique actions
   */
  export type IncomingInspectionSpecItemFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the IncomingInspectionSpecItem
     */
    select?: IncomingInspectionSpecItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IncomingInspectionSpecItemInclude | null
    /**
     * Filter, which IncomingInspectionSpecItem to fetch.
     */
    where: IncomingInspectionSpecItemWhereUniqueInput
  }

  /**
   * IncomingInspectionSpecItem findUnique
   */
  export interface IncomingInspectionSpecItemFindUniqueArgs extends IncomingInspectionSpecItemFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * IncomingInspectionSpecItem findUniqueOrThrow
   */
  export type IncomingInspectionSpecItemFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the IncomingInspectionSpecItem
     */
    select?: IncomingInspectionSpecItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IncomingInspectionSpecItemInclude | null
    /**
     * Filter, which IncomingInspectionSpecItem to fetch.
     */
    where: IncomingInspectionSpecItemWhereUniqueInput
  }


  /**
   * IncomingInspectionSpecItem base type for findFirst actions
   */
  export type IncomingInspectionSpecItemFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the IncomingInspectionSpecItem
     */
    select?: IncomingInspectionSpecItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IncomingInspectionSpecItemInclude | null
    /**
     * Filter, which IncomingInspectionSpecItem to fetch.
     */
    where?: IncomingInspectionSpecItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncomingInspectionSpecItems to fetch.
     */
    orderBy?: Enumerable<IncomingInspectionSpecItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IncomingInspectionSpecItems.
     */
    cursor?: IncomingInspectionSpecItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncomingInspectionSpecItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncomingInspectionSpecItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IncomingInspectionSpecItems.
     */
    distinct?: Enumerable<IncomingInspectionSpecItemScalarFieldEnum>
  }

  /**
   * IncomingInspectionSpecItem findFirst
   */
  export interface IncomingInspectionSpecItemFindFirstArgs extends IncomingInspectionSpecItemFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * IncomingInspectionSpecItem findFirstOrThrow
   */
  export type IncomingInspectionSpecItemFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the IncomingInspectionSpecItem
     */
    select?: IncomingInspectionSpecItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IncomingInspectionSpecItemInclude | null
    /**
     * Filter, which IncomingInspectionSpecItem to fetch.
     */
    where?: IncomingInspectionSpecItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncomingInspectionSpecItems to fetch.
     */
    orderBy?: Enumerable<IncomingInspectionSpecItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IncomingInspectionSpecItems.
     */
    cursor?: IncomingInspectionSpecItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncomingInspectionSpecItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncomingInspectionSpecItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IncomingInspectionSpecItems.
     */
    distinct?: Enumerable<IncomingInspectionSpecItemScalarFieldEnum>
  }


  /**
   * IncomingInspectionSpecItem findMany
   */
  export type IncomingInspectionSpecItemFindManyArgs = {
    /**
     * Select specific fields to fetch from the IncomingInspectionSpecItem
     */
    select?: IncomingInspectionSpecItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IncomingInspectionSpecItemInclude | null
    /**
     * Filter, which IncomingInspectionSpecItems to fetch.
     */
    where?: IncomingInspectionSpecItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncomingInspectionSpecItems to fetch.
     */
    orderBy?: Enumerable<IncomingInspectionSpecItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IncomingInspectionSpecItems.
     */
    cursor?: IncomingInspectionSpecItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncomingInspectionSpecItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncomingInspectionSpecItems.
     */
    skip?: number
    distinct?: Enumerable<IncomingInspectionSpecItemScalarFieldEnum>
  }


  /**
   * IncomingInspectionSpecItem create
   */
  export type IncomingInspectionSpecItemCreateArgs = {
    /**
     * Select specific fields to fetch from the IncomingInspectionSpecItem
     */
    select?: IncomingInspectionSpecItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IncomingInspectionSpecItemInclude | null
    /**
     * The data needed to create a IncomingInspectionSpecItem.
     */
    data: XOR<IncomingInspectionSpecItemCreateInput, IncomingInspectionSpecItemUncheckedCreateInput>
  }


  /**
   * IncomingInspectionSpecItem createMany
   */
  export type IncomingInspectionSpecItemCreateManyArgs = {
    /**
     * The data used to create many IncomingInspectionSpecItems.
     */
    data: Enumerable<IncomingInspectionSpecItemCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * IncomingInspectionSpecItem update
   */
  export type IncomingInspectionSpecItemUpdateArgs = {
    /**
     * Select specific fields to fetch from the IncomingInspectionSpecItem
     */
    select?: IncomingInspectionSpecItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IncomingInspectionSpecItemInclude | null
    /**
     * The data needed to update a IncomingInspectionSpecItem.
     */
    data: XOR<IncomingInspectionSpecItemUpdateInput, IncomingInspectionSpecItemUncheckedUpdateInput>
    /**
     * Choose, which IncomingInspectionSpecItem to update.
     */
    where: IncomingInspectionSpecItemWhereUniqueInput
  }


  /**
   * IncomingInspectionSpecItem updateMany
   */
  export type IncomingInspectionSpecItemUpdateManyArgs = {
    /**
     * The data used to update IncomingInspectionSpecItems.
     */
    data: XOR<IncomingInspectionSpecItemUpdateManyMutationInput, IncomingInspectionSpecItemUncheckedUpdateManyInput>
    /**
     * Filter which IncomingInspectionSpecItems to update
     */
    where?: IncomingInspectionSpecItemWhereInput
  }


  /**
   * IncomingInspectionSpecItem upsert
   */
  export type IncomingInspectionSpecItemUpsertArgs = {
    /**
     * Select specific fields to fetch from the IncomingInspectionSpecItem
     */
    select?: IncomingInspectionSpecItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IncomingInspectionSpecItemInclude | null
    /**
     * The filter to search for the IncomingInspectionSpecItem to update in case it exists.
     */
    where: IncomingInspectionSpecItemWhereUniqueInput
    /**
     * In case the IncomingInspectionSpecItem found by the `where` argument doesn't exist, create a new IncomingInspectionSpecItem with this data.
     */
    create: XOR<IncomingInspectionSpecItemCreateInput, IncomingInspectionSpecItemUncheckedCreateInput>
    /**
     * In case the IncomingInspectionSpecItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IncomingInspectionSpecItemUpdateInput, IncomingInspectionSpecItemUncheckedUpdateInput>
  }


  /**
   * IncomingInspectionSpecItem delete
   */
  export type IncomingInspectionSpecItemDeleteArgs = {
    /**
     * Select specific fields to fetch from the IncomingInspectionSpecItem
     */
    select?: IncomingInspectionSpecItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IncomingInspectionSpecItemInclude | null
    /**
     * Filter which IncomingInspectionSpecItem to delete.
     */
    where: IncomingInspectionSpecItemWhereUniqueInput
  }


  /**
   * IncomingInspectionSpecItem deleteMany
   */
  export type IncomingInspectionSpecItemDeleteManyArgs = {
    /**
     * Filter which IncomingInspectionSpecItems to delete
     */
    where?: IncomingInspectionSpecItemWhereInput
  }


  /**
   * IncomingInspectionSpecItem.incomingInspectionRecordItem
   */
  export type IncomingInspectionSpecItem$incomingInspectionRecordItemArgs = {
    /**
     * Select specific fields to fetch from the IncomingInspectionRecordItem
     */
    select?: IncomingInspectionRecordItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IncomingInspectionRecordItemInclude | null
    where?: IncomingInspectionRecordItemWhereInput
    orderBy?: Enumerable<IncomingInspectionRecordItemOrderByWithRelationInput>
    cursor?: IncomingInspectionRecordItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<IncomingInspectionRecordItemScalarFieldEnum>
  }


  /**
   * IncomingInspectionSpecItem without action
   */
  export type IncomingInspectionSpecItemArgs = {
    /**
     * Select specific fields to fetch from the IncomingInspectionSpecItem
     */
    select?: IncomingInspectionSpecItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IncomingInspectionSpecItemInclude | null
  }



  /**
   * Model NonconformItem
   */


  export type AggregateNonconformItem = {
    _count: NonconformItemCountAggregateOutputType | null
    _avg: NonconformItemAvgAggregateOutputType | null
    _sum: NonconformItemSumAggregateOutputType | null
    _min: NonconformItemMinAggregateOutputType | null
    _max: NonconformItemMaxAggregateOutputType | null
  }

  export type NonconformItemAvgAggregateOutputType = {
    id: number | null
    partId: number | null
  }

  export type NonconformItemSumAggregateOutputType = {
    id: number | null
    partId: number | null
  }

  export type NonconformItemMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    partId: number | null
    description: string | null
    note: string | null
  }

  export type NonconformItemMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    partId: number | null
    description: string | null
    note: string | null
  }

  export type NonconformItemCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    isDeleted: number
    partId: number
    description: number
    note: number
    _all: number
  }


  export type NonconformItemAvgAggregateInputType = {
    id?: true
    partId?: true
  }

  export type NonconformItemSumAggregateInputType = {
    id?: true
    partId?: true
  }

  export type NonconformItemMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    partId?: true
    description?: true
    note?: true
  }

  export type NonconformItemMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    partId?: true
    description?: true
    note?: true
  }

  export type NonconformItemCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    partId?: true
    description?: true
    note?: true
    _all?: true
  }

  export type NonconformItemAggregateArgs = {
    /**
     * Filter which NonconformItem to aggregate.
     */
    where?: NonconformItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NonconformItems to fetch.
     */
    orderBy?: Enumerable<NonconformItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NonconformItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NonconformItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NonconformItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NonconformItems
    **/
    _count?: true | NonconformItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NonconformItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NonconformItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NonconformItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NonconformItemMaxAggregateInputType
  }

  export type GetNonconformItemAggregateType<T extends NonconformItemAggregateArgs> = {
        [P in keyof T & keyof AggregateNonconformItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNonconformItem[P]>
      : GetScalarType<T[P], AggregateNonconformItem[P]>
  }




  export type NonconformItemGroupByArgs = {
    where?: NonconformItemWhereInput
    orderBy?: Enumerable<NonconformItemOrderByWithAggregationInput>
    by: NonconformItemScalarFieldEnum[]
    having?: NonconformItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NonconformItemCountAggregateInputType | true
    _avg?: NonconformItemAvgAggregateInputType
    _sum?: NonconformItemSumAggregateInputType
    _min?: NonconformItemMinAggregateInputType
    _max?: NonconformItemMaxAggregateInputType
  }


  export type NonconformItemGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    isDeleted: boolean
    partId: number
    description: string
    note: string | null
    _count: NonconformItemCountAggregateOutputType | null
    _avg: NonconformItemAvgAggregateOutputType | null
    _sum: NonconformItemSumAggregateOutputType | null
    _min: NonconformItemMinAggregateOutputType | null
    _max: NonconformItemMaxAggregateOutputType | null
  }

  type GetNonconformItemGroupByPayload<T extends NonconformItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<NonconformItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NonconformItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NonconformItemGroupByOutputType[P]>
            : GetScalarType<T[P], NonconformItemGroupByOutputType[P]>
        }
      >
    >


  export type NonconformItemSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    partId?: boolean
    description?: boolean
    note?: boolean
    part?: boolean | PartArgs
  }


  export type NonconformItemInclude = {
    part?: boolean | PartArgs
  }

  export type NonconformItemGetPayload<S extends boolean | null | undefined | NonconformItemArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? NonconformItem :
    S extends undefined ? never :
    S extends { include: any } & (NonconformItemArgs | NonconformItemFindManyArgs)
    ? NonconformItem  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'part' ? PartGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (NonconformItemArgs | NonconformItemFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'part' ? PartGetPayload<S['select'][P]> :  P extends keyof NonconformItem ? NonconformItem[P] : never
  } 
      : NonconformItem


  type NonconformItemCountArgs = 
    Omit<NonconformItemFindManyArgs, 'select' | 'include'> & {
      select?: NonconformItemCountAggregateInputType | true
    }

  export interface NonconformItemDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one NonconformItem that matches the filter.
     * @param {NonconformItemFindUniqueArgs} args - Arguments to find a NonconformItem
     * @example
     * // Get one NonconformItem
     * const nonconformItem = await prisma.nonconformItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends NonconformItemFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, NonconformItemFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'NonconformItem'> extends True ? Prisma__NonconformItemClient<NonconformItemGetPayload<T>> : Prisma__NonconformItemClient<NonconformItemGetPayload<T> | null, null>

    /**
     * Find one NonconformItem that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {NonconformItemFindUniqueOrThrowArgs} args - Arguments to find a NonconformItem
     * @example
     * // Get one NonconformItem
     * const nonconformItem = await prisma.nonconformItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends NonconformItemFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, NonconformItemFindUniqueOrThrowArgs>
    ): Prisma__NonconformItemClient<NonconformItemGetPayload<T>>

    /**
     * Find the first NonconformItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NonconformItemFindFirstArgs} args - Arguments to find a NonconformItem
     * @example
     * // Get one NonconformItem
     * const nonconformItem = await prisma.nonconformItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends NonconformItemFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, NonconformItemFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'NonconformItem'> extends True ? Prisma__NonconformItemClient<NonconformItemGetPayload<T>> : Prisma__NonconformItemClient<NonconformItemGetPayload<T> | null, null>

    /**
     * Find the first NonconformItem that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NonconformItemFindFirstOrThrowArgs} args - Arguments to find a NonconformItem
     * @example
     * // Get one NonconformItem
     * const nonconformItem = await prisma.nonconformItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends NonconformItemFindFirstOrThrowArgs>(
      args?: SelectSubset<T, NonconformItemFindFirstOrThrowArgs>
    ): Prisma__NonconformItemClient<NonconformItemGetPayload<T>>

    /**
     * Find zero or more NonconformItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NonconformItemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NonconformItems
     * const nonconformItems = await prisma.nonconformItem.findMany()
     * 
     * // Get first 10 NonconformItems
     * const nonconformItems = await prisma.nonconformItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const nonconformItemWithIdOnly = await prisma.nonconformItem.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends NonconformItemFindManyArgs>(
      args?: SelectSubset<T, NonconformItemFindManyArgs>
    ): Prisma.PrismaPromise<Array<NonconformItemGetPayload<T>>>

    /**
     * Create a NonconformItem.
     * @param {NonconformItemCreateArgs} args - Arguments to create a NonconformItem.
     * @example
     * // Create one NonconformItem
     * const NonconformItem = await prisma.nonconformItem.create({
     *   data: {
     *     // ... data to create a NonconformItem
     *   }
     * })
     * 
    **/
    create<T extends NonconformItemCreateArgs>(
      args: SelectSubset<T, NonconformItemCreateArgs>
    ): Prisma__NonconformItemClient<NonconformItemGetPayload<T>>

    /**
     * Create many NonconformItems.
     *     @param {NonconformItemCreateManyArgs} args - Arguments to create many NonconformItems.
     *     @example
     *     // Create many NonconformItems
     *     const nonconformItem = await prisma.nonconformItem.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends NonconformItemCreateManyArgs>(
      args?: SelectSubset<T, NonconformItemCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a NonconformItem.
     * @param {NonconformItemDeleteArgs} args - Arguments to delete one NonconformItem.
     * @example
     * // Delete one NonconformItem
     * const NonconformItem = await prisma.nonconformItem.delete({
     *   where: {
     *     // ... filter to delete one NonconformItem
     *   }
     * })
     * 
    **/
    delete<T extends NonconformItemDeleteArgs>(
      args: SelectSubset<T, NonconformItemDeleteArgs>
    ): Prisma__NonconformItemClient<NonconformItemGetPayload<T>>

    /**
     * Update one NonconformItem.
     * @param {NonconformItemUpdateArgs} args - Arguments to update one NonconformItem.
     * @example
     * // Update one NonconformItem
     * const nonconformItem = await prisma.nonconformItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends NonconformItemUpdateArgs>(
      args: SelectSubset<T, NonconformItemUpdateArgs>
    ): Prisma__NonconformItemClient<NonconformItemGetPayload<T>>

    /**
     * Delete zero or more NonconformItems.
     * @param {NonconformItemDeleteManyArgs} args - Arguments to filter NonconformItems to delete.
     * @example
     * // Delete a few NonconformItems
     * const { count } = await prisma.nonconformItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends NonconformItemDeleteManyArgs>(
      args?: SelectSubset<T, NonconformItemDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NonconformItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NonconformItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NonconformItems
     * const nonconformItem = await prisma.nonconformItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends NonconformItemUpdateManyArgs>(
      args: SelectSubset<T, NonconformItemUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NonconformItem.
     * @param {NonconformItemUpsertArgs} args - Arguments to update or create a NonconformItem.
     * @example
     * // Update or create a NonconformItem
     * const nonconformItem = await prisma.nonconformItem.upsert({
     *   create: {
     *     // ... data to create a NonconformItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NonconformItem we want to update
     *   }
     * })
    **/
    upsert<T extends NonconformItemUpsertArgs>(
      args: SelectSubset<T, NonconformItemUpsertArgs>
    ): Prisma__NonconformItemClient<NonconformItemGetPayload<T>>

    /**
     * Count the number of NonconformItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NonconformItemCountArgs} args - Arguments to filter NonconformItems to count.
     * @example
     * // Count the number of NonconformItems
     * const count = await prisma.nonconformItem.count({
     *   where: {
     *     // ... the filter for the NonconformItems we want to count
     *   }
     * })
    **/
    count<T extends NonconformItemCountArgs>(
      args?: Subset<T, NonconformItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NonconformItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NonconformItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NonconformItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NonconformItemAggregateArgs>(args: Subset<T, NonconformItemAggregateArgs>): Prisma.PrismaPromise<GetNonconformItemAggregateType<T>>

    /**
     * Group by NonconformItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NonconformItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NonconformItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NonconformItemGroupByArgs['orderBy'] }
        : { orderBy?: NonconformItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NonconformItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNonconformItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for NonconformItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__NonconformItemClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    part<T extends PartArgs= {}>(args?: Subset<T, PartArgs>): Prisma__PartClient<PartGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * NonconformItem base type for findUnique actions
   */
  export type NonconformItemFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the NonconformItem
     */
    select?: NonconformItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NonconformItemInclude | null
    /**
     * Filter, which NonconformItem to fetch.
     */
    where: NonconformItemWhereUniqueInput
  }

  /**
   * NonconformItem findUnique
   */
  export interface NonconformItemFindUniqueArgs extends NonconformItemFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * NonconformItem findUniqueOrThrow
   */
  export type NonconformItemFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the NonconformItem
     */
    select?: NonconformItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NonconformItemInclude | null
    /**
     * Filter, which NonconformItem to fetch.
     */
    where: NonconformItemWhereUniqueInput
  }


  /**
   * NonconformItem base type for findFirst actions
   */
  export type NonconformItemFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the NonconformItem
     */
    select?: NonconformItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NonconformItemInclude | null
    /**
     * Filter, which NonconformItem to fetch.
     */
    where?: NonconformItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NonconformItems to fetch.
     */
    orderBy?: Enumerable<NonconformItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NonconformItems.
     */
    cursor?: NonconformItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NonconformItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NonconformItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NonconformItems.
     */
    distinct?: Enumerable<NonconformItemScalarFieldEnum>
  }

  /**
   * NonconformItem findFirst
   */
  export interface NonconformItemFindFirstArgs extends NonconformItemFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * NonconformItem findFirstOrThrow
   */
  export type NonconformItemFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the NonconformItem
     */
    select?: NonconformItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NonconformItemInclude | null
    /**
     * Filter, which NonconformItem to fetch.
     */
    where?: NonconformItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NonconformItems to fetch.
     */
    orderBy?: Enumerable<NonconformItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NonconformItems.
     */
    cursor?: NonconformItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NonconformItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NonconformItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NonconformItems.
     */
    distinct?: Enumerable<NonconformItemScalarFieldEnum>
  }


  /**
   * NonconformItem findMany
   */
  export type NonconformItemFindManyArgs = {
    /**
     * Select specific fields to fetch from the NonconformItem
     */
    select?: NonconformItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NonconformItemInclude | null
    /**
     * Filter, which NonconformItems to fetch.
     */
    where?: NonconformItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NonconformItems to fetch.
     */
    orderBy?: Enumerable<NonconformItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NonconformItems.
     */
    cursor?: NonconformItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NonconformItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NonconformItems.
     */
    skip?: number
    distinct?: Enumerable<NonconformItemScalarFieldEnum>
  }


  /**
   * NonconformItem create
   */
  export type NonconformItemCreateArgs = {
    /**
     * Select specific fields to fetch from the NonconformItem
     */
    select?: NonconformItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NonconformItemInclude | null
    /**
     * The data needed to create a NonconformItem.
     */
    data: XOR<NonconformItemCreateInput, NonconformItemUncheckedCreateInput>
  }


  /**
   * NonconformItem createMany
   */
  export type NonconformItemCreateManyArgs = {
    /**
     * The data used to create many NonconformItems.
     */
    data: Enumerable<NonconformItemCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * NonconformItem update
   */
  export type NonconformItemUpdateArgs = {
    /**
     * Select specific fields to fetch from the NonconformItem
     */
    select?: NonconformItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NonconformItemInclude | null
    /**
     * The data needed to update a NonconformItem.
     */
    data: XOR<NonconformItemUpdateInput, NonconformItemUncheckedUpdateInput>
    /**
     * Choose, which NonconformItem to update.
     */
    where: NonconformItemWhereUniqueInput
  }


  /**
   * NonconformItem updateMany
   */
  export type NonconformItemUpdateManyArgs = {
    /**
     * The data used to update NonconformItems.
     */
    data: XOR<NonconformItemUpdateManyMutationInput, NonconformItemUncheckedUpdateManyInput>
    /**
     * Filter which NonconformItems to update
     */
    where?: NonconformItemWhereInput
  }


  /**
   * NonconformItem upsert
   */
  export type NonconformItemUpsertArgs = {
    /**
     * Select specific fields to fetch from the NonconformItem
     */
    select?: NonconformItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NonconformItemInclude | null
    /**
     * The filter to search for the NonconformItem to update in case it exists.
     */
    where: NonconformItemWhereUniqueInput
    /**
     * In case the NonconformItem found by the `where` argument doesn't exist, create a new NonconformItem with this data.
     */
    create: XOR<NonconformItemCreateInput, NonconformItemUncheckedCreateInput>
    /**
     * In case the NonconformItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NonconformItemUpdateInput, NonconformItemUncheckedUpdateInput>
  }


  /**
   * NonconformItem delete
   */
  export type NonconformItemDeleteArgs = {
    /**
     * Select specific fields to fetch from the NonconformItem
     */
    select?: NonconformItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NonconformItemInclude | null
    /**
     * Filter which NonconformItem to delete.
     */
    where: NonconformItemWhereUniqueInput
  }


  /**
   * NonconformItem deleteMany
   */
  export type NonconformItemDeleteManyArgs = {
    /**
     * Filter which NonconformItems to delete
     */
    where?: NonconformItemWhereInput
  }


  /**
   * NonconformItem without action
   */
  export type NonconformItemArgs = {
    /**
     * Select specific fields to fetch from the NonconformItem
     */
    select?: NonconformItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NonconformItemInclude | null
  }



  /**
   * Model PartOperation
   */


  export type AggregatePartOperation = {
    _count: PartOperationCountAggregateOutputType | null
    _avg: PartOperationAvgAggregateOutputType | null
    _sum: PartOperationSumAggregateOutputType | null
    _min: PartOperationMinAggregateOutputType | null
    _max: PartOperationMaxAggregateOutputType | null
  }

  export type PartOperationAvgAggregateOutputType = {
    id: number | null
    partId: number | null
  }

  export type PartOperationSumAggregateOutputType = {
    id: number | null
    partId: number | null
  }

  export type PartOperationMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    version: string | null
    no: string | null
    name: string | null
    partId: number | null
  }

  export type PartOperationMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    version: string | null
    no: string | null
    name: string | null
    partId: number | null
  }

  export type PartOperationCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    isDeleted: number
    version: number
    no: number
    name: number
    partId: number
    _all: number
  }


  export type PartOperationAvgAggregateInputType = {
    id?: true
    partId?: true
  }

  export type PartOperationSumAggregateInputType = {
    id?: true
    partId?: true
  }

  export type PartOperationMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    version?: true
    no?: true
    name?: true
    partId?: true
  }

  export type PartOperationMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    version?: true
    no?: true
    name?: true
    partId?: true
  }

  export type PartOperationCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    version?: true
    no?: true
    name?: true
    partId?: true
    _all?: true
  }

  export type PartOperationAggregateArgs = {
    /**
     * Filter which PartOperation to aggregate.
     */
    where?: PartOperationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PartOperations to fetch.
     */
    orderBy?: Enumerable<PartOperationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PartOperationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PartOperations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PartOperations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PartOperations
    **/
    _count?: true | PartOperationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PartOperationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PartOperationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PartOperationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PartOperationMaxAggregateInputType
  }

  export type GetPartOperationAggregateType<T extends PartOperationAggregateArgs> = {
        [P in keyof T & keyof AggregatePartOperation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePartOperation[P]>
      : GetScalarType<T[P], AggregatePartOperation[P]>
  }




  export type PartOperationGroupByArgs = {
    where?: PartOperationWhereInput
    orderBy?: Enumerable<PartOperationOrderByWithAggregationInput>
    by: PartOperationScalarFieldEnum[]
    having?: PartOperationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PartOperationCountAggregateInputType | true
    _avg?: PartOperationAvgAggregateInputType
    _sum?: PartOperationSumAggregateInputType
    _min?: PartOperationMinAggregateInputType
    _max?: PartOperationMaxAggregateInputType
  }


  export type PartOperationGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    isDeleted: boolean
    version: string
    no: string
    name: string
    partId: number
    _count: PartOperationCountAggregateOutputType | null
    _avg: PartOperationAvgAggregateOutputType | null
    _sum: PartOperationSumAggregateOutputType | null
    _min: PartOperationMinAggregateOutputType | null
    _max: PartOperationMaxAggregateOutputType | null
  }

  type GetPartOperationGroupByPayload<T extends PartOperationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PartOperationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PartOperationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PartOperationGroupByOutputType[P]>
            : GetScalarType<T[P], PartOperationGroupByOutputType[P]>
        }
      >
    >


  export type PartOperationSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    version?: boolean
    no?: boolean
    name?: boolean
    partId?: boolean
    part?: boolean | PartArgs
    partOperationInspectionItems?: boolean | PartOperation$partOperationInspectionItemsArgs
    _count?: boolean | PartOperationCountOutputTypeArgs
  }


  export type PartOperationInclude = {
    part?: boolean | PartArgs
    partOperationInspectionItems?: boolean | PartOperation$partOperationInspectionItemsArgs
    _count?: boolean | PartOperationCountOutputTypeArgs
  }

  export type PartOperationGetPayload<S extends boolean | null | undefined | PartOperationArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? PartOperation :
    S extends undefined ? never :
    S extends { include: any } & (PartOperationArgs | PartOperationFindManyArgs)
    ? PartOperation  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'part' ? PartGetPayload<S['include'][P]> :
        P extends 'partOperationInspectionItems' ? Array < PartOperationInspectionItemGetPayload<S['include'][P]>>  :
        P extends '_count' ? PartOperationCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (PartOperationArgs | PartOperationFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'part' ? PartGetPayload<S['select'][P]> :
        P extends 'partOperationInspectionItems' ? Array < PartOperationInspectionItemGetPayload<S['select'][P]>>  :
        P extends '_count' ? PartOperationCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof PartOperation ? PartOperation[P] : never
  } 
      : PartOperation


  type PartOperationCountArgs = 
    Omit<PartOperationFindManyArgs, 'select' | 'include'> & {
      select?: PartOperationCountAggregateInputType | true
    }

  export interface PartOperationDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one PartOperation that matches the filter.
     * @param {PartOperationFindUniqueArgs} args - Arguments to find a PartOperation
     * @example
     * // Get one PartOperation
     * const partOperation = await prisma.partOperation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PartOperationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PartOperationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PartOperation'> extends True ? Prisma__PartOperationClient<PartOperationGetPayload<T>> : Prisma__PartOperationClient<PartOperationGetPayload<T> | null, null>

    /**
     * Find one PartOperation that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PartOperationFindUniqueOrThrowArgs} args - Arguments to find a PartOperation
     * @example
     * // Get one PartOperation
     * const partOperation = await prisma.partOperation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PartOperationFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PartOperationFindUniqueOrThrowArgs>
    ): Prisma__PartOperationClient<PartOperationGetPayload<T>>

    /**
     * Find the first PartOperation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartOperationFindFirstArgs} args - Arguments to find a PartOperation
     * @example
     * // Get one PartOperation
     * const partOperation = await prisma.partOperation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PartOperationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PartOperationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PartOperation'> extends True ? Prisma__PartOperationClient<PartOperationGetPayload<T>> : Prisma__PartOperationClient<PartOperationGetPayload<T> | null, null>

    /**
     * Find the first PartOperation that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartOperationFindFirstOrThrowArgs} args - Arguments to find a PartOperation
     * @example
     * // Get one PartOperation
     * const partOperation = await prisma.partOperation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PartOperationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PartOperationFindFirstOrThrowArgs>
    ): Prisma__PartOperationClient<PartOperationGetPayload<T>>

    /**
     * Find zero or more PartOperations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartOperationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PartOperations
     * const partOperations = await prisma.partOperation.findMany()
     * 
     * // Get first 10 PartOperations
     * const partOperations = await prisma.partOperation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const partOperationWithIdOnly = await prisma.partOperation.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PartOperationFindManyArgs>(
      args?: SelectSubset<T, PartOperationFindManyArgs>
    ): Prisma.PrismaPromise<Array<PartOperationGetPayload<T>>>

    /**
     * Create a PartOperation.
     * @param {PartOperationCreateArgs} args - Arguments to create a PartOperation.
     * @example
     * // Create one PartOperation
     * const PartOperation = await prisma.partOperation.create({
     *   data: {
     *     // ... data to create a PartOperation
     *   }
     * })
     * 
    **/
    create<T extends PartOperationCreateArgs>(
      args: SelectSubset<T, PartOperationCreateArgs>
    ): Prisma__PartOperationClient<PartOperationGetPayload<T>>

    /**
     * Create many PartOperations.
     *     @param {PartOperationCreateManyArgs} args - Arguments to create many PartOperations.
     *     @example
     *     // Create many PartOperations
     *     const partOperation = await prisma.partOperation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PartOperationCreateManyArgs>(
      args?: SelectSubset<T, PartOperationCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PartOperation.
     * @param {PartOperationDeleteArgs} args - Arguments to delete one PartOperation.
     * @example
     * // Delete one PartOperation
     * const PartOperation = await prisma.partOperation.delete({
     *   where: {
     *     // ... filter to delete one PartOperation
     *   }
     * })
     * 
    **/
    delete<T extends PartOperationDeleteArgs>(
      args: SelectSubset<T, PartOperationDeleteArgs>
    ): Prisma__PartOperationClient<PartOperationGetPayload<T>>

    /**
     * Update one PartOperation.
     * @param {PartOperationUpdateArgs} args - Arguments to update one PartOperation.
     * @example
     * // Update one PartOperation
     * const partOperation = await prisma.partOperation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PartOperationUpdateArgs>(
      args: SelectSubset<T, PartOperationUpdateArgs>
    ): Prisma__PartOperationClient<PartOperationGetPayload<T>>

    /**
     * Delete zero or more PartOperations.
     * @param {PartOperationDeleteManyArgs} args - Arguments to filter PartOperations to delete.
     * @example
     * // Delete a few PartOperations
     * const { count } = await prisma.partOperation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PartOperationDeleteManyArgs>(
      args?: SelectSubset<T, PartOperationDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PartOperations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartOperationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PartOperations
     * const partOperation = await prisma.partOperation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PartOperationUpdateManyArgs>(
      args: SelectSubset<T, PartOperationUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PartOperation.
     * @param {PartOperationUpsertArgs} args - Arguments to update or create a PartOperation.
     * @example
     * // Update or create a PartOperation
     * const partOperation = await prisma.partOperation.upsert({
     *   create: {
     *     // ... data to create a PartOperation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PartOperation we want to update
     *   }
     * })
    **/
    upsert<T extends PartOperationUpsertArgs>(
      args: SelectSubset<T, PartOperationUpsertArgs>
    ): Prisma__PartOperationClient<PartOperationGetPayload<T>>

    /**
     * Count the number of PartOperations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartOperationCountArgs} args - Arguments to filter PartOperations to count.
     * @example
     * // Count the number of PartOperations
     * const count = await prisma.partOperation.count({
     *   where: {
     *     // ... the filter for the PartOperations we want to count
     *   }
     * })
    **/
    count<T extends PartOperationCountArgs>(
      args?: Subset<T, PartOperationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PartOperationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PartOperation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartOperationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PartOperationAggregateArgs>(args: Subset<T, PartOperationAggregateArgs>): Prisma.PrismaPromise<GetPartOperationAggregateType<T>>

    /**
     * Group by PartOperation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartOperationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PartOperationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PartOperationGroupByArgs['orderBy'] }
        : { orderBy?: PartOperationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PartOperationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPartOperationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for PartOperation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PartOperationClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    part<T extends PartArgs= {}>(args?: Subset<T, PartArgs>): Prisma__PartClient<PartGetPayload<T> | Null>;

    partOperationInspectionItems<T extends PartOperation$partOperationInspectionItemsArgs= {}>(args?: Subset<T, PartOperation$partOperationInspectionItemsArgs>): Prisma.PrismaPromise<Array<PartOperationInspectionItemGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * PartOperation base type for findUnique actions
   */
  export type PartOperationFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the PartOperation
     */
    select?: PartOperationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartOperationInclude | null
    /**
     * Filter, which PartOperation to fetch.
     */
    where: PartOperationWhereUniqueInput
  }

  /**
   * PartOperation findUnique
   */
  export interface PartOperationFindUniqueArgs extends PartOperationFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PartOperation findUniqueOrThrow
   */
  export type PartOperationFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the PartOperation
     */
    select?: PartOperationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartOperationInclude | null
    /**
     * Filter, which PartOperation to fetch.
     */
    where: PartOperationWhereUniqueInput
  }


  /**
   * PartOperation base type for findFirst actions
   */
  export type PartOperationFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the PartOperation
     */
    select?: PartOperationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartOperationInclude | null
    /**
     * Filter, which PartOperation to fetch.
     */
    where?: PartOperationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PartOperations to fetch.
     */
    orderBy?: Enumerable<PartOperationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PartOperations.
     */
    cursor?: PartOperationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PartOperations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PartOperations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PartOperations.
     */
    distinct?: Enumerable<PartOperationScalarFieldEnum>
  }

  /**
   * PartOperation findFirst
   */
  export interface PartOperationFindFirstArgs extends PartOperationFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PartOperation findFirstOrThrow
   */
  export type PartOperationFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the PartOperation
     */
    select?: PartOperationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartOperationInclude | null
    /**
     * Filter, which PartOperation to fetch.
     */
    where?: PartOperationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PartOperations to fetch.
     */
    orderBy?: Enumerable<PartOperationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PartOperations.
     */
    cursor?: PartOperationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PartOperations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PartOperations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PartOperations.
     */
    distinct?: Enumerable<PartOperationScalarFieldEnum>
  }


  /**
   * PartOperation findMany
   */
  export type PartOperationFindManyArgs = {
    /**
     * Select specific fields to fetch from the PartOperation
     */
    select?: PartOperationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartOperationInclude | null
    /**
     * Filter, which PartOperations to fetch.
     */
    where?: PartOperationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PartOperations to fetch.
     */
    orderBy?: Enumerable<PartOperationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PartOperations.
     */
    cursor?: PartOperationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PartOperations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PartOperations.
     */
    skip?: number
    distinct?: Enumerable<PartOperationScalarFieldEnum>
  }


  /**
   * PartOperation create
   */
  export type PartOperationCreateArgs = {
    /**
     * Select specific fields to fetch from the PartOperation
     */
    select?: PartOperationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartOperationInclude | null
    /**
     * The data needed to create a PartOperation.
     */
    data: XOR<PartOperationCreateInput, PartOperationUncheckedCreateInput>
  }


  /**
   * PartOperation createMany
   */
  export type PartOperationCreateManyArgs = {
    /**
     * The data used to create many PartOperations.
     */
    data: Enumerable<PartOperationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * PartOperation update
   */
  export type PartOperationUpdateArgs = {
    /**
     * Select specific fields to fetch from the PartOperation
     */
    select?: PartOperationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartOperationInclude | null
    /**
     * The data needed to update a PartOperation.
     */
    data: XOR<PartOperationUpdateInput, PartOperationUncheckedUpdateInput>
    /**
     * Choose, which PartOperation to update.
     */
    where: PartOperationWhereUniqueInput
  }


  /**
   * PartOperation updateMany
   */
  export type PartOperationUpdateManyArgs = {
    /**
     * The data used to update PartOperations.
     */
    data: XOR<PartOperationUpdateManyMutationInput, PartOperationUncheckedUpdateManyInput>
    /**
     * Filter which PartOperations to update
     */
    where?: PartOperationWhereInput
  }


  /**
   * PartOperation upsert
   */
  export type PartOperationUpsertArgs = {
    /**
     * Select specific fields to fetch from the PartOperation
     */
    select?: PartOperationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartOperationInclude | null
    /**
     * The filter to search for the PartOperation to update in case it exists.
     */
    where: PartOperationWhereUniqueInput
    /**
     * In case the PartOperation found by the `where` argument doesn't exist, create a new PartOperation with this data.
     */
    create: XOR<PartOperationCreateInput, PartOperationUncheckedCreateInput>
    /**
     * In case the PartOperation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PartOperationUpdateInput, PartOperationUncheckedUpdateInput>
  }


  /**
   * PartOperation delete
   */
  export type PartOperationDeleteArgs = {
    /**
     * Select specific fields to fetch from the PartOperation
     */
    select?: PartOperationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartOperationInclude | null
    /**
     * Filter which PartOperation to delete.
     */
    where: PartOperationWhereUniqueInput
  }


  /**
   * PartOperation deleteMany
   */
  export type PartOperationDeleteManyArgs = {
    /**
     * Filter which PartOperations to delete
     */
    where?: PartOperationWhereInput
  }


  /**
   * PartOperation.partOperationInspectionItems
   */
  export type PartOperation$partOperationInspectionItemsArgs = {
    /**
     * Select specific fields to fetch from the PartOperationInspectionItem
     */
    select?: PartOperationInspectionItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartOperationInspectionItemInclude | null
    where?: PartOperationInspectionItemWhereInput
    orderBy?: Enumerable<PartOperationInspectionItemOrderByWithRelationInput>
    cursor?: PartOperationInspectionItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PartOperationInspectionItemScalarFieldEnum>
  }


  /**
   * PartOperation without action
   */
  export type PartOperationArgs = {
    /**
     * Select specific fields to fetch from the PartOperation
     */
    select?: PartOperationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartOperationInclude | null
  }



  /**
   * Model PartOperationInspectionItem
   */


  export type AggregatePartOperationInspectionItem = {
    _count: PartOperationInspectionItemCountAggregateOutputType | null
    _avg: PartOperationInspectionItemAvgAggregateOutputType | null
    _sum: PartOperationInspectionItemSumAggregateOutputType | null
    _min: PartOperationInspectionItemMinAggregateOutputType | null
    _max: PartOperationInspectionItemMaxAggregateOutputType | null
  }

  export type PartOperationInspectionItemAvgAggregateOutputType = {
    id: number | null
    partOperationId: number | null
  }

  export type PartOperationInspectionItemSumAggregateOutputType = {
    id: number | null
    partOperationId: number | null
  }

  export type PartOperationInspectionItemMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    name: string | null
    partOperationId: number | null
  }

  export type PartOperationInspectionItemMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    name: string | null
    partOperationId: number | null
  }

  export type PartOperationInspectionItemCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    isDeleted: number
    name: number
    partOperationId: number
    _all: number
  }


  export type PartOperationInspectionItemAvgAggregateInputType = {
    id?: true
    partOperationId?: true
  }

  export type PartOperationInspectionItemSumAggregateInputType = {
    id?: true
    partOperationId?: true
  }

  export type PartOperationInspectionItemMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    name?: true
    partOperationId?: true
  }

  export type PartOperationInspectionItemMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    name?: true
    partOperationId?: true
  }

  export type PartOperationInspectionItemCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    name?: true
    partOperationId?: true
    _all?: true
  }

  export type PartOperationInspectionItemAggregateArgs = {
    /**
     * Filter which PartOperationInspectionItem to aggregate.
     */
    where?: PartOperationInspectionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PartOperationInspectionItems to fetch.
     */
    orderBy?: Enumerable<PartOperationInspectionItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PartOperationInspectionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PartOperationInspectionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PartOperationInspectionItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PartOperationInspectionItems
    **/
    _count?: true | PartOperationInspectionItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PartOperationInspectionItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PartOperationInspectionItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PartOperationInspectionItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PartOperationInspectionItemMaxAggregateInputType
  }

  export type GetPartOperationInspectionItemAggregateType<T extends PartOperationInspectionItemAggregateArgs> = {
        [P in keyof T & keyof AggregatePartOperationInspectionItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePartOperationInspectionItem[P]>
      : GetScalarType<T[P], AggregatePartOperationInspectionItem[P]>
  }




  export type PartOperationInspectionItemGroupByArgs = {
    where?: PartOperationInspectionItemWhereInput
    orderBy?: Enumerable<PartOperationInspectionItemOrderByWithAggregationInput>
    by: PartOperationInspectionItemScalarFieldEnum[]
    having?: PartOperationInspectionItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PartOperationInspectionItemCountAggregateInputType | true
    _avg?: PartOperationInspectionItemAvgAggregateInputType
    _sum?: PartOperationInspectionItemSumAggregateInputType
    _min?: PartOperationInspectionItemMinAggregateInputType
    _max?: PartOperationInspectionItemMaxAggregateInputType
  }


  export type PartOperationInspectionItemGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    isDeleted: boolean
    name: string
    partOperationId: number
    _count: PartOperationInspectionItemCountAggregateOutputType | null
    _avg: PartOperationInspectionItemAvgAggregateOutputType | null
    _sum: PartOperationInspectionItemSumAggregateOutputType | null
    _min: PartOperationInspectionItemMinAggregateOutputType | null
    _max: PartOperationInspectionItemMaxAggregateOutputType | null
  }

  type GetPartOperationInspectionItemGroupByPayload<T extends PartOperationInspectionItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PartOperationInspectionItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PartOperationInspectionItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PartOperationInspectionItemGroupByOutputType[P]>
            : GetScalarType<T[P], PartOperationInspectionItemGroupByOutputType[P]>
        }
      >
    >


  export type PartOperationInspectionItemSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    name?: boolean
    partOperationId?: boolean
    partOperation?: boolean | PartOperationArgs
    operationInspectionRecordItems?: boolean | PartOperationInspectionItem$operationInspectionRecordItemsArgs
    _count?: boolean | PartOperationInspectionItemCountOutputTypeArgs
  }


  export type PartOperationInspectionItemInclude = {
    partOperation?: boolean | PartOperationArgs
    operationInspectionRecordItems?: boolean | PartOperationInspectionItem$operationInspectionRecordItemsArgs
    _count?: boolean | PartOperationInspectionItemCountOutputTypeArgs
  }

  export type PartOperationInspectionItemGetPayload<S extends boolean | null | undefined | PartOperationInspectionItemArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? PartOperationInspectionItem :
    S extends undefined ? never :
    S extends { include: any } & (PartOperationInspectionItemArgs | PartOperationInspectionItemFindManyArgs)
    ? PartOperationInspectionItem  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'partOperation' ? PartOperationGetPayload<S['include'][P]> :
        P extends 'operationInspectionRecordItems' ? Array < OperationInspectionRecordItemGetPayload<S['include'][P]>>  :
        P extends '_count' ? PartOperationInspectionItemCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (PartOperationInspectionItemArgs | PartOperationInspectionItemFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'partOperation' ? PartOperationGetPayload<S['select'][P]> :
        P extends 'operationInspectionRecordItems' ? Array < OperationInspectionRecordItemGetPayload<S['select'][P]>>  :
        P extends '_count' ? PartOperationInspectionItemCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof PartOperationInspectionItem ? PartOperationInspectionItem[P] : never
  } 
      : PartOperationInspectionItem


  type PartOperationInspectionItemCountArgs = 
    Omit<PartOperationInspectionItemFindManyArgs, 'select' | 'include'> & {
      select?: PartOperationInspectionItemCountAggregateInputType | true
    }

  export interface PartOperationInspectionItemDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one PartOperationInspectionItem that matches the filter.
     * @param {PartOperationInspectionItemFindUniqueArgs} args - Arguments to find a PartOperationInspectionItem
     * @example
     * // Get one PartOperationInspectionItem
     * const partOperationInspectionItem = await prisma.partOperationInspectionItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PartOperationInspectionItemFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PartOperationInspectionItemFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PartOperationInspectionItem'> extends True ? Prisma__PartOperationInspectionItemClient<PartOperationInspectionItemGetPayload<T>> : Prisma__PartOperationInspectionItemClient<PartOperationInspectionItemGetPayload<T> | null, null>

    /**
     * Find one PartOperationInspectionItem that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PartOperationInspectionItemFindUniqueOrThrowArgs} args - Arguments to find a PartOperationInspectionItem
     * @example
     * // Get one PartOperationInspectionItem
     * const partOperationInspectionItem = await prisma.partOperationInspectionItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PartOperationInspectionItemFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PartOperationInspectionItemFindUniqueOrThrowArgs>
    ): Prisma__PartOperationInspectionItemClient<PartOperationInspectionItemGetPayload<T>>

    /**
     * Find the first PartOperationInspectionItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartOperationInspectionItemFindFirstArgs} args - Arguments to find a PartOperationInspectionItem
     * @example
     * // Get one PartOperationInspectionItem
     * const partOperationInspectionItem = await prisma.partOperationInspectionItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PartOperationInspectionItemFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PartOperationInspectionItemFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PartOperationInspectionItem'> extends True ? Prisma__PartOperationInspectionItemClient<PartOperationInspectionItemGetPayload<T>> : Prisma__PartOperationInspectionItemClient<PartOperationInspectionItemGetPayload<T> | null, null>

    /**
     * Find the first PartOperationInspectionItem that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartOperationInspectionItemFindFirstOrThrowArgs} args - Arguments to find a PartOperationInspectionItem
     * @example
     * // Get one PartOperationInspectionItem
     * const partOperationInspectionItem = await prisma.partOperationInspectionItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PartOperationInspectionItemFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PartOperationInspectionItemFindFirstOrThrowArgs>
    ): Prisma__PartOperationInspectionItemClient<PartOperationInspectionItemGetPayload<T>>

    /**
     * Find zero or more PartOperationInspectionItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartOperationInspectionItemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PartOperationInspectionItems
     * const partOperationInspectionItems = await prisma.partOperationInspectionItem.findMany()
     * 
     * // Get first 10 PartOperationInspectionItems
     * const partOperationInspectionItems = await prisma.partOperationInspectionItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const partOperationInspectionItemWithIdOnly = await prisma.partOperationInspectionItem.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PartOperationInspectionItemFindManyArgs>(
      args?: SelectSubset<T, PartOperationInspectionItemFindManyArgs>
    ): Prisma.PrismaPromise<Array<PartOperationInspectionItemGetPayload<T>>>

    /**
     * Create a PartOperationInspectionItem.
     * @param {PartOperationInspectionItemCreateArgs} args - Arguments to create a PartOperationInspectionItem.
     * @example
     * // Create one PartOperationInspectionItem
     * const PartOperationInspectionItem = await prisma.partOperationInspectionItem.create({
     *   data: {
     *     // ... data to create a PartOperationInspectionItem
     *   }
     * })
     * 
    **/
    create<T extends PartOperationInspectionItemCreateArgs>(
      args: SelectSubset<T, PartOperationInspectionItemCreateArgs>
    ): Prisma__PartOperationInspectionItemClient<PartOperationInspectionItemGetPayload<T>>

    /**
     * Create many PartOperationInspectionItems.
     *     @param {PartOperationInspectionItemCreateManyArgs} args - Arguments to create many PartOperationInspectionItems.
     *     @example
     *     // Create many PartOperationInspectionItems
     *     const partOperationInspectionItem = await prisma.partOperationInspectionItem.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PartOperationInspectionItemCreateManyArgs>(
      args?: SelectSubset<T, PartOperationInspectionItemCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PartOperationInspectionItem.
     * @param {PartOperationInspectionItemDeleteArgs} args - Arguments to delete one PartOperationInspectionItem.
     * @example
     * // Delete one PartOperationInspectionItem
     * const PartOperationInspectionItem = await prisma.partOperationInspectionItem.delete({
     *   where: {
     *     // ... filter to delete one PartOperationInspectionItem
     *   }
     * })
     * 
    **/
    delete<T extends PartOperationInspectionItemDeleteArgs>(
      args: SelectSubset<T, PartOperationInspectionItemDeleteArgs>
    ): Prisma__PartOperationInspectionItemClient<PartOperationInspectionItemGetPayload<T>>

    /**
     * Update one PartOperationInspectionItem.
     * @param {PartOperationInspectionItemUpdateArgs} args - Arguments to update one PartOperationInspectionItem.
     * @example
     * // Update one PartOperationInspectionItem
     * const partOperationInspectionItem = await prisma.partOperationInspectionItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PartOperationInspectionItemUpdateArgs>(
      args: SelectSubset<T, PartOperationInspectionItemUpdateArgs>
    ): Prisma__PartOperationInspectionItemClient<PartOperationInspectionItemGetPayload<T>>

    /**
     * Delete zero or more PartOperationInspectionItems.
     * @param {PartOperationInspectionItemDeleteManyArgs} args - Arguments to filter PartOperationInspectionItems to delete.
     * @example
     * // Delete a few PartOperationInspectionItems
     * const { count } = await prisma.partOperationInspectionItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PartOperationInspectionItemDeleteManyArgs>(
      args?: SelectSubset<T, PartOperationInspectionItemDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PartOperationInspectionItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartOperationInspectionItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PartOperationInspectionItems
     * const partOperationInspectionItem = await prisma.partOperationInspectionItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PartOperationInspectionItemUpdateManyArgs>(
      args: SelectSubset<T, PartOperationInspectionItemUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PartOperationInspectionItem.
     * @param {PartOperationInspectionItemUpsertArgs} args - Arguments to update or create a PartOperationInspectionItem.
     * @example
     * // Update or create a PartOperationInspectionItem
     * const partOperationInspectionItem = await prisma.partOperationInspectionItem.upsert({
     *   create: {
     *     // ... data to create a PartOperationInspectionItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PartOperationInspectionItem we want to update
     *   }
     * })
    **/
    upsert<T extends PartOperationInspectionItemUpsertArgs>(
      args: SelectSubset<T, PartOperationInspectionItemUpsertArgs>
    ): Prisma__PartOperationInspectionItemClient<PartOperationInspectionItemGetPayload<T>>

    /**
     * Count the number of PartOperationInspectionItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartOperationInspectionItemCountArgs} args - Arguments to filter PartOperationInspectionItems to count.
     * @example
     * // Count the number of PartOperationInspectionItems
     * const count = await prisma.partOperationInspectionItem.count({
     *   where: {
     *     // ... the filter for the PartOperationInspectionItems we want to count
     *   }
     * })
    **/
    count<T extends PartOperationInspectionItemCountArgs>(
      args?: Subset<T, PartOperationInspectionItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PartOperationInspectionItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PartOperationInspectionItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartOperationInspectionItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PartOperationInspectionItemAggregateArgs>(args: Subset<T, PartOperationInspectionItemAggregateArgs>): Prisma.PrismaPromise<GetPartOperationInspectionItemAggregateType<T>>

    /**
     * Group by PartOperationInspectionItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartOperationInspectionItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PartOperationInspectionItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PartOperationInspectionItemGroupByArgs['orderBy'] }
        : { orderBy?: PartOperationInspectionItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PartOperationInspectionItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPartOperationInspectionItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for PartOperationInspectionItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PartOperationInspectionItemClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    partOperation<T extends PartOperationArgs= {}>(args?: Subset<T, PartOperationArgs>): Prisma__PartOperationClient<PartOperationGetPayload<T> | Null>;

    operationInspectionRecordItems<T extends PartOperationInspectionItem$operationInspectionRecordItemsArgs= {}>(args?: Subset<T, PartOperationInspectionItem$operationInspectionRecordItemsArgs>): Prisma.PrismaPromise<Array<OperationInspectionRecordItemGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * PartOperationInspectionItem base type for findUnique actions
   */
  export type PartOperationInspectionItemFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the PartOperationInspectionItem
     */
    select?: PartOperationInspectionItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartOperationInspectionItemInclude | null
    /**
     * Filter, which PartOperationInspectionItem to fetch.
     */
    where: PartOperationInspectionItemWhereUniqueInput
  }

  /**
   * PartOperationInspectionItem findUnique
   */
  export interface PartOperationInspectionItemFindUniqueArgs extends PartOperationInspectionItemFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PartOperationInspectionItem findUniqueOrThrow
   */
  export type PartOperationInspectionItemFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the PartOperationInspectionItem
     */
    select?: PartOperationInspectionItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartOperationInspectionItemInclude | null
    /**
     * Filter, which PartOperationInspectionItem to fetch.
     */
    where: PartOperationInspectionItemWhereUniqueInput
  }


  /**
   * PartOperationInspectionItem base type for findFirst actions
   */
  export type PartOperationInspectionItemFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the PartOperationInspectionItem
     */
    select?: PartOperationInspectionItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartOperationInspectionItemInclude | null
    /**
     * Filter, which PartOperationInspectionItem to fetch.
     */
    where?: PartOperationInspectionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PartOperationInspectionItems to fetch.
     */
    orderBy?: Enumerable<PartOperationInspectionItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PartOperationInspectionItems.
     */
    cursor?: PartOperationInspectionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PartOperationInspectionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PartOperationInspectionItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PartOperationInspectionItems.
     */
    distinct?: Enumerable<PartOperationInspectionItemScalarFieldEnum>
  }

  /**
   * PartOperationInspectionItem findFirst
   */
  export interface PartOperationInspectionItemFindFirstArgs extends PartOperationInspectionItemFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PartOperationInspectionItem findFirstOrThrow
   */
  export type PartOperationInspectionItemFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the PartOperationInspectionItem
     */
    select?: PartOperationInspectionItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartOperationInspectionItemInclude | null
    /**
     * Filter, which PartOperationInspectionItem to fetch.
     */
    where?: PartOperationInspectionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PartOperationInspectionItems to fetch.
     */
    orderBy?: Enumerable<PartOperationInspectionItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PartOperationInspectionItems.
     */
    cursor?: PartOperationInspectionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PartOperationInspectionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PartOperationInspectionItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PartOperationInspectionItems.
     */
    distinct?: Enumerable<PartOperationInspectionItemScalarFieldEnum>
  }


  /**
   * PartOperationInspectionItem findMany
   */
  export type PartOperationInspectionItemFindManyArgs = {
    /**
     * Select specific fields to fetch from the PartOperationInspectionItem
     */
    select?: PartOperationInspectionItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartOperationInspectionItemInclude | null
    /**
     * Filter, which PartOperationInspectionItems to fetch.
     */
    where?: PartOperationInspectionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PartOperationInspectionItems to fetch.
     */
    orderBy?: Enumerable<PartOperationInspectionItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PartOperationInspectionItems.
     */
    cursor?: PartOperationInspectionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PartOperationInspectionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PartOperationInspectionItems.
     */
    skip?: number
    distinct?: Enumerable<PartOperationInspectionItemScalarFieldEnum>
  }


  /**
   * PartOperationInspectionItem create
   */
  export type PartOperationInspectionItemCreateArgs = {
    /**
     * Select specific fields to fetch from the PartOperationInspectionItem
     */
    select?: PartOperationInspectionItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartOperationInspectionItemInclude | null
    /**
     * The data needed to create a PartOperationInspectionItem.
     */
    data: XOR<PartOperationInspectionItemCreateInput, PartOperationInspectionItemUncheckedCreateInput>
  }


  /**
   * PartOperationInspectionItem createMany
   */
  export type PartOperationInspectionItemCreateManyArgs = {
    /**
     * The data used to create many PartOperationInspectionItems.
     */
    data: Enumerable<PartOperationInspectionItemCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * PartOperationInspectionItem update
   */
  export type PartOperationInspectionItemUpdateArgs = {
    /**
     * Select specific fields to fetch from the PartOperationInspectionItem
     */
    select?: PartOperationInspectionItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartOperationInspectionItemInclude | null
    /**
     * The data needed to update a PartOperationInspectionItem.
     */
    data: XOR<PartOperationInspectionItemUpdateInput, PartOperationInspectionItemUncheckedUpdateInput>
    /**
     * Choose, which PartOperationInspectionItem to update.
     */
    where: PartOperationInspectionItemWhereUniqueInput
  }


  /**
   * PartOperationInspectionItem updateMany
   */
  export type PartOperationInspectionItemUpdateManyArgs = {
    /**
     * The data used to update PartOperationInspectionItems.
     */
    data: XOR<PartOperationInspectionItemUpdateManyMutationInput, PartOperationInspectionItemUncheckedUpdateManyInput>
    /**
     * Filter which PartOperationInspectionItems to update
     */
    where?: PartOperationInspectionItemWhereInput
  }


  /**
   * PartOperationInspectionItem upsert
   */
  export type PartOperationInspectionItemUpsertArgs = {
    /**
     * Select specific fields to fetch from the PartOperationInspectionItem
     */
    select?: PartOperationInspectionItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartOperationInspectionItemInclude | null
    /**
     * The filter to search for the PartOperationInspectionItem to update in case it exists.
     */
    where: PartOperationInspectionItemWhereUniqueInput
    /**
     * In case the PartOperationInspectionItem found by the `where` argument doesn't exist, create a new PartOperationInspectionItem with this data.
     */
    create: XOR<PartOperationInspectionItemCreateInput, PartOperationInspectionItemUncheckedCreateInput>
    /**
     * In case the PartOperationInspectionItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PartOperationInspectionItemUpdateInput, PartOperationInspectionItemUncheckedUpdateInput>
  }


  /**
   * PartOperationInspectionItem delete
   */
  export type PartOperationInspectionItemDeleteArgs = {
    /**
     * Select specific fields to fetch from the PartOperationInspectionItem
     */
    select?: PartOperationInspectionItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartOperationInspectionItemInclude | null
    /**
     * Filter which PartOperationInspectionItem to delete.
     */
    where: PartOperationInspectionItemWhereUniqueInput
  }


  /**
   * PartOperationInspectionItem deleteMany
   */
  export type PartOperationInspectionItemDeleteManyArgs = {
    /**
     * Filter which PartOperationInspectionItems to delete
     */
    where?: PartOperationInspectionItemWhereInput
  }


  /**
   * PartOperationInspectionItem.operationInspectionRecordItems
   */
  export type PartOperationInspectionItem$operationInspectionRecordItemsArgs = {
    /**
     * Select specific fields to fetch from the OperationInspectionRecordItem
     */
    select?: OperationInspectionRecordItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OperationInspectionRecordItemInclude | null
    where?: OperationInspectionRecordItemWhereInput
    orderBy?: Enumerable<OperationInspectionRecordItemOrderByWithRelationInput>
    cursor?: OperationInspectionRecordItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<OperationInspectionRecordItemScalarFieldEnum>
  }


  /**
   * PartOperationInspectionItem without action
   */
  export type PartOperationInspectionItemArgs = {
    /**
     * Select specific fields to fetch from the PartOperationInspectionItem
     */
    select?: PartOperationInspectionItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PartOperationInspectionItemInclude | null
  }



  /**
   * Model Receipt
   */


  export type AggregateReceipt = {
    _count: ReceiptCountAggregateOutputType | null
    _avg: ReceiptAvgAggregateOutputType | null
    _sum: ReceiptSumAggregateOutputType | null
    _min: ReceiptMinAggregateOutputType | null
    _max: ReceiptMaxAggregateOutputType | null
  }

  export type ReceiptAvgAggregateOutputType = {
    id: number | null
    partVersionId: number | null
  }

  export type ReceiptSumAggregateOutputType = {
    id: number | null
    partVersionId: number | null
  }

  export type ReceiptMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    lot: string | null
    partVersionId: number | null
  }

  export type ReceiptMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    lot: string | null
    partVersionId: number | null
  }

  export type ReceiptCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    isDeleted: number
    lot: number
    partVersionId: number
    _all: number
  }


  export type ReceiptAvgAggregateInputType = {
    id?: true
    partVersionId?: true
  }

  export type ReceiptSumAggregateInputType = {
    id?: true
    partVersionId?: true
  }

  export type ReceiptMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    lot?: true
    partVersionId?: true
  }

  export type ReceiptMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    lot?: true
    partVersionId?: true
  }

  export type ReceiptCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    lot?: true
    partVersionId?: true
    _all?: true
  }

  export type ReceiptAggregateArgs = {
    /**
     * Filter which Receipt to aggregate.
     */
    where?: ReceiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Receipts to fetch.
     */
    orderBy?: Enumerable<ReceiptOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReceiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Receipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Receipts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Receipts
    **/
    _count?: true | ReceiptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReceiptAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReceiptSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReceiptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReceiptMaxAggregateInputType
  }

  export type GetReceiptAggregateType<T extends ReceiptAggregateArgs> = {
        [P in keyof T & keyof AggregateReceipt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReceipt[P]>
      : GetScalarType<T[P], AggregateReceipt[P]>
  }




  export type ReceiptGroupByArgs = {
    where?: ReceiptWhereInput
    orderBy?: Enumerable<ReceiptOrderByWithAggregationInput>
    by: ReceiptScalarFieldEnum[]
    having?: ReceiptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReceiptCountAggregateInputType | true
    _avg?: ReceiptAvgAggregateInputType
    _sum?: ReceiptSumAggregateInputType
    _min?: ReceiptMinAggregateInputType
    _max?: ReceiptMaxAggregateInputType
  }


  export type ReceiptGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    isDeleted: boolean
    lot: string
    partVersionId: number
    _count: ReceiptCountAggregateOutputType | null
    _avg: ReceiptAvgAggregateOutputType | null
    _sum: ReceiptSumAggregateOutputType | null
    _min: ReceiptMinAggregateOutputType | null
    _max: ReceiptMaxAggregateOutputType | null
  }

  type GetReceiptGroupByPayload<T extends ReceiptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ReceiptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReceiptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReceiptGroupByOutputType[P]>
            : GetScalarType<T[P], ReceiptGroupByOutputType[P]>
        }
      >
    >


  export type ReceiptSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    lot?: boolean
    partVersionId?: boolean
    partVersion?: boolean | PartVersionArgs
    incomingInspectionRecord?: boolean | IncomingInspectionRecordArgs
  }


  export type ReceiptInclude = {
    partVersion?: boolean | PartVersionArgs
    incomingInspectionRecord?: boolean | IncomingInspectionRecordArgs
  }

  export type ReceiptGetPayload<S extends boolean | null | undefined | ReceiptArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Receipt :
    S extends undefined ? never :
    S extends { include: any } & (ReceiptArgs | ReceiptFindManyArgs)
    ? Receipt  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'partVersion' ? PartVersionGetPayload<S['include'][P]> :
        P extends 'incomingInspectionRecord' ? IncomingInspectionRecordGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (ReceiptArgs | ReceiptFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'partVersion' ? PartVersionGetPayload<S['select'][P]> :
        P extends 'incomingInspectionRecord' ? IncomingInspectionRecordGetPayload<S['select'][P]> | null :  P extends keyof Receipt ? Receipt[P] : never
  } 
      : Receipt


  type ReceiptCountArgs = 
    Omit<ReceiptFindManyArgs, 'select' | 'include'> & {
      select?: ReceiptCountAggregateInputType | true
    }

  export interface ReceiptDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Receipt that matches the filter.
     * @param {ReceiptFindUniqueArgs} args - Arguments to find a Receipt
     * @example
     * // Get one Receipt
     * const receipt = await prisma.receipt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ReceiptFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ReceiptFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Receipt'> extends True ? Prisma__ReceiptClient<ReceiptGetPayload<T>> : Prisma__ReceiptClient<ReceiptGetPayload<T> | null, null>

    /**
     * Find one Receipt that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ReceiptFindUniqueOrThrowArgs} args - Arguments to find a Receipt
     * @example
     * // Get one Receipt
     * const receipt = await prisma.receipt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ReceiptFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ReceiptFindUniqueOrThrowArgs>
    ): Prisma__ReceiptClient<ReceiptGetPayload<T>>

    /**
     * Find the first Receipt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptFindFirstArgs} args - Arguments to find a Receipt
     * @example
     * // Get one Receipt
     * const receipt = await prisma.receipt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ReceiptFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ReceiptFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Receipt'> extends True ? Prisma__ReceiptClient<ReceiptGetPayload<T>> : Prisma__ReceiptClient<ReceiptGetPayload<T> | null, null>

    /**
     * Find the first Receipt that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptFindFirstOrThrowArgs} args - Arguments to find a Receipt
     * @example
     * // Get one Receipt
     * const receipt = await prisma.receipt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ReceiptFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ReceiptFindFirstOrThrowArgs>
    ): Prisma__ReceiptClient<ReceiptGetPayload<T>>

    /**
     * Find zero or more Receipts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Receipts
     * const receipts = await prisma.receipt.findMany()
     * 
     * // Get first 10 Receipts
     * const receipts = await prisma.receipt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const receiptWithIdOnly = await prisma.receipt.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ReceiptFindManyArgs>(
      args?: SelectSubset<T, ReceiptFindManyArgs>
    ): Prisma.PrismaPromise<Array<ReceiptGetPayload<T>>>

    /**
     * Create a Receipt.
     * @param {ReceiptCreateArgs} args - Arguments to create a Receipt.
     * @example
     * // Create one Receipt
     * const Receipt = await prisma.receipt.create({
     *   data: {
     *     // ... data to create a Receipt
     *   }
     * })
     * 
    **/
    create<T extends ReceiptCreateArgs>(
      args: SelectSubset<T, ReceiptCreateArgs>
    ): Prisma__ReceiptClient<ReceiptGetPayload<T>>

    /**
     * Create many Receipts.
     *     @param {ReceiptCreateManyArgs} args - Arguments to create many Receipts.
     *     @example
     *     // Create many Receipts
     *     const receipt = await prisma.receipt.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ReceiptCreateManyArgs>(
      args?: SelectSubset<T, ReceiptCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Receipt.
     * @param {ReceiptDeleteArgs} args - Arguments to delete one Receipt.
     * @example
     * // Delete one Receipt
     * const Receipt = await prisma.receipt.delete({
     *   where: {
     *     // ... filter to delete one Receipt
     *   }
     * })
     * 
    **/
    delete<T extends ReceiptDeleteArgs>(
      args: SelectSubset<T, ReceiptDeleteArgs>
    ): Prisma__ReceiptClient<ReceiptGetPayload<T>>

    /**
     * Update one Receipt.
     * @param {ReceiptUpdateArgs} args - Arguments to update one Receipt.
     * @example
     * // Update one Receipt
     * const receipt = await prisma.receipt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ReceiptUpdateArgs>(
      args: SelectSubset<T, ReceiptUpdateArgs>
    ): Prisma__ReceiptClient<ReceiptGetPayload<T>>

    /**
     * Delete zero or more Receipts.
     * @param {ReceiptDeleteManyArgs} args - Arguments to filter Receipts to delete.
     * @example
     * // Delete a few Receipts
     * const { count } = await prisma.receipt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ReceiptDeleteManyArgs>(
      args?: SelectSubset<T, ReceiptDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Receipts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Receipts
     * const receipt = await prisma.receipt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ReceiptUpdateManyArgs>(
      args: SelectSubset<T, ReceiptUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Receipt.
     * @param {ReceiptUpsertArgs} args - Arguments to update or create a Receipt.
     * @example
     * // Update or create a Receipt
     * const receipt = await prisma.receipt.upsert({
     *   create: {
     *     // ... data to create a Receipt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Receipt we want to update
     *   }
     * })
    **/
    upsert<T extends ReceiptUpsertArgs>(
      args: SelectSubset<T, ReceiptUpsertArgs>
    ): Prisma__ReceiptClient<ReceiptGetPayload<T>>

    /**
     * Count the number of Receipts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptCountArgs} args - Arguments to filter Receipts to count.
     * @example
     * // Count the number of Receipts
     * const count = await prisma.receipt.count({
     *   where: {
     *     // ... the filter for the Receipts we want to count
     *   }
     * })
    **/
    count<T extends ReceiptCountArgs>(
      args?: Subset<T, ReceiptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReceiptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Receipt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReceiptAggregateArgs>(args: Subset<T, ReceiptAggregateArgs>): Prisma.PrismaPromise<GetReceiptAggregateType<T>>

    /**
     * Group by Receipt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReceiptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReceiptGroupByArgs['orderBy'] }
        : { orderBy?: ReceiptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReceiptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReceiptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Receipt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ReceiptClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    partVersion<T extends PartVersionArgs= {}>(args?: Subset<T, PartVersionArgs>): Prisma__PartVersionClient<PartVersionGetPayload<T> | Null>;

    incomingInspectionRecord<T extends IncomingInspectionRecordArgs= {}>(args?: Subset<T, IncomingInspectionRecordArgs>): Prisma__IncomingInspectionRecordClient<IncomingInspectionRecordGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Receipt base type for findUnique actions
   */
  export type ReceiptFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReceiptInclude | null
    /**
     * Filter, which Receipt to fetch.
     */
    where: ReceiptWhereUniqueInput
  }

  /**
   * Receipt findUnique
   */
  export interface ReceiptFindUniqueArgs extends ReceiptFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Receipt findUniqueOrThrow
   */
  export type ReceiptFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReceiptInclude | null
    /**
     * Filter, which Receipt to fetch.
     */
    where: ReceiptWhereUniqueInput
  }


  /**
   * Receipt base type for findFirst actions
   */
  export type ReceiptFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReceiptInclude | null
    /**
     * Filter, which Receipt to fetch.
     */
    where?: ReceiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Receipts to fetch.
     */
    orderBy?: Enumerable<ReceiptOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Receipts.
     */
    cursor?: ReceiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Receipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Receipts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Receipts.
     */
    distinct?: Enumerable<ReceiptScalarFieldEnum>
  }

  /**
   * Receipt findFirst
   */
  export interface ReceiptFindFirstArgs extends ReceiptFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Receipt findFirstOrThrow
   */
  export type ReceiptFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReceiptInclude | null
    /**
     * Filter, which Receipt to fetch.
     */
    where?: ReceiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Receipts to fetch.
     */
    orderBy?: Enumerable<ReceiptOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Receipts.
     */
    cursor?: ReceiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Receipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Receipts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Receipts.
     */
    distinct?: Enumerable<ReceiptScalarFieldEnum>
  }


  /**
   * Receipt findMany
   */
  export type ReceiptFindManyArgs = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReceiptInclude | null
    /**
     * Filter, which Receipts to fetch.
     */
    where?: ReceiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Receipts to fetch.
     */
    orderBy?: Enumerable<ReceiptOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Receipts.
     */
    cursor?: ReceiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Receipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Receipts.
     */
    skip?: number
    distinct?: Enumerable<ReceiptScalarFieldEnum>
  }


  /**
   * Receipt create
   */
  export type ReceiptCreateArgs = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReceiptInclude | null
    /**
     * The data needed to create a Receipt.
     */
    data: XOR<ReceiptCreateInput, ReceiptUncheckedCreateInput>
  }


  /**
   * Receipt createMany
   */
  export type ReceiptCreateManyArgs = {
    /**
     * The data used to create many Receipts.
     */
    data: Enumerable<ReceiptCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Receipt update
   */
  export type ReceiptUpdateArgs = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReceiptInclude | null
    /**
     * The data needed to update a Receipt.
     */
    data: XOR<ReceiptUpdateInput, ReceiptUncheckedUpdateInput>
    /**
     * Choose, which Receipt to update.
     */
    where: ReceiptWhereUniqueInput
  }


  /**
   * Receipt updateMany
   */
  export type ReceiptUpdateManyArgs = {
    /**
     * The data used to update Receipts.
     */
    data: XOR<ReceiptUpdateManyMutationInput, ReceiptUncheckedUpdateManyInput>
    /**
     * Filter which Receipts to update
     */
    where?: ReceiptWhereInput
  }


  /**
   * Receipt upsert
   */
  export type ReceiptUpsertArgs = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReceiptInclude | null
    /**
     * The filter to search for the Receipt to update in case it exists.
     */
    where: ReceiptWhereUniqueInput
    /**
     * In case the Receipt found by the `where` argument doesn't exist, create a new Receipt with this data.
     */
    create: XOR<ReceiptCreateInput, ReceiptUncheckedCreateInput>
    /**
     * In case the Receipt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReceiptUpdateInput, ReceiptUncheckedUpdateInput>
  }


  /**
   * Receipt delete
   */
  export type ReceiptDeleteArgs = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReceiptInclude | null
    /**
     * Filter which Receipt to delete.
     */
    where: ReceiptWhereUniqueInput
  }


  /**
   * Receipt deleteMany
   */
  export type ReceiptDeleteManyArgs = {
    /**
     * Filter which Receipts to delete
     */
    where?: ReceiptWhereInput
  }


  /**
   * Receipt without action
   */
  export type ReceiptArgs = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReceiptInclude | null
  }



  /**
   * Model IncomingInspectionRecord
   */


  export type AggregateIncomingInspectionRecord = {
    _count: IncomingInspectionRecordCountAggregateOutputType | null
    _avg: IncomingInspectionRecordAvgAggregateOutputType | null
    _sum: IncomingInspectionRecordSumAggregateOutputType | null
    _min: IncomingInspectionRecordMinAggregateOutputType | null
    _max: IncomingInspectionRecordMaxAggregateOutputType | null
  }

  export type IncomingInspectionRecordAvgAggregateOutputType = {
    id: number | null
    receiptId: number | null
    incomingInspectionSpecId: number | null
  }

  export type IncomingInspectionRecordSumAggregateOutputType = {
    id: number | null
    receiptId: number | null
    incomingInspectionSpecId: number | null
  }

  export type IncomingInspectionRecordMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    note: string | null
    result: IncomingInspectionResult | null
    receiptId: number | null
    incomingInspectionSpecId: number | null
  }

  export type IncomingInspectionRecordMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    note: string | null
    result: IncomingInspectionResult | null
    receiptId: number | null
    incomingInspectionSpecId: number | null
  }

  export type IncomingInspectionRecordCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    isDeleted: number
    note: number
    result: number
    receiptId: number
    incomingInspectionSpecId: number
    _all: number
  }


  export type IncomingInspectionRecordAvgAggregateInputType = {
    id?: true
    receiptId?: true
    incomingInspectionSpecId?: true
  }

  export type IncomingInspectionRecordSumAggregateInputType = {
    id?: true
    receiptId?: true
    incomingInspectionSpecId?: true
  }

  export type IncomingInspectionRecordMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    note?: true
    result?: true
    receiptId?: true
    incomingInspectionSpecId?: true
  }

  export type IncomingInspectionRecordMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    note?: true
    result?: true
    receiptId?: true
    incomingInspectionSpecId?: true
  }

  export type IncomingInspectionRecordCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    note?: true
    result?: true
    receiptId?: true
    incomingInspectionSpecId?: true
    _all?: true
  }

  export type IncomingInspectionRecordAggregateArgs = {
    /**
     * Filter which IncomingInspectionRecord to aggregate.
     */
    where?: IncomingInspectionRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncomingInspectionRecords to fetch.
     */
    orderBy?: Enumerable<IncomingInspectionRecordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IncomingInspectionRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncomingInspectionRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncomingInspectionRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IncomingInspectionRecords
    **/
    _count?: true | IncomingInspectionRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IncomingInspectionRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IncomingInspectionRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IncomingInspectionRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IncomingInspectionRecordMaxAggregateInputType
  }

  export type GetIncomingInspectionRecordAggregateType<T extends IncomingInspectionRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateIncomingInspectionRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIncomingInspectionRecord[P]>
      : GetScalarType<T[P], AggregateIncomingInspectionRecord[P]>
  }




  export type IncomingInspectionRecordGroupByArgs = {
    where?: IncomingInspectionRecordWhereInput
    orderBy?: Enumerable<IncomingInspectionRecordOrderByWithAggregationInput>
    by: IncomingInspectionRecordScalarFieldEnum[]
    having?: IncomingInspectionRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IncomingInspectionRecordCountAggregateInputType | true
    _avg?: IncomingInspectionRecordAvgAggregateInputType
    _sum?: IncomingInspectionRecordSumAggregateInputType
    _min?: IncomingInspectionRecordMinAggregateInputType
    _max?: IncomingInspectionRecordMaxAggregateInputType
  }


  export type IncomingInspectionRecordGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    isDeleted: boolean
    note: string
    result: IncomingInspectionResult
    receiptId: number
    incomingInspectionSpecId: number
    _count: IncomingInspectionRecordCountAggregateOutputType | null
    _avg: IncomingInspectionRecordAvgAggregateOutputType | null
    _sum: IncomingInspectionRecordSumAggregateOutputType | null
    _min: IncomingInspectionRecordMinAggregateOutputType | null
    _max: IncomingInspectionRecordMaxAggregateOutputType | null
  }

  type GetIncomingInspectionRecordGroupByPayload<T extends IncomingInspectionRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<IncomingInspectionRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IncomingInspectionRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IncomingInspectionRecordGroupByOutputType[P]>
            : GetScalarType<T[P], IncomingInspectionRecordGroupByOutputType[P]>
        }
      >
    >


  export type IncomingInspectionRecordSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    note?: boolean
    result?: boolean
    receiptId?: boolean
    incomingInspectionSpecId?: boolean
    receipt?: boolean | ReceiptArgs
    incomingInspectionSpec?: boolean | IncomingInspectionSpecArgs
    incomingInspectionRecordItems?: boolean | IncomingInspectionRecord$incomingInspectionRecordItemsArgs
    _count?: boolean | IncomingInspectionRecordCountOutputTypeArgs
  }


  export type IncomingInspectionRecordInclude = {
    receipt?: boolean | ReceiptArgs
    incomingInspectionSpec?: boolean | IncomingInspectionSpecArgs
    incomingInspectionRecordItems?: boolean | IncomingInspectionRecord$incomingInspectionRecordItemsArgs
    _count?: boolean | IncomingInspectionRecordCountOutputTypeArgs
  }

  export type IncomingInspectionRecordGetPayload<S extends boolean | null | undefined | IncomingInspectionRecordArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? IncomingInspectionRecord :
    S extends undefined ? never :
    S extends { include: any } & (IncomingInspectionRecordArgs | IncomingInspectionRecordFindManyArgs)
    ? IncomingInspectionRecord  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'receipt' ? ReceiptGetPayload<S['include'][P]> :
        P extends 'incomingInspectionSpec' ? IncomingInspectionSpecGetPayload<S['include'][P]> :
        P extends 'incomingInspectionRecordItems' ? Array < IncomingInspectionRecordItemGetPayload<S['include'][P]>>  :
        P extends '_count' ? IncomingInspectionRecordCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (IncomingInspectionRecordArgs | IncomingInspectionRecordFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'receipt' ? ReceiptGetPayload<S['select'][P]> :
        P extends 'incomingInspectionSpec' ? IncomingInspectionSpecGetPayload<S['select'][P]> :
        P extends 'incomingInspectionRecordItems' ? Array < IncomingInspectionRecordItemGetPayload<S['select'][P]>>  :
        P extends '_count' ? IncomingInspectionRecordCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof IncomingInspectionRecord ? IncomingInspectionRecord[P] : never
  } 
      : IncomingInspectionRecord


  type IncomingInspectionRecordCountArgs = 
    Omit<IncomingInspectionRecordFindManyArgs, 'select' | 'include'> & {
      select?: IncomingInspectionRecordCountAggregateInputType | true
    }

  export interface IncomingInspectionRecordDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one IncomingInspectionRecord that matches the filter.
     * @param {IncomingInspectionRecordFindUniqueArgs} args - Arguments to find a IncomingInspectionRecord
     * @example
     * // Get one IncomingInspectionRecord
     * const incomingInspectionRecord = await prisma.incomingInspectionRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends IncomingInspectionRecordFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, IncomingInspectionRecordFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'IncomingInspectionRecord'> extends True ? Prisma__IncomingInspectionRecordClient<IncomingInspectionRecordGetPayload<T>> : Prisma__IncomingInspectionRecordClient<IncomingInspectionRecordGetPayload<T> | null, null>

    /**
     * Find one IncomingInspectionRecord that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {IncomingInspectionRecordFindUniqueOrThrowArgs} args - Arguments to find a IncomingInspectionRecord
     * @example
     * // Get one IncomingInspectionRecord
     * const incomingInspectionRecord = await prisma.incomingInspectionRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends IncomingInspectionRecordFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, IncomingInspectionRecordFindUniqueOrThrowArgs>
    ): Prisma__IncomingInspectionRecordClient<IncomingInspectionRecordGetPayload<T>>

    /**
     * Find the first IncomingInspectionRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomingInspectionRecordFindFirstArgs} args - Arguments to find a IncomingInspectionRecord
     * @example
     * // Get one IncomingInspectionRecord
     * const incomingInspectionRecord = await prisma.incomingInspectionRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends IncomingInspectionRecordFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, IncomingInspectionRecordFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'IncomingInspectionRecord'> extends True ? Prisma__IncomingInspectionRecordClient<IncomingInspectionRecordGetPayload<T>> : Prisma__IncomingInspectionRecordClient<IncomingInspectionRecordGetPayload<T> | null, null>

    /**
     * Find the first IncomingInspectionRecord that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomingInspectionRecordFindFirstOrThrowArgs} args - Arguments to find a IncomingInspectionRecord
     * @example
     * // Get one IncomingInspectionRecord
     * const incomingInspectionRecord = await prisma.incomingInspectionRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends IncomingInspectionRecordFindFirstOrThrowArgs>(
      args?: SelectSubset<T, IncomingInspectionRecordFindFirstOrThrowArgs>
    ): Prisma__IncomingInspectionRecordClient<IncomingInspectionRecordGetPayload<T>>

    /**
     * Find zero or more IncomingInspectionRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomingInspectionRecordFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IncomingInspectionRecords
     * const incomingInspectionRecords = await prisma.incomingInspectionRecord.findMany()
     * 
     * // Get first 10 IncomingInspectionRecords
     * const incomingInspectionRecords = await prisma.incomingInspectionRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const incomingInspectionRecordWithIdOnly = await prisma.incomingInspectionRecord.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends IncomingInspectionRecordFindManyArgs>(
      args?: SelectSubset<T, IncomingInspectionRecordFindManyArgs>
    ): Prisma.PrismaPromise<Array<IncomingInspectionRecordGetPayload<T>>>

    /**
     * Create a IncomingInspectionRecord.
     * @param {IncomingInspectionRecordCreateArgs} args - Arguments to create a IncomingInspectionRecord.
     * @example
     * // Create one IncomingInspectionRecord
     * const IncomingInspectionRecord = await prisma.incomingInspectionRecord.create({
     *   data: {
     *     // ... data to create a IncomingInspectionRecord
     *   }
     * })
     * 
    **/
    create<T extends IncomingInspectionRecordCreateArgs>(
      args: SelectSubset<T, IncomingInspectionRecordCreateArgs>
    ): Prisma__IncomingInspectionRecordClient<IncomingInspectionRecordGetPayload<T>>

    /**
     * Create many IncomingInspectionRecords.
     *     @param {IncomingInspectionRecordCreateManyArgs} args - Arguments to create many IncomingInspectionRecords.
     *     @example
     *     // Create many IncomingInspectionRecords
     *     const incomingInspectionRecord = await prisma.incomingInspectionRecord.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends IncomingInspectionRecordCreateManyArgs>(
      args?: SelectSubset<T, IncomingInspectionRecordCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a IncomingInspectionRecord.
     * @param {IncomingInspectionRecordDeleteArgs} args - Arguments to delete one IncomingInspectionRecord.
     * @example
     * // Delete one IncomingInspectionRecord
     * const IncomingInspectionRecord = await prisma.incomingInspectionRecord.delete({
     *   where: {
     *     // ... filter to delete one IncomingInspectionRecord
     *   }
     * })
     * 
    **/
    delete<T extends IncomingInspectionRecordDeleteArgs>(
      args: SelectSubset<T, IncomingInspectionRecordDeleteArgs>
    ): Prisma__IncomingInspectionRecordClient<IncomingInspectionRecordGetPayload<T>>

    /**
     * Update one IncomingInspectionRecord.
     * @param {IncomingInspectionRecordUpdateArgs} args - Arguments to update one IncomingInspectionRecord.
     * @example
     * // Update one IncomingInspectionRecord
     * const incomingInspectionRecord = await prisma.incomingInspectionRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends IncomingInspectionRecordUpdateArgs>(
      args: SelectSubset<T, IncomingInspectionRecordUpdateArgs>
    ): Prisma__IncomingInspectionRecordClient<IncomingInspectionRecordGetPayload<T>>

    /**
     * Delete zero or more IncomingInspectionRecords.
     * @param {IncomingInspectionRecordDeleteManyArgs} args - Arguments to filter IncomingInspectionRecords to delete.
     * @example
     * // Delete a few IncomingInspectionRecords
     * const { count } = await prisma.incomingInspectionRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends IncomingInspectionRecordDeleteManyArgs>(
      args?: SelectSubset<T, IncomingInspectionRecordDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IncomingInspectionRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomingInspectionRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IncomingInspectionRecords
     * const incomingInspectionRecord = await prisma.incomingInspectionRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends IncomingInspectionRecordUpdateManyArgs>(
      args: SelectSubset<T, IncomingInspectionRecordUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one IncomingInspectionRecord.
     * @param {IncomingInspectionRecordUpsertArgs} args - Arguments to update or create a IncomingInspectionRecord.
     * @example
     * // Update or create a IncomingInspectionRecord
     * const incomingInspectionRecord = await prisma.incomingInspectionRecord.upsert({
     *   create: {
     *     // ... data to create a IncomingInspectionRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IncomingInspectionRecord we want to update
     *   }
     * })
    **/
    upsert<T extends IncomingInspectionRecordUpsertArgs>(
      args: SelectSubset<T, IncomingInspectionRecordUpsertArgs>
    ): Prisma__IncomingInspectionRecordClient<IncomingInspectionRecordGetPayload<T>>

    /**
     * Count the number of IncomingInspectionRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomingInspectionRecordCountArgs} args - Arguments to filter IncomingInspectionRecords to count.
     * @example
     * // Count the number of IncomingInspectionRecords
     * const count = await prisma.incomingInspectionRecord.count({
     *   where: {
     *     // ... the filter for the IncomingInspectionRecords we want to count
     *   }
     * })
    **/
    count<T extends IncomingInspectionRecordCountArgs>(
      args?: Subset<T, IncomingInspectionRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IncomingInspectionRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IncomingInspectionRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomingInspectionRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IncomingInspectionRecordAggregateArgs>(args: Subset<T, IncomingInspectionRecordAggregateArgs>): Prisma.PrismaPromise<GetIncomingInspectionRecordAggregateType<T>>

    /**
     * Group by IncomingInspectionRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomingInspectionRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IncomingInspectionRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IncomingInspectionRecordGroupByArgs['orderBy'] }
        : { orderBy?: IncomingInspectionRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IncomingInspectionRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIncomingInspectionRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for IncomingInspectionRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__IncomingInspectionRecordClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    receipt<T extends ReceiptArgs= {}>(args?: Subset<T, ReceiptArgs>): Prisma__ReceiptClient<ReceiptGetPayload<T> | Null>;

    incomingInspectionSpec<T extends IncomingInspectionSpecArgs= {}>(args?: Subset<T, IncomingInspectionSpecArgs>): Prisma__IncomingInspectionSpecClient<IncomingInspectionSpecGetPayload<T> | Null>;

    incomingInspectionRecordItems<T extends IncomingInspectionRecord$incomingInspectionRecordItemsArgs= {}>(args?: Subset<T, IncomingInspectionRecord$incomingInspectionRecordItemsArgs>): Prisma.PrismaPromise<Array<IncomingInspectionRecordItemGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * IncomingInspectionRecord base type for findUnique actions
   */
  export type IncomingInspectionRecordFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the IncomingInspectionRecord
     */
    select?: IncomingInspectionRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IncomingInspectionRecordInclude | null
    /**
     * Filter, which IncomingInspectionRecord to fetch.
     */
    where: IncomingInspectionRecordWhereUniqueInput
  }

  /**
   * IncomingInspectionRecord findUnique
   */
  export interface IncomingInspectionRecordFindUniqueArgs extends IncomingInspectionRecordFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * IncomingInspectionRecord findUniqueOrThrow
   */
  export type IncomingInspectionRecordFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the IncomingInspectionRecord
     */
    select?: IncomingInspectionRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IncomingInspectionRecordInclude | null
    /**
     * Filter, which IncomingInspectionRecord to fetch.
     */
    where: IncomingInspectionRecordWhereUniqueInput
  }


  /**
   * IncomingInspectionRecord base type for findFirst actions
   */
  export type IncomingInspectionRecordFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the IncomingInspectionRecord
     */
    select?: IncomingInspectionRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IncomingInspectionRecordInclude | null
    /**
     * Filter, which IncomingInspectionRecord to fetch.
     */
    where?: IncomingInspectionRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncomingInspectionRecords to fetch.
     */
    orderBy?: Enumerable<IncomingInspectionRecordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IncomingInspectionRecords.
     */
    cursor?: IncomingInspectionRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncomingInspectionRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncomingInspectionRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IncomingInspectionRecords.
     */
    distinct?: Enumerable<IncomingInspectionRecordScalarFieldEnum>
  }

  /**
   * IncomingInspectionRecord findFirst
   */
  export interface IncomingInspectionRecordFindFirstArgs extends IncomingInspectionRecordFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * IncomingInspectionRecord findFirstOrThrow
   */
  export type IncomingInspectionRecordFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the IncomingInspectionRecord
     */
    select?: IncomingInspectionRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IncomingInspectionRecordInclude | null
    /**
     * Filter, which IncomingInspectionRecord to fetch.
     */
    where?: IncomingInspectionRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncomingInspectionRecords to fetch.
     */
    orderBy?: Enumerable<IncomingInspectionRecordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IncomingInspectionRecords.
     */
    cursor?: IncomingInspectionRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncomingInspectionRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncomingInspectionRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IncomingInspectionRecords.
     */
    distinct?: Enumerable<IncomingInspectionRecordScalarFieldEnum>
  }


  /**
   * IncomingInspectionRecord findMany
   */
  export type IncomingInspectionRecordFindManyArgs = {
    /**
     * Select specific fields to fetch from the IncomingInspectionRecord
     */
    select?: IncomingInspectionRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IncomingInspectionRecordInclude | null
    /**
     * Filter, which IncomingInspectionRecords to fetch.
     */
    where?: IncomingInspectionRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncomingInspectionRecords to fetch.
     */
    orderBy?: Enumerable<IncomingInspectionRecordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IncomingInspectionRecords.
     */
    cursor?: IncomingInspectionRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncomingInspectionRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncomingInspectionRecords.
     */
    skip?: number
    distinct?: Enumerable<IncomingInspectionRecordScalarFieldEnum>
  }


  /**
   * IncomingInspectionRecord create
   */
  export type IncomingInspectionRecordCreateArgs = {
    /**
     * Select specific fields to fetch from the IncomingInspectionRecord
     */
    select?: IncomingInspectionRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IncomingInspectionRecordInclude | null
    /**
     * The data needed to create a IncomingInspectionRecord.
     */
    data: XOR<IncomingInspectionRecordCreateInput, IncomingInspectionRecordUncheckedCreateInput>
  }


  /**
   * IncomingInspectionRecord createMany
   */
  export type IncomingInspectionRecordCreateManyArgs = {
    /**
     * The data used to create many IncomingInspectionRecords.
     */
    data: Enumerable<IncomingInspectionRecordCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * IncomingInspectionRecord update
   */
  export type IncomingInspectionRecordUpdateArgs = {
    /**
     * Select specific fields to fetch from the IncomingInspectionRecord
     */
    select?: IncomingInspectionRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IncomingInspectionRecordInclude | null
    /**
     * The data needed to update a IncomingInspectionRecord.
     */
    data: XOR<IncomingInspectionRecordUpdateInput, IncomingInspectionRecordUncheckedUpdateInput>
    /**
     * Choose, which IncomingInspectionRecord to update.
     */
    where: IncomingInspectionRecordWhereUniqueInput
  }


  /**
   * IncomingInspectionRecord updateMany
   */
  export type IncomingInspectionRecordUpdateManyArgs = {
    /**
     * The data used to update IncomingInspectionRecords.
     */
    data: XOR<IncomingInspectionRecordUpdateManyMutationInput, IncomingInspectionRecordUncheckedUpdateManyInput>
    /**
     * Filter which IncomingInspectionRecords to update
     */
    where?: IncomingInspectionRecordWhereInput
  }


  /**
   * IncomingInspectionRecord upsert
   */
  export type IncomingInspectionRecordUpsertArgs = {
    /**
     * Select specific fields to fetch from the IncomingInspectionRecord
     */
    select?: IncomingInspectionRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IncomingInspectionRecordInclude | null
    /**
     * The filter to search for the IncomingInspectionRecord to update in case it exists.
     */
    where: IncomingInspectionRecordWhereUniqueInput
    /**
     * In case the IncomingInspectionRecord found by the `where` argument doesn't exist, create a new IncomingInspectionRecord with this data.
     */
    create: XOR<IncomingInspectionRecordCreateInput, IncomingInspectionRecordUncheckedCreateInput>
    /**
     * In case the IncomingInspectionRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IncomingInspectionRecordUpdateInput, IncomingInspectionRecordUncheckedUpdateInput>
  }


  /**
   * IncomingInspectionRecord delete
   */
  export type IncomingInspectionRecordDeleteArgs = {
    /**
     * Select specific fields to fetch from the IncomingInspectionRecord
     */
    select?: IncomingInspectionRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IncomingInspectionRecordInclude | null
    /**
     * Filter which IncomingInspectionRecord to delete.
     */
    where: IncomingInspectionRecordWhereUniqueInput
  }


  /**
   * IncomingInspectionRecord deleteMany
   */
  export type IncomingInspectionRecordDeleteManyArgs = {
    /**
     * Filter which IncomingInspectionRecords to delete
     */
    where?: IncomingInspectionRecordWhereInput
  }


  /**
   * IncomingInspectionRecord.incomingInspectionRecordItems
   */
  export type IncomingInspectionRecord$incomingInspectionRecordItemsArgs = {
    /**
     * Select specific fields to fetch from the IncomingInspectionRecordItem
     */
    select?: IncomingInspectionRecordItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IncomingInspectionRecordItemInclude | null
    where?: IncomingInspectionRecordItemWhereInput
    orderBy?: Enumerable<IncomingInspectionRecordItemOrderByWithRelationInput>
    cursor?: IncomingInspectionRecordItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<IncomingInspectionRecordItemScalarFieldEnum>
  }


  /**
   * IncomingInspectionRecord without action
   */
  export type IncomingInspectionRecordArgs = {
    /**
     * Select specific fields to fetch from the IncomingInspectionRecord
     */
    select?: IncomingInspectionRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IncomingInspectionRecordInclude | null
  }



  /**
   * Model IncomingInspectionRecordItem
   */


  export type AggregateIncomingInspectionRecordItem = {
    _count: IncomingInspectionRecordItemCountAggregateOutputType | null
    _avg: IncomingInspectionRecordItemAvgAggregateOutputType | null
    _sum: IncomingInspectionRecordItemSumAggregateOutputType | null
    _min: IncomingInspectionRecordItemMinAggregateOutputType | null
    _max: IncomingInspectionRecordItemMaxAggregateOutputType | null
  }

  export type IncomingInspectionRecordItemAvgAggregateOutputType = {
    id: number | null
    incomingInspectionRecordId: number | null
    incomingInspectionSpecItemId: number | null
  }

  export type IncomingInspectionRecordItemSumAggregateOutputType = {
    id: number | null
    incomingInspectionRecordId: number | null
    incomingInspectionSpecItemId: number | null
  }

  export type IncomingInspectionRecordItemMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    result: boolean | null
    inspectionIteration: string | null
    incomingInspectionRecordId: number | null
    incomingInspectionSpecItemId: number | null
  }

  export type IncomingInspectionRecordItemMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    result: boolean | null
    inspectionIteration: string | null
    incomingInspectionRecordId: number | null
    incomingInspectionSpecItemId: number | null
  }

  export type IncomingInspectionRecordItemCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    isDeleted: number
    result: number
    inspectionIteration: number
    incomingInspectionRecordId: number
    incomingInspectionSpecItemId: number
    _all: number
  }


  export type IncomingInspectionRecordItemAvgAggregateInputType = {
    id?: true
    incomingInspectionRecordId?: true
    incomingInspectionSpecItemId?: true
  }

  export type IncomingInspectionRecordItemSumAggregateInputType = {
    id?: true
    incomingInspectionRecordId?: true
    incomingInspectionSpecItemId?: true
  }

  export type IncomingInspectionRecordItemMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    result?: true
    inspectionIteration?: true
    incomingInspectionRecordId?: true
    incomingInspectionSpecItemId?: true
  }

  export type IncomingInspectionRecordItemMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    result?: true
    inspectionIteration?: true
    incomingInspectionRecordId?: true
    incomingInspectionSpecItemId?: true
  }

  export type IncomingInspectionRecordItemCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    result?: true
    inspectionIteration?: true
    incomingInspectionRecordId?: true
    incomingInspectionSpecItemId?: true
    _all?: true
  }

  export type IncomingInspectionRecordItemAggregateArgs = {
    /**
     * Filter which IncomingInspectionRecordItem to aggregate.
     */
    where?: IncomingInspectionRecordItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncomingInspectionRecordItems to fetch.
     */
    orderBy?: Enumerable<IncomingInspectionRecordItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IncomingInspectionRecordItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncomingInspectionRecordItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncomingInspectionRecordItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IncomingInspectionRecordItems
    **/
    _count?: true | IncomingInspectionRecordItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IncomingInspectionRecordItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IncomingInspectionRecordItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IncomingInspectionRecordItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IncomingInspectionRecordItemMaxAggregateInputType
  }

  export type GetIncomingInspectionRecordItemAggregateType<T extends IncomingInspectionRecordItemAggregateArgs> = {
        [P in keyof T & keyof AggregateIncomingInspectionRecordItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIncomingInspectionRecordItem[P]>
      : GetScalarType<T[P], AggregateIncomingInspectionRecordItem[P]>
  }




  export type IncomingInspectionRecordItemGroupByArgs = {
    where?: IncomingInspectionRecordItemWhereInput
    orderBy?: Enumerable<IncomingInspectionRecordItemOrderByWithAggregationInput>
    by: IncomingInspectionRecordItemScalarFieldEnum[]
    having?: IncomingInspectionRecordItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IncomingInspectionRecordItemCountAggregateInputType | true
    _avg?: IncomingInspectionRecordItemAvgAggregateInputType
    _sum?: IncomingInspectionRecordItemSumAggregateInputType
    _min?: IncomingInspectionRecordItemMinAggregateInputType
    _max?: IncomingInspectionRecordItemMaxAggregateInputType
  }


  export type IncomingInspectionRecordItemGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    isDeleted: boolean
    result: boolean
    inspectionIteration: string
    incomingInspectionRecordId: number
    incomingInspectionSpecItemId: number
    _count: IncomingInspectionRecordItemCountAggregateOutputType | null
    _avg: IncomingInspectionRecordItemAvgAggregateOutputType | null
    _sum: IncomingInspectionRecordItemSumAggregateOutputType | null
    _min: IncomingInspectionRecordItemMinAggregateOutputType | null
    _max: IncomingInspectionRecordItemMaxAggregateOutputType | null
  }

  type GetIncomingInspectionRecordItemGroupByPayload<T extends IncomingInspectionRecordItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<IncomingInspectionRecordItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IncomingInspectionRecordItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IncomingInspectionRecordItemGroupByOutputType[P]>
            : GetScalarType<T[P], IncomingInspectionRecordItemGroupByOutputType[P]>
        }
      >
    >


  export type IncomingInspectionRecordItemSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    result?: boolean
    inspectionIteration?: boolean
    incomingInspectionRecordId?: boolean
    incomingInspectionSpecItemId?: boolean
    incomingInspectionRecord?: boolean | IncomingInspectionRecordArgs
    incomingInspectionSpecItem?: boolean | IncomingInspectionSpecItemArgs
  }


  export type IncomingInspectionRecordItemInclude = {
    incomingInspectionRecord?: boolean | IncomingInspectionRecordArgs
    incomingInspectionSpecItem?: boolean | IncomingInspectionSpecItemArgs
  }

  export type IncomingInspectionRecordItemGetPayload<S extends boolean | null | undefined | IncomingInspectionRecordItemArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? IncomingInspectionRecordItem :
    S extends undefined ? never :
    S extends { include: any } & (IncomingInspectionRecordItemArgs | IncomingInspectionRecordItemFindManyArgs)
    ? IncomingInspectionRecordItem  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'incomingInspectionRecord' ? IncomingInspectionRecordGetPayload<S['include'][P]> :
        P extends 'incomingInspectionSpecItem' ? IncomingInspectionSpecItemGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (IncomingInspectionRecordItemArgs | IncomingInspectionRecordItemFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'incomingInspectionRecord' ? IncomingInspectionRecordGetPayload<S['select'][P]> :
        P extends 'incomingInspectionSpecItem' ? IncomingInspectionSpecItemGetPayload<S['select'][P]> :  P extends keyof IncomingInspectionRecordItem ? IncomingInspectionRecordItem[P] : never
  } 
      : IncomingInspectionRecordItem


  type IncomingInspectionRecordItemCountArgs = 
    Omit<IncomingInspectionRecordItemFindManyArgs, 'select' | 'include'> & {
      select?: IncomingInspectionRecordItemCountAggregateInputType | true
    }

  export interface IncomingInspectionRecordItemDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one IncomingInspectionRecordItem that matches the filter.
     * @param {IncomingInspectionRecordItemFindUniqueArgs} args - Arguments to find a IncomingInspectionRecordItem
     * @example
     * // Get one IncomingInspectionRecordItem
     * const incomingInspectionRecordItem = await prisma.incomingInspectionRecordItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends IncomingInspectionRecordItemFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, IncomingInspectionRecordItemFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'IncomingInspectionRecordItem'> extends True ? Prisma__IncomingInspectionRecordItemClient<IncomingInspectionRecordItemGetPayload<T>> : Prisma__IncomingInspectionRecordItemClient<IncomingInspectionRecordItemGetPayload<T> | null, null>

    /**
     * Find one IncomingInspectionRecordItem that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {IncomingInspectionRecordItemFindUniqueOrThrowArgs} args - Arguments to find a IncomingInspectionRecordItem
     * @example
     * // Get one IncomingInspectionRecordItem
     * const incomingInspectionRecordItem = await prisma.incomingInspectionRecordItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends IncomingInspectionRecordItemFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, IncomingInspectionRecordItemFindUniqueOrThrowArgs>
    ): Prisma__IncomingInspectionRecordItemClient<IncomingInspectionRecordItemGetPayload<T>>

    /**
     * Find the first IncomingInspectionRecordItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomingInspectionRecordItemFindFirstArgs} args - Arguments to find a IncomingInspectionRecordItem
     * @example
     * // Get one IncomingInspectionRecordItem
     * const incomingInspectionRecordItem = await prisma.incomingInspectionRecordItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends IncomingInspectionRecordItemFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, IncomingInspectionRecordItemFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'IncomingInspectionRecordItem'> extends True ? Prisma__IncomingInspectionRecordItemClient<IncomingInspectionRecordItemGetPayload<T>> : Prisma__IncomingInspectionRecordItemClient<IncomingInspectionRecordItemGetPayload<T> | null, null>

    /**
     * Find the first IncomingInspectionRecordItem that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomingInspectionRecordItemFindFirstOrThrowArgs} args - Arguments to find a IncomingInspectionRecordItem
     * @example
     * // Get one IncomingInspectionRecordItem
     * const incomingInspectionRecordItem = await prisma.incomingInspectionRecordItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends IncomingInspectionRecordItemFindFirstOrThrowArgs>(
      args?: SelectSubset<T, IncomingInspectionRecordItemFindFirstOrThrowArgs>
    ): Prisma__IncomingInspectionRecordItemClient<IncomingInspectionRecordItemGetPayload<T>>

    /**
     * Find zero or more IncomingInspectionRecordItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomingInspectionRecordItemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IncomingInspectionRecordItems
     * const incomingInspectionRecordItems = await prisma.incomingInspectionRecordItem.findMany()
     * 
     * // Get first 10 IncomingInspectionRecordItems
     * const incomingInspectionRecordItems = await prisma.incomingInspectionRecordItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const incomingInspectionRecordItemWithIdOnly = await prisma.incomingInspectionRecordItem.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends IncomingInspectionRecordItemFindManyArgs>(
      args?: SelectSubset<T, IncomingInspectionRecordItemFindManyArgs>
    ): Prisma.PrismaPromise<Array<IncomingInspectionRecordItemGetPayload<T>>>

    /**
     * Create a IncomingInspectionRecordItem.
     * @param {IncomingInspectionRecordItemCreateArgs} args - Arguments to create a IncomingInspectionRecordItem.
     * @example
     * // Create one IncomingInspectionRecordItem
     * const IncomingInspectionRecordItem = await prisma.incomingInspectionRecordItem.create({
     *   data: {
     *     // ... data to create a IncomingInspectionRecordItem
     *   }
     * })
     * 
    **/
    create<T extends IncomingInspectionRecordItemCreateArgs>(
      args: SelectSubset<T, IncomingInspectionRecordItemCreateArgs>
    ): Prisma__IncomingInspectionRecordItemClient<IncomingInspectionRecordItemGetPayload<T>>

    /**
     * Create many IncomingInspectionRecordItems.
     *     @param {IncomingInspectionRecordItemCreateManyArgs} args - Arguments to create many IncomingInspectionRecordItems.
     *     @example
     *     // Create many IncomingInspectionRecordItems
     *     const incomingInspectionRecordItem = await prisma.incomingInspectionRecordItem.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends IncomingInspectionRecordItemCreateManyArgs>(
      args?: SelectSubset<T, IncomingInspectionRecordItemCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a IncomingInspectionRecordItem.
     * @param {IncomingInspectionRecordItemDeleteArgs} args - Arguments to delete one IncomingInspectionRecordItem.
     * @example
     * // Delete one IncomingInspectionRecordItem
     * const IncomingInspectionRecordItem = await prisma.incomingInspectionRecordItem.delete({
     *   where: {
     *     // ... filter to delete one IncomingInspectionRecordItem
     *   }
     * })
     * 
    **/
    delete<T extends IncomingInspectionRecordItemDeleteArgs>(
      args: SelectSubset<T, IncomingInspectionRecordItemDeleteArgs>
    ): Prisma__IncomingInspectionRecordItemClient<IncomingInspectionRecordItemGetPayload<T>>

    /**
     * Update one IncomingInspectionRecordItem.
     * @param {IncomingInspectionRecordItemUpdateArgs} args - Arguments to update one IncomingInspectionRecordItem.
     * @example
     * // Update one IncomingInspectionRecordItem
     * const incomingInspectionRecordItem = await prisma.incomingInspectionRecordItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends IncomingInspectionRecordItemUpdateArgs>(
      args: SelectSubset<T, IncomingInspectionRecordItemUpdateArgs>
    ): Prisma__IncomingInspectionRecordItemClient<IncomingInspectionRecordItemGetPayload<T>>

    /**
     * Delete zero or more IncomingInspectionRecordItems.
     * @param {IncomingInspectionRecordItemDeleteManyArgs} args - Arguments to filter IncomingInspectionRecordItems to delete.
     * @example
     * // Delete a few IncomingInspectionRecordItems
     * const { count } = await prisma.incomingInspectionRecordItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends IncomingInspectionRecordItemDeleteManyArgs>(
      args?: SelectSubset<T, IncomingInspectionRecordItemDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IncomingInspectionRecordItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomingInspectionRecordItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IncomingInspectionRecordItems
     * const incomingInspectionRecordItem = await prisma.incomingInspectionRecordItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends IncomingInspectionRecordItemUpdateManyArgs>(
      args: SelectSubset<T, IncomingInspectionRecordItemUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one IncomingInspectionRecordItem.
     * @param {IncomingInspectionRecordItemUpsertArgs} args - Arguments to update or create a IncomingInspectionRecordItem.
     * @example
     * // Update or create a IncomingInspectionRecordItem
     * const incomingInspectionRecordItem = await prisma.incomingInspectionRecordItem.upsert({
     *   create: {
     *     // ... data to create a IncomingInspectionRecordItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IncomingInspectionRecordItem we want to update
     *   }
     * })
    **/
    upsert<T extends IncomingInspectionRecordItemUpsertArgs>(
      args: SelectSubset<T, IncomingInspectionRecordItemUpsertArgs>
    ): Prisma__IncomingInspectionRecordItemClient<IncomingInspectionRecordItemGetPayload<T>>

    /**
     * Count the number of IncomingInspectionRecordItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomingInspectionRecordItemCountArgs} args - Arguments to filter IncomingInspectionRecordItems to count.
     * @example
     * // Count the number of IncomingInspectionRecordItems
     * const count = await prisma.incomingInspectionRecordItem.count({
     *   where: {
     *     // ... the filter for the IncomingInspectionRecordItems we want to count
     *   }
     * })
    **/
    count<T extends IncomingInspectionRecordItemCountArgs>(
      args?: Subset<T, IncomingInspectionRecordItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IncomingInspectionRecordItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IncomingInspectionRecordItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomingInspectionRecordItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IncomingInspectionRecordItemAggregateArgs>(args: Subset<T, IncomingInspectionRecordItemAggregateArgs>): Prisma.PrismaPromise<GetIncomingInspectionRecordItemAggregateType<T>>

    /**
     * Group by IncomingInspectionRecordItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomingInspectionRecordItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IncomingInspectionRecordItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IncomingInspectionRecordItemGroupByArgs['orderBy'] }
        : { orderBy?: IncomingInspectionRecordItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IncomingInspectionRecordItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIncomingInspectionRecordItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for IncomingInspectionRecordItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__IncomingInspectionRecordItemClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    incomingInspectionRecord<T extends IncomingInspectionRecordArgs= {}>(args?: Subset<T, IncomingInspectionRecordArgs>): Prisma__IncomingInspectionRecordClient<IncomingInspectionRecordGetPayload<T> | Null>;

    incomingInspectionSpecItem<T extends IncomingInspectionSpecItemArgs= {}>(args?: Subset<T, IncomingInspectionSpecItemArgs>): Prisma__IncomingInspectionSpecItemClient<IncomingInspectionSpecItemGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * IncomingInspectionRecordItem base type for findUnique actions
   */
  export type IncomingInspectionRecordItemFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the IncomingInspectionRecordItem
     */
    select?: IncomingInspectionRecordItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IncomingInspectionRecordItemInclude | null
    /**
     * Filter, which IncomingInspectionRecordItem to fetch.
     */
    where: IncomingInspectionRecordItemWhereUniqueInput
  }

  /**
   * IncomingInspectionRecordItem findUnique
   */
  export interface IncomingInspectionRecordItemFindUniqueArgs extends IncomingInspectionRecordItemFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * IncomingInspectionRecordItem findUniqueOrThrow
   */
  export type IncomingInspectionRecordItemFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the IncomingInspectionRecordItem
     */
    select?: IncomingInspectionRecordItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IncomingInspectionRecordItemInclude | null
    /**
     * Filter, which IncomingInspectionRecordItem to fetch.
     */
    where: IncomingInspectionRecordItemWhereUniqueInput
  }


  /**
   * IncomingInspectionRecordItem base type for findFirst actions
   */
  export type IncomingInspectionRecordItemFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the IncomingInspectionRecordItem
     */
    select?: IncomingInspectionRecordItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IncomingInspectionRecordItemInclude | null
    /**
     * Filter, which IncomingInspectionRecordItem to fetch.
     */
    where?: IncomingInspectionRecordItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncomingInspectionRecordItems to fetch.
     */
    orderBy?: Enumerable<IncomingInspectionRecordItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IncomingInspectionRecordItems.
     */
    cursor?: IncomingInspectionRecordItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncomingInspectionRecordItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncomingInspectionRecordItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IncomingInspectionRecordItems.
     */
    distinct?: Enumerable<IncomingInspectionRecordItemScalarFieldEnum>
  }

  /**
   * IncomingInspectionRecordItem findFirst
   */
  export interface IncomingInspectionRecordItemFindFirstArgs extends IncomingInspectionRecordItemFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * IncomingInspectionRecordItem findFirstOrThrow
   */
  export type IncomingInspectionRecordItemFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the IncomingInspectionRecordItem
     */
    select?: IncomingInspectionRecordItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IncomingInspectionRecordItemInclude | null
    /**
     * Filter, which IncomingInspectionRecordItem to fetch.
     */
    where?: IncomingInspectionRecordItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncomingInspectionRecordItems to fetch.
     */
    orderBy?: Enumerable<IncomingInspectionRecordItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IncomingInspectionRecordItems.
     */
    cursor?: IncomingInspectionRecordItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncomingInspectionRecordItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncomingInspectionRecordItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IncomingInspectionRecordItems.
     */
    distinct?: Enumerable<IncomingInspectionRecordItemScalarFieldEnum>
  }


  /**
   * IncomingInspectionRecordItem findMany
   */
  export type IncomingInspectionRecordItemFindManyArgs = {
    /**
     * Select specific fields to fetch from the IncomingInspectionRecordItem
     */
    select?: IncomingInspectionRecordItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IncomingInspectionRecordItemInclude | null
    /**
     * Filter, which IncomingInspectionRecordItems to fetch.
     */
    where?: IncomingInspectionRecordItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncomingInspectionRecordItems to fetch.
     */
    orderBy?: Enumerable<IncomingInspectionRecordItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IncomingInspectionRecordItems.
     */
    cursor?: IncomingInspectionRecordItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncomingInspectionRecordItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncomingInspectionRecordItems.
     */
    skip?: number
    distinct?: Enumerable<IncomingInspectionRecordItemScalarFieldEnum>
  }


  /**
   * IncomingInspectionRecordItem create
   */
  export type IncomingInspectionRecordItemCreateArgs = {
    /**
     * Select specific fields to fetch from the IncomingInspectionRecordItem
     */
    select?: IncomingInspectionRecordItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IncomingInspectionRecordItemInclude | null
    /**
     * The data needed to create a IncomingInspectionRecordItem.
     */
    data: XOR<IncomingInspectionRecordItemCreateInput, IncomingInspectionRecordItemUncheckedCreateInput>
  }


  /**
   * IncomingInspectionRecordItem createMany
   */
  export type IncomingInspectionRecordItemCreateManyArgs = {
    /**
     * The data used to create many IncomingInspectionRecordItems.
     */
    data: Enumerable<IncomingInspectionRecordItemCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * IncomingInspectionRecordItem update
   */
  export type IncomingInspectionRecordItemUpdateArgs = {
    /**
     * Select specific fields to fetch from the IncomingInspectionRecordItem
     */
    select?: IncomingInspectionRecordItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IncomingInspectionRecordItemInclude | null
    /**
     * The data needed to update a IncomingInspectionRecordItem.
     */
    data: XOR<IncomingInspectionRecordItemUpdateInput, IncomingInspectionRecordItemUncheckedUpdateInput>
    /**
     * Choose, which IncomingInspectionRecordItem to update.
     */
    where: IncomingInspectionRecordItemWhereUniqueInput
  }


  /**
   * IncomingInspectionRecordItem updateMany
   */
  export type IncomingInspectionRecordItemUpdateManyArgs = {
    /**
     * The data used to update IncomingInspectionRecordItems.
     */
    data: XOR<IncomingInspectionRecordItemUpdateManyMutationInput, IncomingInspectionRecordItemUncheckedUpdateManyInput>
    /**
     * Filter which IncomingInspectionRecordItems to update
     */
    where?: IncomingInspectionRecordItemWhereInput
  }


  /**
   * IncomingInspectionRecordItem upsert
   */
  export type IncomingInspectionRecordItemUpsertArgs = {
    /**
     * Select specific fields to fetch from the IncomingInspectionRecordItem
     */
    select?: IncomingInspectionRecordItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IncomingInspectionRecordItemInclude | null
    /**
     * The filter to search for the IncomingInspectionRecordItem to update in case it exists.
     */
    where: IncomingInspectionRecordItemWhereUniqueInput
    /**
     * In case the IncomingInspectionRecordItem found by the `where` argument doesn't exist, create a new IncomingInspectionRecordItem with this data.
     */
    create: XOR<IncomingInspectionRecordItemCreateInput, IncomingInspectionRecordItemUncheckedCreateInput>
    /**
     * In case the IncomingInspectionRecordItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IncomingInspectionRecordItemUpdateInput, IncomingInspectionRecordItemUncheckedUpdateInput>
  }


  /**
   * IncomingInspectionRecordItem delete
   */
  export type IncomingInspectionRecordItemDeleteArgs = {
    /**
     * Select specific fields to fetch from the IncomingInspectionRecordItem
     */
    select?: IncomingInspectionRecordItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IncomingInspectionRecordItemInclude | null
    /**
     * Filter which IncomingInspectionRecordItem to delete.
     */
    where: IncomingInspectionRecordItemWhereUniqueInput
  }


  /**
   * IncomingInspectionRecordItem deleteMany
   */
  export type IncomingInspectionRecordItemDeleteManyArgs = {
    /**
     * Filter which IncomingInspectionRecordItems to delete
     */
    where?: IncomingInspectionRecordItemWhereInput
  }


  /**
   * IncomingInspectionRecordItem without action
   */
  export type IncomingInspectionRecordItemArgs = {
    /**
     * Select specific fields to fetch from the IncomingInspectionRecordItem
     */
    select?: IncomingInspectionRecordItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IncomingInspectionRecordItemInclude | null
  }



  /**
   * Model WorkerOrder
   */


  export type AggregateWorkerOrder = {
    _count: WorkerOrderCountAggregateOutputType | null
    _avg: WorkerOrderAvgAggregateOutputType | null
    _sum: WorkerOrderSumAggregateOutputType | null
    _min: WorkerOrderMinAggregateOutputType | null
    _max: WorkerOrderMaxAggregateOutputType | null
  }

  export type WorkerOrderAvgAggregateOutputType = {
    id: number | null
    partId: number | null
  }

  export type WorkerOrderSumAggregateOutputType = {
    id: number | null
    partId: number | null
  }

  export type WorkerOrderMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    no: string | null
    partId: number | null
  }

  export type WorkerOrderMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    no: string | null
    partId: number | null
  }

  export type WorkerOrderCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    isDeleted: number
    no: number
    partId: number
    _all: number
  }


  export type WorkerOrderAvgAggregateInputType = {
    id?: true
    partId?: true
  }

  export type WorkerOrderSumAggregateInputType = {
    id?: true
    partId?: true
  }

  export type WorkerOrderMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    no?: true
    partId?: true
  }

  export type WorkerOrderMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    no?: true
    partId?: true
  }

  export type WorkerOrderCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    no?: true
    partId?: true
    _all?: true
  }

  export type WorkerOrderAggregateArgs = {
    /**
     * Filter which WorkerOrder to aggregate.
     */
    where?: WorkerOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkerOrders to fetch.
     */
    orderBy?: Enumerable<WorkerOrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkerOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkerOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkerOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkerOrders
    **/
    _count?: true | WorkerOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkerOrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkerOrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkerOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkerOrderMaxAggregateInputType
  }

  export type GetWorkerOrderAggregateType<T extends WorkerOrderAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkerOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkerOrder[P]>
      : GetScalarType<T[P], AggregateWorkerOrder[P]>
  }




  export type WorkerOrderGroupByArgs = {
    where?: WorkerOrderWhereInput
    orderBy?: Enumerable<WorkerOrderOrderByWithAggregationInput>
    by: WorkerOrderScalarFieldEnum[]
    having?: WorkerOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkerOrderCountAggregateInputType | true
    _avg?: WorkerOrderAvgAggregateInputType
    _sum?: WorkerOrderSumAggregateInputType
    _min?: WorkerOrderMinAggregateInputType
    _max?: WorkerOrderMaxAggregateInputType
  }


  export type WorkerOrderGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    isDeleted: boolean
    no: string
    partId: number
    _count: WorkerOrderCountAggregateOutputType | null
    _avg: WorkerOrderAvgAggregateOutputType | null
    _sum: WorkerOrderSumAggregateOutputType | null
    _min: WorkerOrderMinAggregateOutputType | null
    _max: WorkerOrderMaxAggregateOutputType | null
  }

  type GetWorkerOrderGroupByPayload<T extends WorkerOrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<WorkerOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkerOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkerOrderGroupByOutputType[P]>
            : GetScalarType<T[P], WorkerOrderGroupByOutputType[P]>
        }
      >
    >


  export type WorkerOrderSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    no?: boolean
    partId?: boolean
    part?: boolean | PartArgs
    operationInspectionRecords?: boolean | WorkerOrder$operationInspectionRecordsArgs
    _count?: boolean | WorkerOrderCountOutputTypeArgs
  }


  export type WorkerOrderInclude = {
    part?: boolean | PartArgs
    operationInspectionRecords?: boolean | WorkerOrder$operationInspectionRecordsArgs
    _count?: boolean | WorkerOrderCountOutputTypeArgs
  }

  export type WorkerOrderGetPayload<S extends boolean | null | undefined | WorkerOrderArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? WorkerOrder :
    S extends undefined ? never :
    S extends { include: any } & (WorkerOrderArgs | WorkerOrderFindManyArgs)
    ? WorkerOrder  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'part' ? PartGetPayload<S['include'][P]> :
        P extends 'operationInspectionRecords' ? Array < OperationInspectionRecordGetPayload<S['include'][P]>>  :
        P extends '_count' ? WorkerOrderCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (WorkerOrderArgs | WorkerOrderFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'part' ? PartGetPayload<S['select'][P]> :
        P extends 'operationInspectionRecords' ? Array < OperationInspectionRecordGetPayload<S['select'][P]>>  :
        P extends '_count' ? WorkerOrderCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof WorkerOrder ? WorkerOrder[P] : never
  } 
      : WorkerOrder


  type WorkerOrderCountArgs = 
    Omit<WorkerOrderFindManyArgs, 'select' | 'include'> & {
      select?: WorkerOrderCountAggregateInputType | true
    }

  export interface WorkerOrderDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one WorkerOrder that matches the filter.
     * @param {WorkerOrderFindUniqueArgs} args - Arguments to find a WorkerOrder
     * @example
     * // Get one WorkerOrder
     * const workerOrder = await prisma.workerOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WorkerOrderFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, WorkerOrderFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'WorkerOrder'> extends True ? Prisma__WorkerOrderClient<WorkerOrderGetPayload<T>> : Prisma__WorkerOrderClient<WorkerOrderGetPayload<T> | null, null>

    /**
     * Find one WorkerOrder that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {WorkerOrderFindUniqueOrThrowArgs} args - Arguments to find a WorkerOrder
     * @example
     * // Get one WorkerOrder
     * const workerOrder = await prisma.workerOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends WorkerOrderFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, WorkerOrderFindUniqueOrThrowArgs>
    ): Prisma__WorkerOrderClient<WorkerOrderGetPayload<T>>

    /**
     * Find the first WorkerOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerOrderFindFirstArgs} args - Arguments to find a WorkerOrder
     * @example
     * // Get one WorkerOrder
     * const workerOrder = await prisma.workerOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WorkerOrderFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, WorkerOrderFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'WorkerOrder'> extends True ? Prisma__WorkerOrderClient<WorkerOrderGetPayload<T>> : Prisma__WorkerOrderClient<WorkerOrderGetPayload<T> | null, null>

    /**
     * Find the first WorkerOrder that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerOrderFindFirstOrThrowArgs} args - Arguments to find a WorkerOrder
     * @example
     * // Get one WorkerOrder
     * const workerOrder = await prisma.workerOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends WorkerOrderFindFirstOrThrowArgs>(
      args?: SelectSubset<T, WorkerOrderFindFirstOrThrowArgs>
    ): Prisma__WorkerOrderClient<WorkerOrderGetPayload<T>>

    /**
     * Find zero or more WorkerOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerOrderFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkerOrders
     * const workerOrders = await prisma.workerOrder.findMany()
     * 
     * // Get first 10 WorkerOrders
     * const workerOrders = await prisma.workerOrder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workerOrderWithIdOnly = await prisma.workerOrder.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends WorkerOrderFindManyArgs>(
      args?: SelectSubset<T, WorkerOrderFindManyArgs>
    ): Prisma.PrismaPromise<Array<WorkerOrderGetPayload<T>>>

    /**
     * Create a WorkerOrder.
     * @param {WorkerOrderCreateArgs} args - Arguments to create a WorkerOrder.
     * @example
     * // Create one WorkerOrder
     * const WorkerOrder = await prisma.workerOrder.create({
     *   data: {
     *     // ... data to create a WorkerOrder
     *   }
     * })
     * 
    **/
    create<T extends WorkerOrderCreateArgs>(
      args: SelectSubset<T, WorkerOrderCreateArgs>
    ): Prisma__WorkerOrderClient<WorkerOrderGetPayload<T>>

    /**
     * Create many WorkerOrders.
     *     @param {WorkerOrderCreateManyArgs} args - Arguments to create many WorkerOrders.
     *     @example
     *     // Create many WorkerOrders
     *     const workerOrder = await prisma.workerOrder.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends WorkerOrderCreateManyArgs>(
      args?: SelectSubset<T, WorkerOrderCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WorkerOrder.
     * @param {WorkerOrderDeleteArgs} args - Arguments to delete one WorkerOrder.
     * @example
     * // Delete one WorkerOrder
     * const WorkerOrder = await prisma.workerOrder.delete({
     *   where: {
     *     // ... filter to delete one WorkerOrder
     *   }
     * })
     * 
    **/
    delete<T extends WorkerOrderDeleteArgs>(
      args: SelectSubset<T, WorkerOrderDeleteArgs>
    ): Prisma__WorkerOrderClient<WorkerOrderGetPayload<T>>

    /**
     * Update one WorkerOrder.
     * @param {WorkerOrderUpdateArgs} args - Arguments to update one WorkerOrder.
     * @example
     * // Update one WorkerOrder
     * const workerOrder = await prisma.workerOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WorkerOrderUpdateArgs>(
      args: SelectSubset<T, WorkerOrderUpdateArgs>
    ): Prisma__WorkerOrderClient<WorkerOrderGetPayload<T>>

    /**
     * Delete zero or more WorkerOrders.
     * @param {WorkerOrderDeleteManyArgs} args - Arguments to filter WorkerOrders to delete.
     * @example
     * // Delete a few WorkerOrders
     * const { count } = await prisma.workerOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WorkerOrderDeleteManyArgs>(
      args?: SelectSubset<T, WorkerOrderDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkerOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkerOrders
     * const workerOrder = await prisma.workerOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WorkerOrderUpdateManyArgs>(
      args: SelectSubset<T, WorkerOrderUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WorkerOrder.
     * @param {WorkerOrderUpsertArgs} args - Arguments to update or create a WorkerOrder.
     * @example
     * // Update or create a WorkerOrder
     * const workerOrder = await prisma.workerOrder.upsert({
     *   create: {
     *     // ... data to create a WorkerOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkerOrder we want to update
     *   }
     * })
    **/
    upsert<T extends WorkerOrderUpsertArgs>(
      args: SelectSubset<T, WorkerOrderUpsertArgs>
    ): Prisma__WorkerOrderClient<WorkerOrderGetPayload<T>>

    /**
     * Count the number of WorkerOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerOrderCountArgs} args - Arguments to filter WorkerOrders to count.
     * @example
     * // Count the number of WorkerOrders
     * const count = await prisma.workerOrder.count({
     *   where: {
     *     // ... the filter for the WorkerOrders we want to count
     *   }
     * })
    **/
    count<T extends WorkerOrderCountArgs>(
      args?: Subset<T, WorkerOrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkerOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkerOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkerOrderAggregateArgs>(args: Subset<T, WorkerOrderAggregateArgs>): Prisma.PrismaPromise<GetWorkerOrderAggregateType<T>>

    /**
     * Group by WorkerOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkerOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkerOrderGroupByArgs['orderBy'] }
        : { orderBy?: WorkerOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkerOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkerOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkerOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__WorkerOrderClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    part<T extends PartArgs= {}>(args?: Subset<T, PartArgs>): Prisma__PartClient<PartGetPayload<T> | Null>;

    operationInspectionRecords<T extends WorkerOrder$operationInspectionRecordsArgs= {}>(args?: Subset<T, WorkerOrder$operationInspectionRecordsArgs>): Prisma.PrismaPromise<Array<OperationInspectionRecordGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * WorkerOrder base type for findUnique actions
   */
  export type WorkerOrderFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the WorkerOrder
     */
    select?: WorkerOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkerOrderInclude | null
    /**
     * Filter, which WorkerOrder to fetch.
     */
    where: WorkerOrderWhereUniqueInput
  }

  /**
   * WorkerOrder findUnique
   */
  export interface WorkerOrderFindUniqueArgs extends WorkerOrderFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * WorkerOrder findUniqueOrThrow
   */
  export type WorkerOrderFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the WorkerOrder
     */
    select?: WorkerOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkerOrderInclude | null
    /**
     * Filter, which WorkerOrder to fetch.
     */
    where: WorkerOrderWhereUniqueInput
  }


  /**
   * WorkerOrder base type for findFirst actions
   */
  export type WorkerOrderFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the WorkerOrder
     */
    select?: WorkerOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkerOrderInclude | null
    /**
     * Filter, which WorkerOrder to fetch.
     */
    where?: WorkerOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkerOrders to fetch.
     */
    orderBy?: Enumerable<WorkerOrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkerOrders.
     */
    cursor?: WorkerOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkerOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkerOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkerOrders.
     */
    distinct?: Enumerable<WorkerOrderScalarFieldEnum>
  }

  /**
   * WorkerOrder findFirst
   */
  export interface WorkerOrderFindFirstArgs extends WorkerOrderFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * WorkerOrder findFirstOrThrow
   */
  export type WorkerOrderFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the WorkerOrder
     */
    select?: WorkerOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkerOrderInclude | null
    /**
     * Filter, which WorkerOrder to fetch.
     */
    where?: WorkerOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkerOrders to fetch.
     */
    orderBy?: Enumerable<WorkerOrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkerOrders.
     */
    cursor?: WorkerOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkerOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkerOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkerOrders.
     */
    distinct?: Enumerable<WorkerOrderScalarFieldEnum>
  }


  /**
   * WorkerOrder findMany
   */
  export type WorkerOrderFindManyArgs = {
    /**
     * Select specific fields to fetch from the WorkerOrder
     */
    select?: WorkerOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkerOrderInclude | null
    /**
     * Filter, which WorkerOrders to fetch.
     */
    where?: WorkerOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkerOrders to fetch.
     */
    orderBy?: Enumerable<WorkerOrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkerOrders.
     */
    cursor?: WorkerOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkerOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkerOrders.
     */
    skip?: number
    distinct?: Enumerable<WorkerOrderScalarFieldEnum>
  }


  /**
   * WorkerOrder create
   */
  export type WorkerOrderCreateArgs = {
    /**
     * Select specific fields to fetch from the WorkerOrder
     */
    select?: WorkerOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkerOrderInclude | null
    /**
     * The data needed to create a WorkerOrder.
     */
    data: XOR<WorkerOrderCreateInput, WorkerOrderUncheckedCreateInput>
  }


  /**
   * WorkerOrder createMany
   */
  export type WorkerOrderCreateManyArgs = {
    /**
     * The data used to create many WorkerOrders.
     */
    data: Enumerable<WorkerOrderCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * WorkerOrder update
   */
  export type WorkerOrderUpdateArgs = {
    /**
     * Select specific fields to fetch from the WorkerOrder
     */
    select?: WorkerOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkerOrderInclude | null
    /**
     * The data needed to update a WorkerOrder.
     */
    data: XOR<WorkerOrderUpdateInput, WorkerOrderUncheckedUpdateInput>
    /**
     * Choose, which WorkerOrder to update.
     */
    where: WorkerOrderWhereUniqueInput
  }


  /**
   * WorkerOrder updateMany
   */
  export type WorkerOrderUpdateManyArgs = {
    /**
     * The data used to update WorkerOrders.
     */
    data: XOR<WorkerOrderUpdateManyMutationInput, WorkerOrderUncheckedUpdateManyInput>
    /**
     * Filter which WorkerOrders to update
     */
    where?: WorkerOrderWhereInput
  }


  /**
   * WorkerOrder upsert
   */
  export type WorkerOrderUpsertArgs = {
    /**
     * Select specific fields to fetch from the WorkerOrder
     */
    select?: WorkerOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkerOrderInclude | null
    /**
     * The filter to search for the WorkerOrder to update in case it exists.
     */
    where: WorkerOrderWhereUniqueInput
    /**
     * In case the WorkerOrder found by the `where` argument doesn't exist, create a new WorkerOrder with this data.
     */
    create: XOR<WorkerOrderCreateInput, WorkerOrderUncheckedCreateInput>
    /**
     * In case the WorkerOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkerOrderUpdateInput, WorkerOrderUncheckedUpdateInput>
  }


  /**
   * WorkerOrder delete
   */
  export type WorkerOrderDeleteArgs = {
    /**
     * Select specific fields to fetch from the WorkerOrder
     */
    select?: WorkerOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkerOrderInclude | null
    /**
     * Filter which WorkerOrder to delete.
     */
    where: WorkerOrderWhereUniqueInput
  }


  /**
   * WorkerOrder deleteMany
   */
  export type WorkerOrderDeleteManyArgs = {
    /**
     * Filter which WorkerOrders to delete
     */
    where?: WorkerOrderWhereInput
  }


  /**
   * WorkerOrder.operationInspectionRecords
   */
  export type WorkerOrder$operationInspectionRecordsArgs = {
    /**
     * Select specific fields to fetch from the OperationInspectionRecord
     */
    select?: OperationInspectionRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OperationInspectionRecordInclude | null
    where?: OperationInspectionRecordWhereInput
    orderBy?: Enumerable<OperationInspectionRecordOrderByWithRelationInput>
    cursor?: OperationInspectionRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<OperationInspectionRecordScalarFieldEnum>
  }


  /**
   * WorkerOrder without action
   */
  export type WorkerOrderArgs = {
    /**
     * Select specific fields to fetch from the WorkerOrder
     */
    select?: WorkerOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkerOrderInclude | null
  }



  /**
   * Model OperationInspectionRecord
   */


  export type AggregateOperationInspectionRecord = {
    _count: OperationInspectionRecordCountAggregateOutputType | null
    _avg: OperationInspectionRecordAvgAggregateOutputType | null
    _sum: OperationInspectionRecordSumAggregateOutputType | null
    _min: OperationInspectionRecordMinAggregateOutputType | null
    _max: OperationInspectionRecordMaxAggregateOutputType | null
  }

  export type OperationInspectionRecordAvgAggregateOutputType = {
    id: number | null
    workerOrderId: number | null
    inspectorId: number | null
    reviewerId: number | null
  }

  export type OperationInspectionRecordSumAggregateOutputType = {
    id: number | null
    workerOrderId: number | null
    inspectorId: number | null
    reviewerId: number | null
  }

  export type OperationInspectionRecordMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    note: string | null
    workerOrderId: number | null
    inspectorId: number | null
    reviewerId: number | null
  }

  export type OperationInspectionRecordMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    note: string | null
    workerOrderId: number | null
    inspectorId: number | null
    reviewerId: number | null
  }

  export type OperationInspectionRecordCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    isDeleted: number
    note: number
    workerOrderId: number
    inspectorId: number
    reviewerId: number
    _all: number
  }


  export type OperationInspectionRecordAvgAggregateInputType = {
    id?: true
    workerOrderId?: true
    inspectorId?: true
    reviewerId?: true
  }

  export type OperationInspectionRecordSumAggregateInputType = {
    id?: true
    workerOrderId?: true
    inspectorId?: true
    reviewerId?: true
  }

  export type OperationInspectionRecordMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    note?: true
    workerOrderId?: true
    inspectorId?: true
    reviewerId?: true
  }

  export type OperationInspectionRecordMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    note?: true
    workerOrderId?: true
    inspectorId?: true
    reviewerId?: true
  }

  export type OperationInspectionRecordCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    note?: true
    workerOrderId?: true
    inspectorId?: true
    reviewerId?: true
    _all?: true
  }

  export type OperationInspectionRecordAggregateArgs = {
    /**
     * Filter which OperationInspectionRecord to aggregate.
     */
    where?: OperationInspectionRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperationInspectionRecords to fetch.
     */
    orderBy?: Enumerable<OperationInspectionRecordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OperationInspectionRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperationInspectionRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperationInspectionRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OperationInspectionRecords
    **/
    _count?: true | OperationInspectionRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OperationInspectionRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OperationInspectionRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OperationInspectionRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OperationInspectionRecordMaxAggregateInputType
  }

  export type GetOperationInspectionRecordAggregateType<T extends OperationInspectionRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateOperationInspectionRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOperationInspectionRecord[P]>
      : GetScalarType<T[P], AggregateOperationInspectionRecord[P]>
  }




  export type OperationInspectionRecordGroupByArgs = {
    where?: OperationInspectionRecordWhereInput
    orderBy?: Enumerable<OperationInspectionRecordOrderByWithAggregationInput>
    by: OperationInspectionRecordScalarFieldEnum[]
    having?: OperationInspectionRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OperationInspectionRecordCountAggregateInputType | true
    _avg?: OperationInspectionRecordAvgAggregateInputType
    _sum?: OperationInspectionRecordSumAggregateInputType
    _min?: OperationInspectionRecordMinAggregateInputType
    _max?: OperationInspectionRecordMaxAggregateInputType
  }


  export type OperationInspectionRecordGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    isDeleted: boolean
    note: string | null
    workerOrderId: number
    inspectorId: number
    reviewerId: number
    _count: OperationInspectionRecordCountAggregateOutputType | null
    _avg: OperationInspectionRecordAvgAggregateOutputType | null
    _sum: OperationInspectionRecordSumAggregateOutputType | null
    _min: OperationInspectionRecordMinAggregateOutputType | null
    _max: OperationInspectionRecordMaxAggregateOutputType | null
  }

  type GetOperationInspectionRecordGroupByPayload<T extends OperationInspectionRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<OperationInspectionRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OperationInspectionRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OperationInspectionRecordGroupByOutputType[P]>
            : GetScalarType<T[P], OperationInspectionRecordGroupByOutputType[P]>
        }
      >
    >


  export type OperationInspectionRecordSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    note?: boolean
    workerOrderId?: boolean
    inspectorId?: boolean
    reviewerId?: boolean
    workerOrder?: boolean | WorkerOrderArgs
    inspector?: boolean | UserArgs
    reviewer?: boolean | UserArgs
    operationInspectionRecordItems?: boolean | OperationInspectionRecord$operationInspectionRecordItemsArgs
    _count?: boolean | OperationInspectionRecordCountOutputTypeArgs
  }


  export type OperationInspectionRecordInclude = {
    workerOrder?: boolean | WorkerOrderArgs
    inspector?: boolean | UserArgs
    reviewer?: boolean | UserArgs
    operationInspectionRecordItems?: boolean | OperationInspectionRecord$operationInspectionRecordItemsArgs
    _count?: boolean | OperationInspectionRecordCountOutputTypeArgs
  }

  export type OperationInspectionRecordGetPayload<S extends boolean | null | undefined | OperationInspectionRecordArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? OperationInspectionRecord :
    S extends undefined ? never :
    S extends { include: any } & (OperationInspectionRecordArgs | OperationInspectionRecordFindManyArgs)
    ? OperationInspectionRecord  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'workerOrder' ? WorkerOrderGetPayload<S['include'][P]> :
        P extends 'inspector' ? UserGetPayload<S['include'][P]> :
        P extends 'reviewer' ? UserGetPayload<S['include'][P]> :
        P extends 'operationInspectionRecordItems' ? Array < OperationInspectionRecordItemGetPayload<S['include'][P]>>  :
        P extends '_count' ? OperationInspectionRecordCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (OperationInspectionRecordArgs | OperationInspectionRecordFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'workerOrder' ? WorkerOrderGetPayload<S['select'][P]> :
        P extends 'inspector' ? UserGetPayload<S['select'][P]> :
        P extends 'reviewer' ? UserGetPayload<S['select'][P]> :
        P extends 'operationInspectionRecordItems' ? Array < OperationInspectionRecordItemGetPayload<S['select'][P]>>  :
        P extends '_count' ? OperationInspectionRecordCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof OperationInspectionRecord ? OperationInspectionRecord[P] : never
  } 
      : OperationInspectionRecord


  type OperationInspectionRecordCountArgs = 
    Omit<OperationInspectionRecordFindManyArgs, 'select' | 'include'> & {
      select?: OperationInspectionRecordCountAggregateInputType | true
    }

  export interface OperationInspectionRecordDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one OperationInspectionRecord that matches the filter.
     * @param {OperationInspectionRecordFindUniqueArgs} args - Arguments to find a OperationInspectionRecord
     * @example
     * // Get one OperationInspectionRecord
     * const operationInspectionRecord = await prisma.operationInspectionRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OperationInspectionRecordFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OperationInspectionRecordFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'OperationInspectionRecord'> extends True ? Prisma__OperationInspectionRecordClient<OperationInspectionRecordGetPayload<T>> : Prisma__OperationInspectionRecordClient<OperationInspectionRecordGetPayload<T> | null, null>

    /**
     * Find one OperationInspectionRecord that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OperationInspectionRecordFindUniqueOrThrowArgs} args - Arguments to find a OperationInspectionRecord
     * @example
     * // Get one OperationInspectionRecord
     * const operationInspectionRecord = await prisma.operationInspectionRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OperationInspectionRecordFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, OperationInspectionRecordFindUniqueOrThrowArgs>
    ): Prisma__OperationInspectionRecordClient<OperationInspectionRecordGetPayload<T>>

    /**
     * Find the first OperationInspectionRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationInspectionRecordFindFirstArgs} args - Arguments to find a OperationInspectionRecord
     * @example
     * // Get one OperationInspectionRecord
     * const operationInspectionRecord = await prisma.operationInspectionRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OperationInspectionRecordFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OperationInspectionRecordFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'OperationInspectionRecord'> extends True ? Prisma__OperationInspectionRecordClient<OperationInspectionRecordGetPayload<T>> : Prisma__OperationInspectionRecordClient<OperationInspectionRecordGetPayload<T> | null, null>

    /**
     * Find the first OperationInspectionRecord that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationInspectionRecordFindFirstOrThrowArgs} args - Arguments to find a OperationInspectionRecord
     * @example
     * // Get one OperationInspectionRecord
     * const operationInspectionRecord = await prisma.operationInspectionRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OperationInspectionRecordFindFirstOrThrowArgs>(
      args?: SelectSubset<T, OperationInspectionRecordFindFirstOrThrowArgs>
    ): Prisma__OperationInspectionRecordClient<OperationInspectionRecordGetPayload<T>>

    /**
     * Find zero or more OperationInspectionRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationInspectionRecordFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OperationInspectionRecords
     * const operationInspectionRecords = await prisma.operationInspectionRecord.findMany()
     * 
     * // Get first 10 OperationInspectionRecords
     * const operationInspectionRecords = await prisma.operationInspectionRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const operationInspectionRecordWithIdOnly = await prisma.operationInspectionRecord.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OperationInspectionRecordFindManyArgs>(
      args?: SelectSubset<T, OperationInspectionRecordFindManyArgs>
    ): Prisma.PrismaPromise<Array<OperationInspectionRecordGetPayload<T>>>

    /**
     * Create a OperationInspectionRecord.
     * @param {OperationInspectionRecordCreateArgs} args - Arguments to create a OperationInspectionRecord.
     * @example
     * // Create one OperationInspectionRecord
     * const OperationInspectionRecord = await prisma.operationInspectionRecord.create({
     *   data: {
     *     // ... data to create a OperationInspectionRecord
     *   }
     * })
     * 
    **/
    create<T extends OperationInspectionRecordCreateArgs>(
      args: SelectSubset<T, OperationInspectionRecordCreateArgs>
    ): Prisma__OperationInspectionRecordClient<OperationInspectionRecordGetPayload<T>>

    /**
     * Create many OperationInspectionRecords.
     *     @param {OperationInspectionRecordCreateManyArgs} args - Arguments to create many OperationInspectionRecords.
     *     @example
     *     // Create many OperationInspectionRecords
     *     const operationInspectionRecord = await prisma.operationInspectionRecord.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OperationInspectionRecordCreateManyArgs>(
      args?: SelectSubset<T, OperationInspectionRecordCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OperationInspectionRecord.
     * @param {OperationInspectionRecordDeleteArgs} args - Arguments to delete one OperationInspectionRecord.
     * @example
     * // Delete one OperationInspectionRecord
     * const OperationInspectionRecord = await prisma.operationInspectionRecord.delete({
     *   where: {
     *     // ... filter to delete one OperationInspectionRecord
     *   }
     * })
     * 
    **/
    delete<T extends OperationInspectionRecordDeleteArgs>(
      args: SelectSubset<T, OperationInspectionRecordDeleteArgs>
    ): Prisma__OperationInspectionRecordClient<OperationInspectionRecordGetPayload<T>>

    /**
     * Update one OperationInspectionRecord.
     * @param {OperationInspectionRecordUpdateArgs} args - Arguments to update one OperationInspectionRecord.
     * @example
     * // Update one OperationInspectionRecord
     * const operationInspectionRecord = await prisma.operationInspectionRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OperationInspectionRecordUpdateArgs>(
      args: SelectSubset<T, OperationInspectionRecordUpdateArgs>
    ): Prisma__OperationInspectionRecordClient<OperationInspectionRecordGetPayload<T>>

    /**
     * Delete zero or more OperationInspectionRecords.
     * @param {OperationInspectionRecordDeleteManyArgs} args - Arguments to filter OperationInspectionRecords to delete.
     * @example
     * // Delete a few OperationInspectionRecords
     * const { count } = await prisma.operationInspectionRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OperationInspectionRecordDeleteManyArgs>(
      args?: SelectSubset<T, OperationInspectionRecordDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OperationInspectionRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationInspectionRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OperationInspectionRecords
     * const operationInspectionRecord = await prisma.operationInspectionRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OperationInspectionRecordUpdateManyArgs>(
      args: SelectSubset<T, OperationInspectionRecordUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OperationInspectionRecord.
     * @param {OperationInspectionRecordUpsertArgs} args - Arguments to update or create a OperationInspectionRecord.
     * @example
     * // Update or create a OperationInspectionRecord
     * const operationInspectionRecord = await prisma.operationInspectionRecord.upsert({
     *   create: {
     *     // ... data to create a OperationInspectionRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OperationInspectionRecord we want to update
     *   }
     * })
    **/
    upsert<T extends OperationInspectionRecordUpsertArgs>(
      args: SelectSubset<T, OperationInspectionRecordUpsertArgs>
    ): Prisma__OperationInspectionRecordClient<OperationInspectionRecordGetPayload<T>>

    /**
     * Count the number of OperationInspectionRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationInspectionRecordCountArgs} args - Arguments to filter OperationInspectionRecords to count.
     * @example
     * // Count the number of OperationInspectionRecords
     * const count = await prisma.operationInspectionRecord.count({
     *   where: {
     *     // ... the filter for the OperationInspectionRecords we want to count
     *   }
     * })
    **/
    count<T extends OperationInspectionRecordCountArgs>(
      args?: Subset<T, OperationInspectionRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OperationInspectionRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OperationInspectionRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationInspectionRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OperationInspectionRecordAggregateArgs>(args: Subset<T, OperationInspectionRecordAggregateArgs>): Prisma.PrismaPromise<GetOperationInspectionRecordAggregateType<T>>

    /**
     * Group by OperationInspectionRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationInspectionRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OperationInspectionRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OperationInspectionRecordGroupByArgs['orderBy'] }
        : { orderBy?: OperationInspectionRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OperationInspectionRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOperationInspectionRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for OperationInspectionRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OperationInspectionRecordClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    workerOrder<T extends WorkerOrderArgs= {}>(args?: Subset<T, WorkerOrderArgs>): Prisma__WorkerOrderClient<WorkerOrderGetPayload<T> | Null>;

    inspector<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    reviewer<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    operationInspectionRecordItems<T extends OperationInspectionRecord$operationInspectionRecordItemsArgs= {}>(args?: Subset<T, OperationInspectionRecord$operationInspectionRecordItemsArgs>): Prisma.PrismaPromise<Array<OperationInspectionRecordItemGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * OperationInspectionRecord base type for findUnique actions
   */
  export type OperationInspectionRecordFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the OperationInspectionRecord
     */
    select?: OperationInspectionRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OperationInspectionRecordInclude | null
    /**
     * Filter, which OperationInspectionRecord to fetch.
     */
    where: OperationInspectionRecordWhereUniqueInput
  }

  /**
   * OperationInspectionRecord findUnique
   */
  export interface OperationInspectionRecordFindUniqueArgs extends OperationInspectionRecordFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * OperationInspectionRecord findUniqueOrThrow
   */
  export type OperationInspectionRecordFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the OperationInspectionRecord
     */
    select?: OperationInspectionRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OperationInspectionRecordInclude | null
    /**
     * Filter, which OperationInspectionRecord to fetch.
     */
    where: OperationInspectionRecordWhereUniqueInput
  }


  /**
   * OperationInspectionRecord base type for findFirst actions
   */
  export type OperationInspectionRecordFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the OperationInspectionRecord
     */
    select?: OperationInspectionRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OperationInspectionRecordInclude | null
    /**
     * Filter, which OperationInspectionRecord to fetch.
     */
    where?: OperationInspectionRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperationInspectionRecords to fetch.
     */
    orderBy?: Enumerable<OperationInspectionRecordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OperationInspectionRecords.
     */
    cursor?: OperationInspectionRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperationInspectionRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperationInspectionRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OperationInspectionRecords.
     */
    distinct?: Enumerable<OperationInspectionRecordScalarFieldEnum>
  }

  /**
   * OperationInspectionRecord findFirst
   */
  export interface OperationInspectionRecordFindFirstArgs extends OperationInspectionRecordFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * OperationInspectionRecord findFirstOrThrow
   */
  export type OperationInspectionRecordFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the OperationInspectionRecord
     */
    select?: OperationInspectionRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OperationInspectionRecordInclude | null
    /**
     * Filter, which OperationInspectionRecord to fetch.
     */
    where?: OperationInspectionRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperationInspectionRecords to fetch.
     */
    orderBy?: Enumerable<OperationInspectionRecordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OperationInspectionRecords.
     */
    cursor?: OperationInspectionRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperationInspectionRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperationInspectionRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OperationInspectionRecords.
     */
    distinct?: Enumerable<OperationInspectionRecordScalarFieldEnum>
  }


  /**
   * OperationInspectionRecord findMany
   */
  export type OperationInspectionRecordFindManyArgs = {
    /**
     * Select specific fields to fetch from the OperationInspectionRecord
     */
    select?: OperationInspectionRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OperationInspectionRecordInclude | null
    /**
     * Filter, which OperationInspectionRecords to fetch.
     */
    where?: OperationInspectionRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperationInspectionRecords to fetch.
     */
    orderBy?: Enumerable<OperationInspectionRecordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OperationInspectionRecords.
     */
    cursor?: OperationInspectionRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperationInspectionRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperationInspectionRecords.
     */
    skip?: number
    distinct?: Enumerable<OperationInspectionRecordScalarFieldEnum>
  }


  /**
   * OperationInspectionRecord create
   */
  export type OperationInspectionRecordCreateArgs = {
    /**
     * Select specific fields to fetch from the OperationInspectionRecord
     */
    select?: OperationInspectionRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OperationInspectionRecordInclude | null
    /**
     * The data needed to create a OperationInspectionRecord.
     */
    data: XOR<OperationInspectionRecordCreateInput, OperationInspectionRecordUncheckedCreateInput>
  }


  /**
   * OperationInspectionRecord createMany
   */
  export type OperationInspectionRecordCreateManyArgs = {
    /**
     * The data used to create many OperationInspectionRecords.
     */
    data: Enumerable<OperationInspectionRecordCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * OperationInspectionRecord update
   */
  export type OperationInspectionRecordUpdateArgs = {
    /**
     * Select specific fields to fetch from the OperationInspectionRecord
     */
    select?: OperationInspectionRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OperationInspectionRecordInclude | null
    /**
     * The data needed to update a OperationInspectionRecord.
     */
    data: XOR<OperationInspectionRecordUpdateInput, OperationInspectionRecordUncheckedUpdateInput>
    /**
     * Choose, which OperationInspectionRecord to update.
     */
    where: OperationInspectionRecordWhereUniqueInput
  }


  /**
   * OperationInspectionRecord updateMany
   */
  export type OperationInspectionRecordUpdateManyArgs = {
    /**
     * The data used to update OperationInspectionRecords.
     */
    data: XOR<OperationInspectionRecordUpdateManyMutationInput, OperationInspectionRecordUncheckedUpdateManyInput>
    /**
     * Filter which OperationInspectionRecords to update
     */
    where?: OperationInspectionRecordWhereInput
  }


  /**
   * OperationInspectionRecord upsert
   */
  export type OperationInspectionRecordUpsertArgs = {
    /**
     * Select specific fields to fetch from the OperationInspectionRecord
     */
    select?: OperationInspectionRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OperationInspectionRecordInclude | null
    /**
     * The filter to search for the OperationInspectionRecord to update in case it exists.
     */
    where: OperationInspectionRecordWhereUniqueInput
    /**
     * In case the OperationInspectionRecord found by the `where` argument doesn't exist, create a new OperationInspectionRecord with this data.
     */
    create: XOR<OperationInspectionRecordCreateInput, OperationInspectionRecordUncheckedCreateInput>
    /**
     * In case the OperationInspectionRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OperationInspectionRecordUpdateInput, OperationInspectionRecordUncheckedUpdateInput>
  }


  /**
   * OperationInspectionRecord delete
   */
  export type OperationInspectionRecordDeleteArgs = {
    /**
     * Select specific fields to fetch from the OperationInspectionRecord
     */
    select?: OperationInspectionRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OperationInspectionRecordInclude | null
    /**
     * Filter which OperationInspectionRecord to delete.
     */
    where: OperationInspectionRecordWhereUniqueInput
  }


  /**
   * OperationInspectionRecord deleteMany
   */
  export type OperationInspectionRecordDeleteManyArgs = {
    /**
     * Filter which OperationInspectionRecords to delete
     */
    where?: OperationInspectionRecordWhereInput
  }


  /**
   * OperationInspectionRecord.operationInspectionRecordItems
   */
  export type OperationInspectionRecord$operationInspectionRecordItemsArgs = {
    /**
     * Select specific fields to fetch from the OperationInspectionRecordItem
     */
    select?: OperationInspectionRecordItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OperationInspectionRecordItemInclude | null
    where?: OperationInspectionRecordItemWhereInput
    orderBy?: Enumerable<OperationInspectionRecordItemOrderByWithRelationInput>
    cursor?: OperationInspectionRecordItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<OperationInspectionRecordItemScalarFieldEnum>
  }


  /**
   * OperationInspectionRecord without action
   */
  export type OperationInspectionRecordArgs = {
    /**
     * Select specific fields to fetch from the OperationInspectionRecord
     */
    select?: OperationInspectionRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OperationInspectionRecordInclude | null
  }



  /**
   * Model OperationInspectionRecordItem
   */


  export type AggregateOperationInspectionRecordItem = {
    _count: OperationInspectionRecordItemCountAggregateOutputType | null
    _avg: OperationInspectionRecordItemAvgAggregateOutputType | null
    _sum: OperationInspectionRecordItemSumAggregateOutputType | null
    _min: OperationInspectionRecordItemMinAggregateOutputType | null
    _max: OperationInspectionRecordItemMaxAggregateOutputType | null
  }

  export type OperationInspectionRecordItemAvgAggregateOutputType = {
    id: number | null
    partOperationInspectionItemId: number | null
    operationInspectionRecordId: number | null
  }

  export type OperationInspectionRecordItemSumAggregateOutputType = {
    id: number | null
    partOperationInspectionItemId: number | null
    operationInspectionRecordId: number | null
  }

  export type OperationInspectionRecordItemMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    inspectionIteration: string | null
    partOperationInspectionItemId: number | null
    operationInspectionRecordId: number | null
  }

  export type OperationInspectionRecordItemMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    inspectionIteration: string | null
    partOperationInspectionItemId: number | null
    operationInspectionRecordId: number | null
  }

  export type OperationInspectionRecordItemCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    isDeleted: number
    inspectionIteration: number
    partOperationInspectionItemId: number
    operationInspectionRecordId: number
    _all: number
  }


  export type OperationInspectionRecordItemAvgAggregateInputType = {
    id?: true
    partOperationInspectionItemId?: true
    operationInspectionRecordId?: true
  }

  export type OperationInspectionRecordItemSumAggregateInputType = {
    id?: true
    partOperationInspectionItemId?: true
    operationInspectionRecordId?: true
  }

  export type OperationInspectionRecordItemMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    inspectionIteration?: true
    partOperationInspectionItemId?: true
    operationInspectionRecordId?: true
  }

  export type OperationInspectionRecordItemMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    inspectionIteration?: true
    partOperationInspectionItemId?: true
    operationInspectionRecordId?: true
  }

  export type OperationInspectionRecordItemCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    inspectionIteration?: true
    partOperationInspectionItemId?: true
    operationInspectionRecordId?: true
    _all?: true
  }

  export type OperationInspectionRecordItemAggregateArgs = {
    /**
     * Filter which OperationInspectionRecordItem to aggregate.
     */
    where?: OperationInspectionRecordItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperationInspectionRecordItems to fetch.
     */
    orderBy?: Enumerable<OperationInspectionRecordItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OperationInspectionRecordItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperationInspectionRecordItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperationInspectionRecordItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OperationInspectionRecordItems
    **/
    _count?: true | OperationInspectionRecordItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OperationInspectionRecordItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OperationInspectionRecordItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OperationInspectionRecordItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OperationInspectionRecordItemMaxAggregateInputType
  }

  export type GetOperationInspectionRecordItemAggregateType<T extends OperationInspectionRecordItemAggregateArgs> = {
        [P in keyof T & keyof AggregateOperationInspectionRecordItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOperationInspectionRecordItem[P]>
      : GetScalarType<T[P], AggregateOperationInspectionRecordItem[P]>
  }




  export type OperationInspectionRecordItemGroupByArgs = {
    where?: OperationInspectionRecordItemWhereInput
    orderBy?: Enumerable<OperationInspectionRecordItemOrderByWithAggregationInput>
    by: OperationInspectionRecordItemScalarFieldEnum[]
    having?: OperationInspectionRecordItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OperationInspectionRecordItemCountAggregateInputType | true
    _avg?: OperationInspectionRecordItemAvgAggregateInputType
    _sum?: OperationInspectionRecordItemSumAggregateInputType
    _min?: OperationInspectionRecordItemMinAggregateInputType
    _max?: OperationInspectionRecordItemMaxAggregateInputType
  }


  export type OperationInspectionRecordItemGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    isDeleted: boolean
    inspectionIteration: string
    partOperationInspectionItemId: number
    operationInspectionRecordId: number
    _count: OperationInspectionRecordItemCountAggregateOutputType | null
    _avg: OperationInspectionRecordItemAvgAggregateOutputType | null
    _sum: OperationInspectionRecordItemSumAggregateOutputType | null
    _min: OperationInspectionRecordItemMinAggregateOutputType | null
    _max: OperationInspectionRecordItemMaxAggregateOutputType | null
  }

  type GetOperationInspectionRecordItemGroupByPayload<T extends OperationInspectionRecordItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<OperationInspectionRecordItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OperationInspectionRecordItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OperationInspectionRecordItemGroupByOutputType[P]>
            : GetScalarType<T[P], OperationInspectionRecordItemGroupByOutputType[P]>
        }
      >
    >


  export type OperationInspectionRecordItemSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    inspectionIteration?: boolean
    partOperationInspectionItemId?: boolean
    operationInspectionRecordId?: boolean
    partOperationInspectionItem?: boolean | PartOperationInspectionItemArgs
    operationInspectionRecord?: boolean | OperationInspectionRecordArgs
  }


  export type OperationInspectionRecordItemInclude = {
    partOperationInspectionItem?: boolean | PartOperationInspectionItemArgs
    operationInspectionRecord?: boolean | OperationInspectionRecordArgs
  }

  export type OperationInspectionRecordItemGetPayload<S extends boolean | null | undefined | OperationInspectionRecordItemArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? OperationInspectionRecordItem :
    S extends undefined ? never :
    S extends { include: any } & (OperationInspectionRecordItemArgs | OperationInspectionRecordItemFindManyArgs)
    ? OperationInspectionRecordItem  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'partOperationInspectionItem' ? PartOperationInspectionItemGetPayload<S['include'][P]> :
        P extends 'operationInspectionRecord' ? OperationInspectionRecordGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (OperationInspectionRecordItemArgs | OperationInspectionRecordItemFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'partOperationInspectionItem' ? PartOperationInspectionItemGetPayload<S['select'][P]> :
        P extends 'operationInspectionRecord' ? OperationInspectionRecordGetPayload<S['select'][P]> :  P extends keyof OperationInspectionRecordItem ? OperationInspectionRecordItem[P] : never
  } 
      : OperationInspectionRecordItem


  type OperationInspectionRecordItemCountArgs = 
    Omit<OperationInspectionRecordItemFindManyArgs, 'select' | 'include'> & {
      select?: OperationInspectionRecordItemCountAggregateInputType | true
    }

  export interface OperationInspectionRecordItemDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one OperationInspectionRecordItem that matches the filter.
     * @param {OperationInspectionRecordItemFindUniqueArgs} args - Arguments to find a OperationInspectionRecordItem
     * @example
     * // Get one OperationInspectionRecordItem
     * const operationInspectionRecordItem = await prisma.operationInspectionRecordItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OperationInspectionRecordItemFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OperationInspectionRecordItemFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'OperationInspectionRecordItem'> extends True ? Prisma__OperationInspectionRecordItemClient<OperationInspectionRecordItemGetPayload<T>> : Prisma__OperationInspectionRecordItemClient<OperationInspectionRecordItemGetPayload<T> | null, null>

    /**
     * Find one OperationInspectionRecordItem that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OperationInspectionRecordItemFindUniqueOrThrowArgs} args - Arguments to find a OperationInspectionRecordItem
     * @example
     * // Get one OperationInspectionRecordItem
     * const operationInspectionRecordItem = await prisma.operationInspectionRecordItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OperationInspectionRecordItemFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, OperationInspectionRecordItemFindUniqueOrThrowArgs>
    ): Prisma__OperationInspectionRecordItemClient<OperationInspectionRecordItemGetPayload<T>>

    /**
     * Find the first OperationInspectionRecordItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationInspectionRecordItemFindFirstArgs} args - Arguments to find a OperationInspectionRecordItem
     * @example
     * // Get one OperationInspectionRecordItem
     * const operationInspectionRecordItem = await prisma.operationInspectionRecordItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OperationInspectionRecordItemFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OperationInspectionRecordItemFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'OperationInspectionRecordItem'> extends True ? Prisma__OperationInspectionRecordItemClient<OperationInspectionRecordItemGetPayload<T>> : Prisma__OperationInspectionRecordItemClient<OperationInspectionRecordItemGetPayload<T> | null, null>

    /**
     * Find the first OperationInspectionRecordItem that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationInspectionRecordItemFindFirstOrThrowArgs} args - Arguments to find a OperationInspectionRecordItem
     * @example
     * // Get one OperationInspectionRecordItem
     * const operationInspectionRecordItem = await prisma.operationInspectionRecordItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OperationInspectionRecordItemFindFirstOrThrowArgs>(
      args?: SelectSubset<T, OperationInspectionRecordItemFindFirstOrThrowArgs>
    ): Prisma__OperationInspectionRecordItemClient<OperationInspectionRecordItemGetPayload<T>>

    /**
     * Find zero or more OperationInspectionRecordItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationInspectionRecordItemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OperationInspectionRecordItems
     * const operationInspectionRecordItems = await prisma.operationInspectionRecordItem.findMany()
     * 
     * // Get first 10 OperationInspectionRecordItems
     * const operationInspectionRecordItems = await prisma.operationInspectionRecordItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const operationInspectionRecordItemWithIdOnly = await prisma.operationInspectionRecordItem.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OperationInspectionRecordItemFindManyArgs>(
      args?: SelectSubset<T, OperationInspectionRecordItemFindManyArgs>
    ): Prisma.PrismaPromise<Array<OperationInspectionRecordItemGetPayload<T>>>

    /**
     * Create a OperationInspectionRecordItem.
     * @param {OperationInspectionRecordItemCreateArgs} args - Arguments to create a OperationInspectionRecordItem.
     * @example
     * // Create one OperationInspectionRecordItem
     * const OperationInspectionRecordItem = await prisma.operationInspectionRecordItem.create({
     *   data: {
     *     // ... data to create a OperationInspectionRecordItem
     *   }
     * })
     * 
    **/
    create<T extends OperationInspectionRecordItemCreateArgs>(
      args: SelectSubset<T, OperationInspectionRecordItemCreateArgs>
    ): Prisma__OperationInspectionRecordItemClient<OperationInspectionRecordItemGetPayload<T>>

    /**
     * Create many OperationInspectionRecordItems.
     *     @param {OperationInspectionRecordItemCreateManyArgs} args - Arguments to create many OperationInspectionRecordItems.
     *     @example
     *     // Create many OperationInspectionRecordItems
     *     const operationInspectionRecordItem = await prisma.operationInspectionRecordItem.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OperationInspectionRecordItemCreateManyArgs>(
      args?: SelectSubset<T, OperationInspectionRecordItemCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OperationInspectionRecordItem.
     * @param {OperationInspectionRecordItemDeleteArgs} args - Arguments to delete one OperationInspectionRecordItem.
     * @example
     * // Delete one OperationInspectionRecordItem
     * const OperationInspectionRecordItem = await prisma.operationInspectionRecordItem.delete({
     *   where: {
     *     // ... filter to delete one OperationInspectionRecordItem
     *   }
     * })
     * 
    **/
    delete<T extends OperationInspectionRecordItemDeleteArgs>(
      args: SelectSubset<T, OperationInspectionRecordItemDeleteArgs>
    ): Prisma__OperationInspectionRecordItemClient<OperationInspectionRecordItemGetPayload<T>>

    /**
     * Update one OperationInspectionRecordItem.
     * @param {OperationInspectionRecordItemUpdateArgs} args - Arguments to update one OperationInspectionRecordItem.
     * @example
     * // Update one OperationInspectionRecordItem
     * const operationInspectionRecordItem = await prisma.operationInspectionRecordItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OperationInspectionRecordItemUpdateArgs>(
      args: SelectSubset<T, OperationInspectionRecordItemUpdateArgs>
    ): Prisma__OperationInspectionRecordItemClient<OperationInspectionRecordItemGetPayload<T>>

    /**
     * Delete zero or more OperationInspectionRecordItems.
     * @param {OperationInspectionRecordItemDeleteManyArgs} args - Arguments to filter OperationInspectionRecordItems to delete.
     * @example
     * // Delete a few OperationInspectionRecordItems
     * const { count } = await prisma.operationInspectionRecordItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OperationInspectionRecordItemDeleteManyArgs>(
      args?: SelectSubset<T, OperationInspectionRecordItemDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OperationInspectionRecordItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationInspectionRecordItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OperationInspectionRecordItems
     * const operationInspectionRecordItem = await prisma.operationInspectionRecordItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OperationInspectionRecordItemUpdateManyArgs>(
      args: SelectSubset<T, OperationInspectionRecordItemUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OperationInspectionRecordItem.
     * @param {OperationInspectionRecordItemUpsertArgs} args - Arguments to update or create a OperationInspectionRecordItem.
     * @example
     * // Update or create a OperationInspectionRecordItem
     * const operationInspectionRecordItem = await prisma.operationInspectionRecordItem.upsert({
     *   create: {
     *     // ... data to create a OperationInspectionRecordItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OperationInspectionRecordItem we want to update
     *   }
     * })
    **/
    upsert<T extends OperationInspectionRecordItemUpsertArgs>(
      args: SelectSubset<T, OperationInspectionRecordItemUpsertArgs>
    ): Prisma__OperationInspectionRecordItemClient<OperationInspectionRecordItemGetPayload<T>>

    /**
     * Count the number of OperationInspectionRecordItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationInspectionRecordItemCountArgs} args - Arguments to filter OperationInspectionRecordItems to count.
     * @example
     * // Count the number of OperationInspectionRecordItems
     * const count = await prisma.operationInspectionRecordItem.count({
     *   where: {
     *     // ... the filter for the OperationInspectionRecordItems we want to count
     *   }
     * })
    **/
    count<T extends OperationInspectionRecordItemCountArgs>(
      args?: Subset<T, OperationInspectionRecordItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OperationInspectionRecordItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OperationInspectionRecordItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationInspectionRecordItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OperationInspectionRecordItemAggregateArgs>(args: Subset<T, OperationInspectionRecordItemAggregateArgs>): Prisma.PrismaPromise<GetOperationInspectionRecordItemAggregateType<T>>

    /**
     * Group by OperationInspectionRecordItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationInspectionRecordItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OperationInspectionRecordItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OperationInspectionRecordItemGroupByArgs['orderBy'] }
        : { orderBy?: OperationInspectionRecordItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OperationInspectionRecordItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOperationInspectionRecordItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for OperationInspectionRecordItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OperationInspectionRecordItemClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    partOperationInspectionItem<T extends PartOperationInspectionItemArgs= {}>(args?: Subset<T, PartOperationInspectionItemArgs>): Prisma__PartOperationInspectionItemClient<PartOperationInspectionItemGetPayload<T> | Null>;

    operationInspectionRecord<T extends OperationInspectionRecordArgs= {}>(args?: Subset<T, OperationInspectionRecordArgs>): Prisma__OperationInspectionRecordClient<OperationInspectionRecordGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * OperationInspectionRecordItem base type for findUnique actions
   */
  export type OperationInspectionRecordItemFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the OperationInspectionRecordItem
     */
    select?: OperationInspectionRecordItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OperationInspectionRecordItemInclude | null
    /**
     * Filter, which OperationInspectionRecordItem to fetch.
     */
    where: OperationInspectionRecordItemWhereUniqueInput
  }

  /**
   * OperationInspectionRecordItem findUnique
   */
  export interface OperationInspectionRecordItemFindUniqueArgs extends OperationInspectionRecordItemFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * OperationInspectionRecordItem findUniqueOrThrow
   */
  export type OperationInspectionRecordItemFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the OperationInspectionRecordItem
     */
    select?: OperationInspectionRecordItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OperationInspectionRecordItemInclude | null
    /**
     * Filter, which OperationInspectionRecordItem to fetch.
     */
    where: OperationInspectionRecordItemWhereUniqueInput
  }


  /**
   * OperationInspectionRecordItem base type for findFirst actions
   */
  export type OperationInspectionRecordItemFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the OperationInspectionRecordItem
     */
    select?: OperationInspectionRecordItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OperationInspectionRecordItemInclude | null
    /**
     * Filter, which OperationInspectionRecordItem to fetch.
     */
    where?: OperationInspectionRecordItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperationInspectionRecordItems to fetch.
     */
    orderBy?: Enumerable<OperationInspectionRecordItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OperationInspectionRecordItems.
     */
    cursor?: OperationInspectionRecordItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperationInspectionRecordItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperationInspectionRecordItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OperationInspectionRecordItems.
     */
    distinct?: Enumerable<OperationInspectionRecordItemScalarFieldEnum>
  }

  /**
   * OperationInspectionRecordItem findFirst
   */
  export interface OperationInspectionRecordItemFindFirstArgs extends OperationInspectionRecordItemFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * OperationInspectionRecordItem findFirstOrThrow
   */
  export type OperationInspectionRecordItemFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the OperationInspectionRecordItem
     */
    select?: OperationInspectionRecordItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OperationInspectionRecordItemInclude | null
    /**
     * Filter, which OperationInspectionRecordItem to fetch.
     */
    where?: OperationInspectionRecordItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperationInspectionRecordItems to fetch.
     */
    orderBy?: Enumerable<OperationInspectionRecordItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OperationInspectionRecordItems.
     */
    cursor?: OperationInspectionRecordItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperationInspectionRecordItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperationInspectionRecordItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OperationInspectionRecordItems.
     */
    distinct?: Enumerable<OperationInspectionRecordItemScalarFieldEnum>
  }


  /**
   * OperationInspectionRecordItem findMany
   */
  export type OperationInspectionRecordItemFindManyArgs = {
    /**
     * Select specific fields to fetch from the OperationInspectionRecordItem
     */
    select?: OperationInspectionRecordItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OperationInspectionRecordItemInclude | null
    /**
     * Filter, which OperationInspectionRecordItems to fetch.
     */
    where?: OperationInspectionRecordItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperationInspectionRecordItems to fetch.
     */
    orderBy?: Enumerable<OperationInspectionRecordItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OperationInspectionRecordItems.
     */
    cursor?: OperationInspectionRecordItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperationInspectionRecordItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperationInspectionRecordItems.
     */
    skip?: number
    distinct?: Enumerable<OperationInspectionRecordItemScalarFieldEnum>
  }


  /**
   * OperationInspectionRecordItem create
   */
  export type OperationInspectionRecordItemCreateArgs = {
    /**
     * Select specific fields to fetch from the OperationInspectionRecordItem
     */
    select?: OperationInspectionRecordItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OperationInspectionRecordItemInclude | null
    /**
     * The data needed to create a OperationInspectionRecordItem.
     */
    data: XOR<OperationInspectionRecordItemCreateInput, OperationInspectionRecordItemUncheckedCreateInput>
  }


  /**
   * OperationInspectionRecordItem createMany
   */
  export type OperationInspectionRecordItemCreateManyArgs = {
    /**
     * The data used to create many OperationInspectionRecordItems.
     */
    data: Enumerable<OperationInspectionRecordItemCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * OperationInspectionRecordItem update
   */
  export type OperationInspectionRecordItemUpdateArgs = {
    /**
     * Select specific fields to fetch from the OperationInspectionRecordItem
     */
    select?: OperationInspectionRecordItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OperationInspectionRecordItemInclude | null
    /**
     * The data needed to update a OperationInspectionRecordItem.
     */
    data: XOR<OperationInspectionRecordItemUpdateInput, OperationInspectionRecordItemUncheckedUpdateInput>
    /**
     * Choose, which OperationInspectionRecordItem to update.
     */
    where: OperationInspectionRecordItemWhereUniqueInput
  }


  /**
   * OperationInspectionRecordItem updateMany
   */
  export type OperationInspectionRecordItemUpdateManyArgs = {
    /**
     * The data used to update OperationInspectionRecordItems.
     */
    data: XOR<OperationInspectionRecordItemUpdateManyMutationInput, OperationInspectionRecordItemUncheckedUpdateManyInput>
    /**
     * Filter which OperationInspectionRecordItems to update
     */
    where?: OperationInspectionRecordItemWhereInput
  }


  /**
   * OperationInspectionRecordItem upsert
   */
  export type OperationInspectionRecordItemUpsertArgs = {
    /**
     * Select specific fields to fetch from the OperationInspectionRecordItem
     */
    select?: OperationInspectionRecordItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OperationInspectionRecordItemInclude | null
    /**
     * The filter to search for the OperationInspectionRecordItem to update in case it exists.
     */
    where: OperationInspectionRecordItemWhereUniqueInput
    /**
     * In case the OperationInspectionRecordItem found by the `where` argument doesn't exist, create a new OperationInspectionRecordItem with this data.
     */
    create: XOR<OperationInspectionRecordItemCreateInput, OperationInspectionRecordItemUncheckedCreateInput>
    /**
     * In case the OperationInspectionRecordItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OperationInspectionRecordItemUpdateInput, OperationInspectionRecordItemUncheckedUpdateInput>
  }


  /**
   * OperationInspectionRecordItem delete
   */
  export type OperationInspectionRecordItemDeleteArgs = {
    /**
     * Select specific fields to fetch from the OperationInspectionRecordItem
     */
    select?: OperationInspectionRecordItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OperationInspectionRecordItemInclude | null
    /**
     * Filter which OperationInspectionRecordItem to delete.
     */
    where: OperationInspectionRecordItemWhereUniqueInput
  }


  /**
   * OperationInspectionRecordItem deleteMany
   */
  export type OperationInspectionRecordItemDeleteManyArgs = {
    /**
     * Filter which OperationInspectionRecordItems to delete
     */
    where?: OperationInspectionRecordItemWhereInput
  }


  /**
   * OperationInspectionRecordItem without action
   */
  export type OperationInspectionRecordItemArgs = {
    /**
     * Select specific fields to fetch from the OperationInspectionRecordItem
     */
    select?: OperationInspectionRecordItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OperationInspectionRecordItemInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const EquipmentScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isDeleted: 'isDeleted',
    name: 'name',
    description: 'description',
    repairPlan: 'repairPlan',
    workStation: 'workStation',
    productLineId: 'productLineId'
  };

  export type EquipmentScalarFieldEnum = (typeof EquipmentScalarFieldEnum)[keyof typeof EquipmentScalarFieldEnum]


  export const IncomingInspectionRecordItemScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isDeleted: 'isDeleted',
    result: 'result',
    inspectionIteration: 'inspectionIteration',
    incomingInspectionRecordId: 'incomingInspectionRecordId',
    incomingInspectionSpecItemId: 'incomingInspectionSpecItemId'
  };

  export type IncomingInspectionRecordItemScalarFieldEnum = (typeof IncomingInspectionRecordItemScalarFieldEnum)[keyof typeof IncomingInspectionRecordItemScalarFieldEnum]


  export const IncomingInspectionRecordScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isDeleted: 'isDeleted',
    note: 'note',
    result: 'result',
    receiptId: 'receiptId',
    incomingInspectionSpecId: 'incomingInspectionSpecId'
  };

  export type IncomingInspectionRecordScalarFieldEnum = (typeof IncomingInspectionRecordScalarFieldEnum)[keyof typeof IncomingInspectionRecordScalarFieldEnum]


  export const IncomingInspectionSpecItemScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isDeleted: 'isDeleted',
    no: 'no',
    name: 'name',
    spec: 'spec',
    incomingInspectionSpecId: 'incomingInspectionSpecId'
  };

  export type IncomingInspectionSpecItemScalarFieldEnum = (typeof IncomingInspectionSpecItemScalarFieldEnum)[keyof typeof IncomingInspectionSpecItemScalarFieldEnum]


  export const IncomingInspectionSpecScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isDeleted: 'isDeleted',
    version: 'version',
    attachment: 'attachment',
    partVersionId: 'partVersionId'
  };

  export type IncomingInspectionSpecScalarFieldEnum = (typeof IncomingInspectionSpecScalarFieldEnum)[keyof typeof IncomingInspectionSpecScalarFieldEnum]


  export const NonconformItemScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isDeleted: 'isDeleted',
    partId: 'partId',
    description: 'description',
    note: 'note'
  };

  export type NonconformItemScalarFieldEnum = (typeof NonconformItemScalarFieldEnum)[keyof typeof NonconformItemScalarFieldEnum]


  export const OperationInspectionRecordItemScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isDeleted: 'isDeleted',
    inspectionIteration: 'inspectionIteration',
    partOperationInspectionItemId: 'partOperationInspectionItemId',
    operationInspectionRecordId: 'operationInspectionRecordId'
  };

  export type OperationInspectionRecordItemScalarFieldEnum = (typeof OperationInspectionRecordItemScalarFieldEnum)[keyof typeof OperationInspectionRecordItemScalarFieldEnum]


  export const OperationInspectionRecordScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isDeleted: 'isDeleted',
    note: 'note',
    workerOrderId: 'workerOrderId',
    inspectorId: 'inspectorId',
    reviewerId: 'reviewerId'
  };

  export type OperationInspectionRecordScalarFieldEnum = (typeof OperationInspectionRecordScalarFieldEnum)[keyof typeof OperationInspectionRecordScalarFieldEnum]


  export const PartOperationInspectionItemScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isDeleted: 'isDeleted',
    name: 'name',
    partOperationId: 'partOperationId'
  };

  export type PartOperationInspectionItemScalarFieldEnum = (typeof PartOperationInspectionItemScalarFieldEnum)[keyof typeof PartOperationInspectionItemScalarFieldEnum]


  export const PartOperationScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isDeleted: 'isDeleted',
    version: 'version',
    no: 'no',
    name: 'name',
    partId: 'partId'
  };

  export type PartOperationScalarFieldEnum = (typeof PartOperationScalarFieldEnum)[keyof typeof PartOperationScalarFieldEnum]


  export const PartScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isDeleted: 'isDeleted',
    no: 'no',
    name: 'name'
  };

  export type PartScalarFieldEnum = (typeof PartScalarFieldEnum)[keyof typeof PartScalarFieldEnum]


  export const PartVersionScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isDeleted: 'isDeleted',
    version: 'version',
    note: 'note',
    partId: 'partId'
  };

  export type PartVersionScalarFieldEnum = (typeof PartVersionScalarFieldEnum)[keyof typeof PartVersionScalarFieldEnum]


  export const ProductLineScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isDeleted: 'isDeleted',
    name: 'name',
    description: 'description'
  };

  export type ProductLineScalarFieldEnum = (typeof ProductLineScalarFieldEnum)[keyof typeof ProductLineScalarFieldEnum]


  export const ReceiptScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isDeleted: 'isDeleted',
    lot: 'lot',
    partVersionId: 'partVersionId'
  };

  export type ReceiptScalarFieldEnum = (typeof ReceiptScalarFieldEnum)[keyof typeof ReceiptScalarFieldEnum]


  export const RepairMaterialInventoryScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isDeleted: 'isDeleted',
    name: 'name',
    description: 'description',
    quantity: 'quantity',
    minimumQuantity: 'minimumQuantity',
    equipmentId: 'equipmentId'
  };

  export type RepairMaterialInventoryScalarFieldEnum = (typeof RepairMaterialInventoryScalarFieldEnum)[keyof typeof RepairMaterialInventoryScalarFieldEnum]


  export const RepairRecordScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isDeleted: 'isDeleted',
    type: 'type',
    equipmentId: 'equipmentId',
    status: 'status',
    description: 'description'
  };

  export type RepairRecordScalarFieldEnum = (typeof RepairRecordScalarFieldEnum)[keyof typeof RepairRecordScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const TaskFormRelationScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isDeleted: 'isDeleted',
    taskDefinitionKey: 'taskDefinitionKey',
    formKey: 'formKey'
  };

  export type TaskFormRelationScalarFieldEnum = (typeof TaskFormRelationScalarFieldEnum)[keyof typeof TaskFormRelationScalarFieldEnum]


  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserProfileScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isDeleted: 'isDeleted',
    userId: 'userId',
    fullName: 'fullName'
  };

  export type UserProfileScalarFieldEnum = (typeof UserProfileScalarFieldEnum)[keyof typeof UserProfileScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isDeleted: 'isDeleted',
    username: 'username',
    hashedPassword: 'hashedPassword',
    hashedRefreshToken: 'hashedRefreshToken',
    status: 'status',
    role: 'role'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const WorkerOrderScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isDeleted: 'isDeleted',
    no: 'no',
    partId: 'partId'
  };

  export type WorkerOrderScalarFieldEnum = (typeof WorkerOrderScalarFieldEnum)[keyof typeof WorkerOrderScalarFieldEnum]


  /**
   * Deep Input Types
   */


  export type TaskFormRelationWhereInput = {
    AND?: Enumerable<TaskFormRelationWhereInput>
    OR?: Enumerable<TaskFormRelationWhereInput>
    NOT?: Enumerable<TaskFormRelationWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    taskDefinitionKey?: StringFilter | string
    formKey?: StringFilter | string
  }

  export type TaskFormRelationOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    taskDefinitionKey?: SortOrder
    formKey?: SortOrder
  }

  export type TaskFormRelationWhereUniqueInput = {
    id?: number
    taskDefinitionKey?: string
  }

  export type TaskFormRelationOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    taskDefinitionKey?: SortOrder
    formKey?: SortOrder
    _count?: TaskFormRelationCountOrderByAggregateInput
    _avg?: TaskFormRelationAvgOrderByAggregateInput
    _max?: TaskFormRelationMaxOrderByAggregateInput
    _min?: TaskFormRelationMinOrderByAggregateInput
    _sum?: TaskFormRelationSumOrderByAggregateInput
  }

  export type TaskFormRelationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TaskFormRelationScalarWhereWithAggregatesInput>
    OR?: Enumerable<TaskFormRelationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TaskFormRelationScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    isDeleted?: BoolWithAggregatesFilter | boolean
    taskDefinitionKey?: StringWithAggregatesFilter | string
    formKey?: StringWithAggregatesFilter | string
  }

  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    username?: StringFilter | string
    hashedPassword?: StringNullableFilter | string | null
    hashedRefreshToken?: StringNullableFilter | string | null
    status?: EnumUserStatusFilter | UserStatus
    role?: EnumUserGroupFilter | UserGroup
    profile?: XOR<UserProfileRelationFilter, UserProfileWhereInput> | null
    reviewedOperationInspectionRecords?: OperationInspectionRecordListRelationFilter
    inspectedOperationInspectionRecords?: OperationInspectionRecordListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    username?: SortOrder
    hashedPassword?: SortOrder
    hashedRefreshToken?: SortOrder
    status?: SortOrder
    role?: SortOrder
    profile?: UserProfileOrderByWithRelationInput
    reviewedOperationInspectionRecords?: OperationInspectionRecordOrderByRelationAggregateInput
    inspectedOperationInspectionRecords?: OperationInspectionRecordOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = {
    id?: number
  }

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    username?: SortOrder
    hashedPassword?: SortOrder
    hashedRefreshToken?: SortOrder
    status?: SortOrder
    role?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    isDeleted?: BoolWithAggregatesFilter | boolean
    username?: StringWithAggregatesFilter | string
    hashedPassword?: StringNullableWithAggregatesFilter | string | null
    hashedRefreshToken?: StringNullableWithAggregatesFilter | string | null
    status?: EnumUserStatusWithAggregatesFilter | UserStatus
    role?: EnumUserGroupWithAggregatesFilter | UserGroup
  }

  export type UserProfileWhereInput = {
    AND?: Enumerable<UserProfileWhereInput>
    OR?: Enumerable<UserProfileWhereInput>
    NOT?: Enumerable<UserProfileWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    userId?: IntFilter | number
    fullName?: StringFilter | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserProfileOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    userId?: SortOrder
    fullName?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserProfileWhereUniqueInput = {
    id?: number
    userId?: number
  }

  export type UserProfileOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    userId?: SortOrder
    fullName?: SortOrder
    _count?: UserProfileCountOrderByAggregateInput
    _avg?: UserProfileAvgOrderByAggregateInput
    _max?: UserProfileMaxOrderByAggregateInput
    _min?: UserProfileMinOrderByAggregateInput
    _sum?: UserProfileSumOrderByAggregateInput
  }

  export type UserProfileScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserProfileScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserProfileScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserProfileScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    isDeleted?: BoolWithAggregatesFilter | boolean
    userId?: IntWithAggregatesFilter | number
    fullName?: StringWithAggregatesFilter | string
  }

  export type ProductLineWhereInput = {
    AND?: Enumerable<ProductLineWhereInput>
    OR?: Enumerable<ProductLineWhereInput>
    NOT?: Enumerable<ProductLineWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    name?: StringFilter | string
    description?: StringFilter | string
    equipment?: EquipmentListRelationFilter
  }

  export type ProductLineOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
    description?: SortOrder
    equipment?: EquipmentOrderByRelationAggregateInput
  }

  export type ProductLineWhereUniqueInput = {
    id?: number
  }

  export type ProductLineOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
    description?: SortOrder
    _count?: ProductLineCountOrderByAggregateInput
    _avg?: ProductLineAvgOrderByAggregateInput
    _max?: ProductLineMaxOrderByAggregateInput
    _min?: ProductLineMinOrderByAggregateInput
    _sum?: ProductLineSumOrderByAggregateInput
  }

  export type ProductLineScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProductLineScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProductLineScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProductLineScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    isDeleted?: BoolWithAggregatesFilter | boolean
    name?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
  }

  export type EquipmentWhereInput = {
    AND?: Enumerable<EquipmentWhereInput>
    OR?: Enumerable<EquipmentWhereInput>
    NOT?: Enumerable<EquipmentWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    name?: StringFilter | string
    description?: StringFilter | string
    repairPlan?: StringFilter | string
    workStation?: StringFilter | string
    productLineId?: IntFilter | number
    productLine?: XOR<ProductLineRelationFilter, ProductLineWhereInput>
    repairMaterialInventories?: RepairMaterialInventoryListRelationFilter
    repairRecords?: RepairRecordListRelationFilter
  }

  export type EquipmentOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
    description?: SortOrder
    repairPlan?: SortOrder
    workStation?: SortOrder
    productLineId?: SortOrder
    productLine?: ProductLineOrderByWithRelationInput
    repairMaterialInventories?: RepairMaterialInventoryOrderByRelationAggregateInput
    repairRecords?: RepairRecordOrderByRelationAggregateInput
  }

  export type EquipmentWhereUniqueInput = {
    id?: number
  }

  export type EquipmentOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
    description?: SortOrder
    repairPlan?: SortOrder
    workStation?: SortOrder
    productLineId?: SortOrder
    _count?: EquipmentCountOrderByAggregateInput
    _avg?: EquipmentAvgOrderByAggregateInput
    _max?: EquipmentMaxOrderByAggregateInput
    _min?: EquipmentMinOrderByAggregateInput
    _sum?: EquipmentSumOrderByAggregateInput
  }

  export type EquipmentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<EquipmentScalarWhereWithAggregatesInput>
    OR?: Enumerable<EquipmentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<EquipmentScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    isDeleted?: BoolWithAggregatesFilter | boolean
    name?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    repairPlan?: StringWithAggregatesFilter | string
    workStation?: StringWithAggregatesFilter | string
    productLineId?: IntWithAggregatesFilter | number
  }

  export type RepairMaterialInventoryWhereInput = {
    AND?: Enumerable<RepairMaterialInventoryWhereInput>
    OR?: Enumerable<RepairMaterialInventoryWhereInput>
    NOT?: Enumerable<RepairMaterialInventoryWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    name?: StringFilter | string
    description?: StringFilter | string
    quantity?: IntFilter | number
    minimumQuantity?: IntFilter | number
    equipmentId?: IntFilter | number
    equipment?: XOR<EquipmentRelationFilter, EquipmentWhereInput>
  }

  export type RepairMaterialInventoryOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    minimumQuantity?: SortOrder
    equipmentId?: SortOrder
    equipment?: EquipmentOrderByWithRelationInput
  }

  export type RepairMaterialInventoryWhereUniqueInput = {
    id?: number
  }

  export type RepairMaterialInventoryOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    minimumQuantity?: SortOrder
    equipmentId?: SortOrder
    _count?: RepairMaterialInventoryCountOrderByAggregateInput
    _avg?: RepairMaterialInventoryAvgOrderByAggregateInput
    _max?: RepairMaterialInventoryMaxOrderByAggregateInput
    _min?: RepairMaterialInventoryMinOrderByAggregateInput
    _sum?: RepairMaterialInventorySumOrderByAggregateInput
  }

  export type RepairMaterialInventoryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RepairMaterialInventoryScalarWhereWithAggregatesInput>
    OR?: Enumerable<RepairMaterialInventoryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RepairMaterialInventoryScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    isDeleted?: BoolWithAggregatesFilter | boolean
    name?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    quantity?: IntWithAggregatesFilter | number
    minimumQuantity?: IntWithAggregatesFilter | number
    equipmentId?: IntWithAggregatesFilter | number
  }

  export type RepairRecordWhereInput = {
    AND?: Enumerable<RepairRecordWhereInput>
    OR?: Enumerable<RepairRecordWhereInput>
    NOT?: Enumerable<RepairRecordWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    type?: EnumRepairTypeFilter | RepairType
    equipmentId?: IntFilter | number
    status?: EnumRepairRecordStatusFilter | RepairRecordStatus
    description?: StringFilter | string
    equipment?: XOR<EquipmentRelationFilter, EquipmentWhereInput>
  }

  export type RepairRecordOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    type?: SortOrder
    equipmentId?: SortOrder
    status?: SortOrder
    description?: SortOrder
    equipment?: EquipmentOrderByWithRelationInput
  }

  export type RepairRecordWhereUniqueInput = {
    id?: number
  }

  export type RepairRecordOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    type?: SortOrder
    equipmentId?: SortOrder
    status?: SortOrder
    description?: SortOrder
    _count?: RepairRecordCountOrderByAggregateInput
    _avg?: RepairRecordAvgOrderByAggregateInput
    _max?: RepairRecordMaxOrderByAggregateInput
    _min?: RepairRecordMinOrderByAggregateInput
    _sum?: RepairRecordSumOrderByAggregateInput
  }

  export type RepairRecordScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RepairRecordScalarWhereWithAggregatesInput>
    OR?: Enumerable<RepairRecordScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RepairRecordScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    isDeleted?: BoolWithAggregatesFilter | boolean
    type?: EnumRepairTypeWithAggregatesFilter | RepairType
    equipmentId?: IntWithAggregatesFilter | number
    status?: EnumRepairRecordStatusWithAggregatesFilter | RepairRecordStatus
    description?: StringWithAggregatesFilter | string
  }

  export type PartWhereInput = {
    AND?: Enumerable<PartWhereInput>
    OR?: Enumerable<PartWhereInput>
    NOT?: Enumerable<PartWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    no?: StringFilter | string
    name?: StringFilter | string
    partVersions?: PartVersionListRelationFilter
    partOperation?: PartOperationListRelationFilter
    workerOrders?: WorkerOrderListRelationFilter
    nonconformItems?: NonconformItemListRelationFilter
  }

  export type PartOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    no?: SortOrder
    name?: SortOrder
    partVersions?: PartVersionOrderByRelationAggregateInput
    partOperation?: PartOperationOrderByRelationAggregateInput
    workerOrders?: WorkerOrderOrderByRelationAggregateInput
    nonconformItems?: NonconformItemOrderByRelationAggregateInput
  }

  export type PartWhereUniqueInput = {
    id?: number
  }

  export type PartOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    no?: SortOrder
    name?: SortOrder
    _count?: PartCountOrderByAggregateInput
    _avg?: PartAvgOrderByAggregateInput
    _max?: PartMaxOrderByAggregateInput
    _min?: PartMinOrderByAggregateInput
    _sum?: PartSumOrderByAggregateInput
  }

  export type PartScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PartScalarWhereWithAggregatesInput>
    OR?: Enumerable<PartScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PartScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    isDeleted?: BoolWithAggregatesFilter | boolean
    no?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
  }

  export type PartVersionWhereInput = {
    AND?: Enumerable<PartVersionWhereInput>
    OR?: Enumerable<PartVersionWhereInput>
    NOT?: Enumerable<PartVersionWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    version?: StringFilter | string
    note?: StringNullableFilter | string | null
    partId?: IntFilter | number
    part?: XOR<PartRelationFilter, PartWhereInput>
    incomingInspectionSpec?: XOR<IncomingInspectionSpecRelationFilter, IncomingInspectionSpecWhereInput> | null
    receipts?: ReceiptListRelationFilter
  }

  export type PartVersionOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    version?: SortOrder
    note?: SortOrder
    partId?: SortOrder
    part?: PartOrderByWithRelationInput
    incomingInspectionSpec?: IncomingInspectionSpecOrderByWithRelationInput
    receipts?: ReceiptOrderByRelationAggregateInput
  }

  export type PartVersionWhereUniqueInput = {
    id?: number
  }

  export type PartVersionOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    version?: SortOrder
    note?: SortOrder
    partId?: SortOrder
    _count?: PartVersionCountOrderByAggregateInput
    _avg?: PartVersionAvgOrderByAggregateInput
    _max?: PartVersionMaxOrderByAggregateInput
    _min?: PartVersionMinOrderByAggregateInput
    _sum?: PartVersionSumOrderByAggregateInput
  }

  export type PartVersionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PartVersionScalarWhereWithAggregatesInput>
    OR?: Enumerable<PartVersionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PartVersionScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    isDeleted?: BoolWithAggregatesFilter | boolean
    version?: StringWithAggregatesFilter | string
    note?: StringNullableWithAggregatesFilter | string | null
    partId?: IntWithAggregatesFilter | number
  }

  export type IncomingInspectionSpecWhereInput = {
    AND?: Enumerable<IncomingInspectionSpecWhereInput>
    OR?: Enumerable<IncomingInspectionSpecWhereInput>
    NOT?: Enumerable<IncomingInspectionSpecWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    version?: StringFilter | string
    attachment?: StringFilter | string
    partVersionId?: IntFilter | number
    incomingInspectionSpecItems?: IncomingInspectionSpecItemListRelationFilter
    incomingInspectionRecords?: IncomingInspectionRecordListRelationFilter
    partVersion?: XOR<PartVersionRelationFilter, PartVersionWhereInput>
  }

  export type IncomingInspectionSpecOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    version?: SortOrder
    attachment?: SortOrder
    partVersionId?: SortOrder
    incomingInspectionSpecItems?: IncomingInspectionSpecItemOrderByRelationAggregateInput
    incomingInspectionRecords?: IncomingInspectionRecordOrderByRelationAggregateInput
    partVersion?: PartVersionOrderByWithRelationInput
  }

  export type IncomingInspectionSpecWhereUniqueInput = {
    id?: number
    partVersionId?: number
  }

  export type IncomingInspectionSpecOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    version?: SortOrder
    attachment?: SortOrder
    partVersionId?: SortOrder
    _count?: IncomingInspectionSpecCountOrderByAggregateInput
    _avg?: IncomingInspectionSpecAvgOrderByAggregateInput
    _max?: IncomingInspectionSpecMaxOrderByAggregateInput
    _min?: IncomingInspectionSpecMinOrderByAggregateInput
    _sum?: IncomingInspectionSpecSumOrderByAggregateInput
  }

  export type IncomingInspectionSpecScalarWhereWithAggregatesInput = {
    AND?: Enumerable<IncomingInspectionSpecScalarWhereWithAggregatesInput>
    OR?: Enumerable<IncomingInspectionSpecScalarWhereWithAggregatesInput>
    NOT?: Enumerable<IncomingInspectionSpecScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    isDeleted?: BoolWithAggregatesFilter | boolean
    version?: StringWithAggregatesFilter | string
    attachment?: StringWithAggregatesFilter | string
    partVersionId?: IntWithAggregatesFilter | number
  }

  export type IncomingInspectionSpecItemWhereInput = {
    AND?: Enumerable<IncomingInspectionSpecItemWhereInput>
    OR?: Enumerable<IncomingInspectionSpecItemWhereInput>
    NOT?: Enumerable<IncomingInspectionSpecItemWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    no?: IntFilter | number
    name?: StringFilter | string
    spec?: StringFilter | string
    incomingInspectionSpecId?: IntFilter | number
    incomingInspectionSpec?: XOR<IncomingInspectionSpecRelationFilter, IncomingInspectionSpecWhereInput>
    incomingInspectionRecordItem?: IncomingInspectionRecordItemListRelationFilter
  }

  export type IncomingInspectionSpecItemOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    no?: SortOrder
    name?: SortOrder
    spec?: SortOrder
    incomingInspectionSpecId?: SortOrder
    incomingInspectionSpec?: IncomingInspectionSpecOrderByWithRelationInput
    incomingInspectionRecordItem?: IncomingInspectionRecordItemOrderByRelationAggregateInput
  }

  export type IncomingInspectionSpecItemWhereUniqueInput = {
    id?: number
  }

  export type IncomingInspectionSpecItemOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    no?: SortOrder
    name?: SortOrder
    spec?: SortOrder
    incomingInspectionSpecId?: SortOrder
    _count?: IncomingInspectionSpecItemCountOrderByAggregateInput
    _avg?: IncomingInspectionSpecItemAvgOrderByAggregateInput
    _max?: IncomingInspectionSpecItemMaxOrderByAggregateInput
    _min?: IncomingInspectionSpecItemMinOrderByAggregateInput
    _sum?: IncomingInspectionSpecItemSumOrderByAggregateInput
  }

  export type IncomingInspectionSpecItemScalarWhereWithAggregatesInput = {
    AND?: Enumerable<IncomingInspectionSpecItemScalarWhereWithAggregatesInput>
    OR?: Enumerable<IncomingInspectionSpecItemScalarWhereWithAggregatesInput>
    NOT?: Enumerable<IncomingInspectionSpecItemScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    isDeleted?: BoolWithAggregatesFilter | boolean
    no?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    spec?: StringWithAggregatesFilter | string
    incomingInspectionSpecId?: IntWithAggregatesFilter | number
  }

  export type NonconformItemWhereInput = {
    AND?: Enumerable<NonconformItemWhereInput>
    OR?: Enumerable<NonconformItemWhereInput>
    NOT?: Enumerable<NonconformItemWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    partId?: IntFilter | number
    description?: StringFilter | string
    note?: StringNullableFilter | string | null
    part?: XOR<PartRelationFilter, PartWhereInput>
  }

  export type NonconformItemOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    partId?: SortOrder
    description?: SortOrder
    note?: SortOrder
    part?: PartOrderByWithRelationInput
  }

  export type NonconformItemWhereUniqueInput = {
    id?: number
  }

  export type NonconformItemOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    partId?: SortOrder
    description?: SortOrder
    note?: SortOrder
    _count?: NonconformItemCountOrderByAggregateInput
    _avg?: NonconformItemAvgOrderByAggregateInput
    _max?: NonconformItemMaxOrderByAggregateInput
    _min?: NonconformItemMinOrderByAggregateInput
    _sum?: NonconformItemSumOrderByAggregateInput
  }

  export type NonconformItemScalarWhereWithAggregatesInput = {
    AND?: Enumerable<NonconformItemScalarWhereWithAggregatesInput>
    OR?: Enumerable<NonconformItemScalarWhereWithAggregatesInput>
    NOT?: Enumerable<NonconformItemScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    isDeleted?: BoolWithAggregatesFilter | boolean
    partId?: IntWithAggregatesFilter | number
    description?: StringWithAggregatesFilter | string
    note?: StringNullableWithAggregatesFilter | string | null
  }

  export type PartOperationWhereInput = {
    AND?: Enumerable<PartOperationWhereInput>
    OR?: Enumerable<PartOperationWhereInput>
    NOT?: Enumerable<PartOperationWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    version?: StringFilter | string
    no?: StringFilter | string
    name?: StringFilter | string
    partId?: IntFilter | number
    part?: XOR<PartRelationFilter, PartWhereInput>
    partOperationInspectionItems?: PartOperationInspectionItemListRelationFilter
  }

  export type PartOperationOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    version?: SortOrder
    no?: SortOrder
    name?: SortOrder
    partId?: SortOrder
    part?: PartOrderByWithRelationInput
    partOperationInspectionItems?: PartOperationInspectionItemOrderByRelationAggregateInput
  }

  export type PartOperationWhereUniqueInput = {
    id?: number
  }

  export type PartOperationOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    version?: SortOrder
    no?: SortOrder
    name?: SortOrder
    partId?: SortOrder
    _count?: PartOperationCountOrderByAggregateInput
    _avg?: PartOperationAvgOrderByAggregateInput
    _max?: PartOperationMaxOrderByAggregateInput
    _min?: PartOperationMinOrderByAggregateInput
    _sum?: PartOperationSumOrderByAggregateInput
  }

  export type PartOperationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PartOperationScalarWhereWithAggregatesInput>
    OR?: Enumerable<PartOperationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PartOperationScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    isDeleted?: BoolWithAggregatesFilter | boolean
    version?: StringWithAggregatesFilter | string
    no?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    partId?: IntWithAggregatesFilter | number
  }

  export type PartOperationInspectionItemWhereInput = {
    AND?: Enumerable<PartOperationInspectionItemWhereInput>
    OR?: Enumerable<PartOperationInspectionItemWhereInput>
    NOT?: Enumerable<PartOperationInspectionItemWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    name?: StringFilter | string
    partOperationId?: IntFilter | number
    partOperation?: XOR<PartOperationRelationFilter, PartOperationWhereInput>
    operationInspectionRecordItems?: OperationInspectionRecordItemListRelationFilter
  }

  export type PartOperationInspectionItemOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
    partOperationId?: SortOrder
    partOperation?: PartOperationOrderByWithRelationInput
    operationInspectionRecordItems?: OperationInspectionRecordItemOrderByRelationAggregateInput
  }

  export type PartOperationInspectionItemWhereUniqueInput = {
    id?: number
  }

  export type PartOperationInspectionItemOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
    partOperationId?: SortOrder
    _count?: PartOperationInspectionItemCountOrderByAggregateInput
    _avg?: PartOperationInspectionItemAvgOrderByAggregateInput
    _max?: PartOperationInspectionItemMaxOrderByAggregateInput
    _min?: PartOperationInspectionItemMinOrderByAggregateInput
    _sum?: PartOperationInspectionItemSumOrderByAggregateInput
  }

  export type PartOperationInspectionItemScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PartOperationInspectionItemScalarWhereWithAggregatesInput>
    OR?: Enumerable<PartOperationInspectionItemScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PartOperationInspectionItemScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    isDeleted?: BoolWithAggregatesFilter | boolean
    name?: StringWithAggregatesFilter | string
    partOperationId?: IntWithAggregatesFilter | number
  }

  export type ReceiptWhereInput = {
    AND?: Enumerable<ReceiptWhereInput>
    OR?: Enumerable<ReceiptWhereInput>
    NOT?: Enumerable<ReceiptWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    lot?: StringFilter | string
    partVersionId?: IntFilter | number
    partVersion?: XOR<PartVersionRelationFilter, PartVersionWhereInput>
    incomingInspectionRecord?: XOR<IncomingInspectionRecordRelationFilter, IncomingInspectionRecordWhereInput> | null
  }

  export type ReceiptOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    lot?: SortOrder
    partVersionId?: SortOrder
    partVersion?: PartVersionOrderByWithRelationInput
    incomingInspectionRecord?: IncomingInspectionRecordOrderByWithRelationInput
  }

  export type ReceiptWhereUniqueInput = {
    id?: number
  }

  export type ReceiptOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    lot?: SortOrder
    partVersionId?: SortOrder
    _count?: ReceiptCountOrderByAggregateInput
    _avg?: ReceiptAvgOrderByAggregateInput
    _max?: ReceiptMaxOrderByAggregateInput
    _min?: ReceiptMinOrderByAggregateInput
    _sum?: ReceiptSumOrderByAggregateInput
  }

  export type ReceiptScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ReceiptScalarWhereWithAggregatesInput>
    OR?: Enumerable<ReceiptScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ReceiptScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    isDeleted?: BoolWithAggregatesFilter | boolean
    lot?: StringWithAggregatesFilter | string
    partVersionId?: IntWithAggregatesFilter | number
  }

  export type IncomingInspectionRecordWhereInput = {
    AND?: Enumerable<IncomingInspectionRecordWhereInput>
    OR?: Enumerable<IncomingInspectionRecordWhereInput>
    NOT?: Enumerable<IncomingInspectionRecordWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    note?: StringFilter | string
    result?: EnumIncomingInspectionResultFilter | IncomingInspectionResult
    receiptId?: IntFilter | number
    incomingInspectionSpecId?: IntFilter | number
    receipt?: XOR<ReceiptRelationFilter, ReceiptWhereInput>
    incomingInspectionSpec?: XOR<IncomingInspectionSpecRelationFilter, IncomingInspectionSpecWhereInput>
    incomingInspectionRecordItems?: IncomingInspectionRecordItemListRelationFilter
  }

  export type IncomingInspectionRecordOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    note?: SortOrder
    result?: SortOrder
    receiptId?: SortOrder
    incomingInspectionSpecId?: SortOrder
    receipt?: ReceiptOrderByWithRelationInput
    incomingInspectionSpec?: IncomingInspectionSpecOrderByWithRelationInput
    incomingInspectionRecordItems?: IncomingInspectionRecordItemOrderByRelationAggregateInput
  }

  export type IncomingInspectionRecordWhereUniqueInput = {
    id?: number
    receiptId?: number
  }

  export type IncomingInspectionRecordOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    note?: SortOrder
    result?: SortOrder
    receiptId?: SortOrder
    incomingInspectionSpecId?: SortOrder
    _count?: IncomingInspectionRecordCountOrderByAggregateInput
    _avg?: IncomingInspectionRecordAvgOrderByAggregateInput
    _max?: IncomingInspectionRecordMaxOrderByAggregateInput
    _min?: IncomingInspectionRecordMinOrderByAggregateInput
    _sum?: IncomingInspectionRecordSumOrderByAggregateInput
  }

  export type IncomingInspectionRecordScalarWhereWithAggregatesInput = {
    AND?: Enumerable<IncomingInspectionRecordScalarWhereWithAggregatesInput>
    OR?: Enumerable<IncomingInspectionRecordScalarWhereWithAggregatesInput>
    NOT?: Enumerable<IncomingInspectionRecordScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    isDeleted?: BoolWithAggregatesFilter | boolean
    note?: StringWithAggregatesFilter | string
    result?: EnumIncomingInspectionResultWithAggregatesFilter | IncomingInspectionResult
    receiptId?: IntWithAggregatesFilter | number
    incomingInspectionSpecId?: IntWithAggregatesFilter | number
  }

  export type IncomingInspectionRecordItemWhereInput = {
    AND?: Enumerable<IncomingInspectionRecordItemWhereInput>
    OR?: Enumerable<IncomingInspectionRecordItemWhereInput>
    NOT?: Enumerable<IncomingInspectionRecordItemWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    result?: BoolFilter | boolean
    inspectionIteration?: StringFilter | string
    incomingInspectionRecordId?: IntFilter | number
    incomingInspectionSpecItemId?: IntFilter | number
    incomingInspectionRecord?: XOR<IncomingInspectionRecordRelationFilter, IncomingInspectionRecordWhereInput>
    incomingInspectionSpecItem?: XOR<IncomingInspectionSpecItemRelationFilter, IncomingInspectionSpecItemWhereInput>
  }

  export type IncomingInspectionRecordItemOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    result?: SortOrder
    inspectionIteration?: SortOrder
    incomingInspectionRecordId?: SortOrder
    incomingInspectionSpecItemId?: SortOrder
    incomingInspectionRecord?: IncomingInspectionRecordOrderByWithRelationInput
    incomingInspectionSpecItem?: IncomingInspectionSpecItemOrderByWithRelationInput
  }

  export type IncomingInspectionRecordItemWhereUniqueInput = {
    id?: number
  }

  export type IncomingInspectionRecordItemOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    result?: SortOrder
    inspectionIteration?: SortOrder
    incomingInspectionRecordId?: SortOrder
    incomingInspectionSpecItemId?: SortOrder
    _count?: IncomingInspectionRecordItemCountOrderByAggregateInput
    _avg?: IncomingInspectionRecordItemAvgOrderByAggregateInput
    _max?: IncomingInspectionRecordItemMaxOrderByAggregateInput
    _min?: IncomingInspectionRecordItemMinOrderByAggregateInput
    _sum?: IncomingInspectionRecordItemSumOrderByAggregateInput
  }

  export type IncomingInspectionRecordItemScalarWhereWithAggregatesInput = {
    AND?: Enumerable<IncomingInspectionRecordItemScalarWhereWithAggregatesInput>
    OR?: Enumerable<IncomingInspectionRecordItemScalarWhereWithAggregatesInput>
    NOT?: Enumerable<IncomingInspectionRecordItemScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    isDeleted?: BoolWithAggregatesFilter | boolean
    result?: BoolWithAggregatesFilter | boolean
    inspectionIteration?: StringWithAggregatesFilter | string
    incomingInspectionRecordId?: IntWithAggregatesFilter | number
    incomingInspectionSpecItemId?: IntWithAggregatesFilter | number
  }

  export type WorkerOrderWhereInput = {
    AND?: Enumerable<WorkerOrderWhereInput>
    OR?: Enumerable<WorkerOrderWhereInput>
    NOT?: Enumerable<WorkerOrderWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    no?: StringFilter | string
    partId?: IntFilter | number
    part?: XOR<PartRelationFilter, PartWhereInput>
    operationInspectionRecords?: OperationInspectionRecordListRelationFilter
  }

  export type WorkerOrderOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    no?: SortOrder
    partId?: SortOrder
    part?: PartOrderByWithRelationInput
    operationInspectionRecords?: OperationInspectionRecordOrderByRelationAggregateInput
  }

  export type WorkerOrderWhereUniqueInput = {
    id?: number
  }

  export type WorkerOrderOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    no?: SortOrder
    partId?: SortOrder
    _count?: WorkerOrderCountOrderByAggregateInput
    _avg?: WorkerOrderAvgOrderByAggregateInput
    _max?: WorkerOrderMaxOrderByAggregateInput
    _min?: WorkerOrderMinOrderByAggregateInput
    _sum?: WorkerOrderSumOrderByAggregateInput
  }

  export type WorkerOrderScalarWhereWithAggregatesInput = {
    AND?: Enumerable<WorkerOrderScalarWhereWithAggregatesInput>
    OR?: Enumerable<WorkerOrderScalarWhereWithAggregatesInput>
    NOT?: Enumerable<WorkerOrderScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    isDeleted?: BoolWithAggregatesFilter | boolean
    no?: StringWithAggregatesFilter | string
    partId?: IntWithAggregatesFilter | number
  }

  export type OperationInspectionRecordWhereInput = {
    AND?: Enumerable<OperationInspectionRecordWhereInput>
    OR?: Enumerable<OperationInspectionRecordWhereInput>
    NOT?: Enumerable<OperationInspectionRecordWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    note?: StringNullableFilter | string | null
    workerOrderId?: IntFilter | number
    inspectorId?: IntFilter | number
    reviewerId?: IntFilter | number
    workerOrder?: XOR<WorkerOrderRelationFilter, WorkerOrderWhereInput>
    inspector?: XOR<UserRelationFilter, UserWhereInput>
    reviewer?: XOR<UserRelationFilter, UserWhereInput>
    operationInspectionRecordItems?: OperationInspectionRecordItemListRelationFilter
  }

  export type OperationInspectionRecordOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    note?: SortOrder
    workerOrderId?: SortOrder
    inspectorId?: SortOrder
    reviewerId?: SortOrder
    workerOrder?: WorkerOrderOrderByWithRelationInput
    inspector?: UserOrderByWithRelationInput
    reviewer?: UserOrderByWithRelationInput
    operationInspectionRecordItems?: OperationInspectionRecordItemOrderByRelationAggregateInput
  }

  export type OperationInspectionRecordWhereUniqueInput = {
    id?: number
  }

  export type OperationInspectionRecordOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    note?: SortOrder
    workerOrderId?: SortOrder
    inspectorId?: SortOrder
    reviewerId?: SortOrder
    _count?: OperationInspectionRecordCountOrderByAggregateInput
    _avg?: OperationInspectionRecordAvgOrderByAggregateInput
    _max?: OperationInspectionRecordMaxOrderByAggregateInput
    _min?: OperationInspectionRecordMinOrderByAggregateInput
    _sum?: OperationInspectionRecordSumOrderByAggregateInput
  }

  export type OperationInspectionRecordScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OperationInspectionRecordScalarWhereWithAggregatesInput>
    OR?: Enumerable<OperationInspectionRecordScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OperationInspectionRecordScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    isDeleted?: BoolWithAggregatesFilter | boolean
    note?: StringNullableWithAggregatesFilter | string | null
    workerOrderId?: IntWithAggregatesFilter | number
    inspectorId?: IntWithAggregatesFilter | number
    reviewerId?: IntWithAggregatesFilter | number
  }

  export type OperationInspectionRecordItemWhereInput = {
    AND?: Enumerable<OperationInspectionRecordItemWhereInput>
    OR?: Enumerable<OperationInspectionRecordItemWhereInput>
    NOT?: Enumerable<OperationInspectionRecordItemWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    inspectionIteration?: StringFilter | string
    partOperationInspectionItemId?: IntFilter | number
    operationInspectionRecordId?: IntFilter | number
    partOperationInspectionItem?: XOR<PartOperationInspectionItemRelationFilter, PartOperationInspectionItemWhereInput>
    operationInspectionRecord?: XOR<OperationInspectionRecordRelationFilter, OperationInspectionRecordWhereInput>
  }

  export type OperationInspectionRecordItemOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    inspectionIteration?: SortOrder
    partOperationInspectionItemId?: SortOrder
    operationInspectionRecordId?: SortOrder
    partOperationInspectionItem?: PartOperationInspectionItemOrderByWithRelationInput
    operationInspectionRecord?: OperationInspectionRecordOrderByWithRelationInput
  }

  export type OperationInspectionRecordItemWhereUniqueInput = {
    id?: number
  }

  export type OperationInspectionRecordItemOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    inspectionIteration?: SortOrder
    partOperationInspectionItemId?: SortOrder
    operationInspectionRecordId?: SortOrder
    _count?: OperationInspectionRecordItemCountOrderByAggregateInput
    _avg?: OperationInspectionRecordItemAvgOrderByAggregateInput
    _max?: OperationInspectionRecordItemMaxOrderByAggregateInput
    _min?: OperationInspectionRecordItemMinOrderByAggregateInput
    _sum?: OperationInspectionRecordItemSumOrderByAggregateInput
  }

  export type OperationInspectionRecordItemScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OperationInspectionRecordItemScalarWhereWithAggregatesInput>
    OR?: Enumerable<OperationInspectionRecordItemScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OperationInspectionRecordItemScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    isDeleted?: BoolWithAggregatesFilter | boolean
    inspectionIteration?: StringWithAggregatesFilter | string
    partOperationInspectionItemId?: IntWithAggregatesFilter | number
    operationInspectionRecordId?: IntWithAggregatesFilter | number
  }

  export type TaskFormRelationCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    taskDefinitionKey: string
    formKey: string
  }

  export type TaskFormRelationUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    taskDefinitionKey: string
    formKey: string
  }

  export type TaskFormRelationUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    taskDefinitionKey?: StringFieldUpdateOperationsInput | string
    formKey?: StringFieldUpdateOperationsInput | string
  }

  export type TaskFormRelationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    taskDefinitionKey?: StringFieldUpdateOperationsInput | string
    formKey?: StringFieldUpdateOperationsInput | string
  }

  export type TaskFormRelationCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    taskDefinitionKey: string
    formKey: string
  }

  export type TaskFormRelationUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    taskDefinitionKey?: StringFieldUpdateOperationsInput | string
    formKey?: StringFieldUpdateOperationsInput | string
  }

  export type TaskFormRelationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    taskDefinitionKey?: StringFieldUpdateOperationsInput | string
    formKey?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    username: string
    hashedPassword?: string | null
    hashedRefreshToken?: string | null
    status: UserStatus
    role?: UserGroup
    profile?: UserProfileCreateNestedOneWithoutUserInput
    reviewedOperationInspectionRecords?: OperationInspectionRecordCreateNestedManyWithoutInspectorInput
    inspectedOperationInspectionRecords?: OperationInspectionRecordCreateNestedManyWithoutReviewerInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    username: string
    hashedPassword?: string | null
    hashedRefreshToken?: string | null
    status: UserStatus
    role?: UserGroup
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    reviewedOperationInspectionRecords?: OperationInspectionRecordUncheckedCreateNestedManyWithoutInspectorInput
    inspectedOperationInspectionRecords?: OperationInspectionRecordUncheckedCreateNestedManyWithoutReviewerInput
  }

  export type UserUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    username?: StringFieldUpdateOperationsInput | string
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    hashedRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | UserStatus
    role?: EnumUserGroupFieldUpdateOperationsInput | UserGroup
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    reviewedOperationInspectionRecords?: OperationInspectionRecordUpdateManyWithoutInspectorNestedInput
    inspectedOperationInspectionRecords?: OperationInspectionRecordUpdateManyWithoutReviewerNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    username?: StringFieldUpdateOperationsInput | string
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    hashedRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | UserStatus
    role?: EnumUserGroupFieldUpdateOperationsInput | UserGroup
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    reviewedOperationInspectionRecords?: OperationInspectionRecordUncheckedUpdateManyWithoutInspectorNestedInput
    inspectedOperationInspectionRecords?: OperationInspectionRecordUncheckedUpdateManyWithoutReviewerNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    username: string
    hashedPassword?: string | null
    hashedRefreshToken?: string | null
    status: UserStatus
    role?: UserGroup
  }

  export type UserUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    username?: StringFieldUpdateOperationsInput | string
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    hashedRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | UserStatus
    role?: EnumUserGroupFieldUpdateOperationsInput | UserGroup
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    username?: StringFieldUpdateOperationsInput | string
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    hashedRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | UserStatus
    role?: EnumUserGroupFieldUpdateOperationsInput | UserGroup
  }

  export type UserProfileCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    fullName: string
    user: UserCreateNestedOneWithoutProfileInput
  }

  export type UserProfileUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    userId: number
    fullName: string
  }

  export type UserProfileUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    fullName?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutProfileNestedInput
  }

  export type UserProfileUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
  }

  export type UserProfileCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    userId: number
    fullName: string
  }

  export type UserProfileUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    fullName?: StringFieldUpdateOperationsInput | string
  }

  export type UserProfileUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
  }

  export type ProductLineCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    description: string
    equipment?: EquipmentCreateNestedManyWithoutProductLineInput
  }

  export type ProductLineUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    description: string
    equipment?: EquipmentUncheckedCreateNestedManyWithoutProductLineInput
  }

  export type ProductLineUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    equipment?: EquipmentUpdateManyWithoutProductLineNestedInput
  }

  export type ProductLineUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    equipment?: EquipmentUncheckedUpdateManyWithoutProductLineNestedInput
  }

  export type ProductLineCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    description: string
  }

  export type ProductLineUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type ProductLineUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type EquipmentCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    description: string
    repairPlan: string
    workStation: string
    productLine: ProductLineCreateNestedOneWithoutEquipmentInput
    repairMaterialInventories?: RepairMaterialInventoryCreateNestedManyWithoutEquipmentInput
    repairRecords?: RepairRecordCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    description: string
    repairPlan: string
    workStation: string
    productLineId: number
    repairMaterialInventories?: RepairMaterialInventoryUncheckedCreateNestedManyWithoutEquipmentInput
    repairRecords?: RepairRecordUncheckedCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    repairPlan?: StringFieldUpdateOperationsInput | string
    workStation?: StringFieldUpdateOperationsInput | string
    productLine?: ProductLineUpdateOneRequiredWithoutEquipmentNestedInput
    repairMaterialInventories?: RepairMaterialInventoryUpdateManyWithoutEquipmentNestedInput
    repairRecords?: RepairRecordUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    repairPlan?: StringFieldUpdateOperationsInput | string
    workStation?: StringFieldUpdateOperationsInput | string
    productLineId?: IntFieldUpdateOperationsInput | number
    repairMaterialInventories?: RepairMaterialInventoryUncheckedUpdateManyWithoutEquipmentNestedInput
    repairRecords?: RepairRecordUncheckedUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    description: string
    repairPlan: string
    workStation: string
    productLineId: number
  }

  export type EquipmentUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    repairPlan?: StringFieldUpdateOperationsInput | string
    workStation?: StringFieldUpdateOperationsInput | string
  }

  export type EquipmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    repairPlan?: StringFieldUpdateOperationsInput | string
    workStation?: StringFieldUpdateOperationsInput | string
    productLineId?: IntFieldUpdateOperationsInput | number
  }

  export type RepairMaterialInventoryCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    description: string
    quantity: number
    minimumQuantity: number
    equipment: EquipmentCreateNestedOneWithoutRepairMaterialInventoriesInput
  }

  export type RepairMaterialInventoryUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    description: string
    quantity: number
    minimumQuantity: number
    equipmentId: number
  }

  export type RepairMaterialInventoryUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    minimumQuantity?: IntFieldUpdateOperationsInput | number
    equipment?: EquipmentUpdateOneRequiredWithoutRepairMaterialInventoriesNestedInput
  }

  export type RepairMaterialInventoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    minimumQuantity?: IntFieldUpdateOperationsInput | number
    equipmentId?: IntFieldUpdateOperationsInput | number
  }

  export type RepairMaterialInventoryCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    description: string
    quantity: number
    minimumQuantity: number
    equipmentId: number
  }

  export type RepairMaterialInventoryUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    minimumQuantity?: IntFieldUpdateOperationsInput | number
  }

  export type RepairMaterialInventoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    minimumQuantity?: IntFieldUpdateOperationsInput | number
    equipmentId?: IntFieldUpdateOperationsInput | number
  }

  export type RepairRecordCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    type: RepairType
    status: RepairRecordStatus
    description: string
    equipment: EquipmentCreateNestedOneWithoutRepairRecordsInput
  }

  export type RepairRecordUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    type: RepairType
    equipmentId: number
    status: RepairRecordStatus
    description: string
  }

  export type RepairRecordUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumRepairTypeFieldUpdateOperationsInput | RepairType
    status?: EnumRepairRecordStatusFieldUpdateOperationsInput | RepairRecordStatus
    description?: StringFieldUpdateOperationsInput | string
    equipment?: EquipmentUpdateOneRequiredWithoutRepairRecordsNestedInput
  }

  export type RepairRecordUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumRepairTypeFieldUpdateOperationsInput | RepairType
    equipmentId?: IntFieldUpdateOperationsInput | number
    status?: EnumRepairRecordStatusFieldUpdateOperationsInput | RepairRecordStatus
    description?: StringFieldUpdateOperationsInput | string
  }

  export type RepairRecordCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    type: RepairType
    equipmentId: number
    status: RepairRecordStatus
    description: string
  }

  export type RepairRecordUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumRepairTypeFieldUpdateOperationsInput | RepairType
    status?: EnumRepairRecordStatusFieldUpdateOperationsInput | RepairRecordStatus
    description?: StringFieldUpdateOperationsInput | string
  }

  export type RepairRecordUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumRepairTypeFieldUpdateOperationsInput | RepairType
    equipmentId?: IntFieldUpdateOperationsInput | number
    status?: EnumRepairRecordStatusFieldUpdateOperationsInput | RepairRecordStatus
    description?: StringFieldUpdateOperationsInput | string
  }

  export type PartCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    no: string
    name: string
    partVersions?: PartVersionCreateNestedManyWithoutPartInput
    partOperation?: PartOperationCreateNestedManyWithoutPartInput
    workerOrders?: WorkerOrderCreateNestedManyWithoutPartInput
    nonconformItems?: NonconformItemCreateNestedManyWithoutPartInput
  }

  export type PartUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    no: string
    name: string
    partVersions?: PartVersionUncheckedCreateNestedManyWithoutPartInput
    partOperation?: PartOperationUncheckedCreateNestedManyWithoutPartInput
    workerOrders?: WorkerOrderUncheckedCreateNestedManyWithoutPartInput
    nonconformItems?: NonconformItemUncheckedCreateNestedManyWithoutPartInput
  }

  export type PartUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    no?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    partVersions?: PartVersionUpdateManyWithoutPartNestedInput
    partOperation?: PartOperationUpdateManyWithoutPartNestedInput
    workerOrders?: WorkerOrderUpdateManyWithoutPartNestedInput
    nonconformItems?: NonconformItemUpdateManyWithoutPartNestedInput
  }

  export type PartUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    no?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    partVersions?: PartVersionUncheckedUpdateManyWithoutPartNestedInput
    partOperation?: PartOperationUncheckedUpdateManyWithoutPartNestedInput
    workerOrders?: WorkerOrderUncheckedUpdateManyWithoutPartNestedInput
    nonconformItems?: NonconformItemUncheckedUpdateManyWithoutPartNestedInput
  }

  export type PartCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    no: string
    name: string
  }

  export type PartUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    no?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PartUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    no?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PartVersionCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    version: string
    note?: string | null
    part: PartCreateNestedOneWithoutPartVersionsInput
    incomingInspectionSpec?: IncomingInspectionSpecCreateNestedOneWithoutPartVersionInput
    receipts?: ReceiptCreateNestedManyWithoutPartVersionInput
  }

  export type PartVersionUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    version: string
    note?: string | null
    partId: number
    incomingInspectionSpec?: IncomingInspectionSpecUncheckedCreateNestedOneWithoutPartVersionInput
    receipts?: ReceiptUncheckedCreateNestedManyWithoutPartVersionInput
  }

  export type PartVersionUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    version?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    part?: PartUpdateOneRequiredWithoutPartVersionsNestedInput
    incomingInspectionSpec?: IncomingInspectionSpecUpdateOneWithoutPartVersionNestedInput
    receipts?: ReceiptUpdateManyWithoutPartVersionNestedInput
  }

  export type PartVersionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    version?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    partId?: IntFieldUpdateOperationsInput | number
    incomingInspectionSpec?: IncomingInspectionSpecUncheckedUpdateOneWithoutPartVersionNestedInput
    receipts?: ReceiptUncheckedUpdateManyWithoutPartVersionNestedInput
  }

  export type PartVersionCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    version: string
    note?: string | null
    partId: number
  }

  export type PartVersionUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    version?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PartVersionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    version?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    partId?: IntFieldUpdateOperationsInput | number
  }

  export type IncomingInspectionSpecCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    version: string
    attachment: string
    incomingInspectionSpecItems?: IncomingInspectionSpecItemCreateNestedManyWithoutIncomingInspectionSpecInput
    incomingInspectionRecords?: IncomingInspectionRecordCreateNestedManyWithoutIncomingInspectionSpecInput
    partVersion: PartVersionCreateNestedOneWithoutIncomingInspectionSpecInput
  }

  export type IncomingInspectionSpecUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    version: string
    attachment: string
    partVersionId: number
    incomingInspectionSpecItems?: IncomingInspectionSpecItemUncheckedCreateNestedManyWithoutIncomingInspectionSpecInput
    incomingInspectionRecords?: IncomingInspectionRecordUncheckedCreateNestedManyWithoutIncomingInspectionSpecInput
  }

  export type IncomingInspectionSpecUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    version?: StringFieldUpdateOperationsInput | string
    attachment?: StringFieldUpdateOperationsInput | string
    incomingInspectionSpecItems?: IncomingInspectionSpecItemUpdateManyWithoutIncomingInspectionSpecNestedInput
    incomingInspectionRecords?: IncomingInspectionRecordUpdateManyWithoutIncomingInspectionSpecNestedInput
    partVersion?: PartVersionUpdateOneRequiredWithoutIncomingInspectionSpecNestedInput
  }

  export type IncomingInspectionSpecUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    version?: StringFieldUpdateOperationsInput | string
    attachment?: StringFieldUpdateOperationsInput | string
    partVersionId?: IntFieldUpdateOperationsInput | number
    incomingInspectionSpecItems?: IncomingInspectionSpecItemUncheckedUpdateManyWithoutIncomingInspectionSpecNestedInput
    incomingInspectionRecords?: IncomingInspectionRecordUncheckedUpdateManyWithoutIncomingInspectionSpecNestedInput
  }

  export type IncomingInspectionSpecCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    version: string
    attachment: string
    partVersionId: number
  }

  export type IncomingInspectionSpecUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    version?: StringFieldUpdateOperationsInput | string
    attachment?: StringFieldUpdateOperationsInput | string
  }

  export type IncomingInspectionSpecUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    version?: StringFieldUpdateOperationsInput | string
    attachment?: StringFieldUpdateOperationsInput | string
    partVersionId?: IntFieldUpdateOperationsInput | number
  }

  export type IncomingInspectionSpecItemCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    no: number
    name: string
    spec: string
    incomingInspectionSpec: IncomingInspectionSpecCreateNestedOneWithoutIncomingInspectionSpecItemsInput
    incomingInspectionRecordItem?: IncomingInspectionRecordItemCreateNestedManyWithoutIncomingInspectionSpecItemInput
  }

  export type IncomingInspectionSpecItemUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    no: number
    name: string
    spec: string
    incomingInspectionSpecId: number
    incomingInspectionRecordItem?: IncomingInspectionRecordItemUncheckedCreateNestedManyWithoutIncomingInspectionSpecItemInput
  }

  export type IncomingInspectionSpecItemUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    no?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    spec?: StringFieldUpdateOperationsInput | string
    incomingInspectionSpec?: IncomingInspectionSpecUpdateOneRequiredWithoutIncomingInspectionSpecItemsNestedInput
    incomingInspectionRecordItem?: IncomingInspectionRecordItemUpdateManyWithoutIncomingInspectionSpecItemNestedInput
  }

  export type IncomingInspectionSpecItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    no?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    spec?: StringFieldUpdateOperationsInput | string
    incomingInspectionSpecId?: IntFieldUpdateOperationsInput | number
    incomingInspectionRecordItem?: IncomingInspectionRecordItemUncheckedUpdateManyWithoutIncomingInspectionSpecItemNestedInput
  }

  export type IncomingInspectionSpecItemCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    no: number
    name: string
    spec: string
    incomingInspectionSpecId: number
  }

  export type IncomingInspectionSpecItemUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    no?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    spec?: StringFieldUpdateOperationsInput | string
  }

  export type IncomingInspectionSpecItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    no?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    spec?: StringFieldUpdateOperationsInput | string
    incomingInspectionSpecId?: IntFieldUpdateOperationsInput | number
  }

  export type NonconformItemCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    description: string
    note?: string | null
    part: PartCreateNestedOneWithoutNonconformItemsInput
  }

  export type NonconformItemUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    partId: number
    description: string
    note?: string | null
  }

  export type NonconformItemUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    description?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    part?: PartUpdateOneRequiredWithoutNonconformItemsNestedInput
  }

  export type NonconformItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    partId?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NonconformItemCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    partId: number
    description: string
    note?: string | null
  }

  export type NonconformItemUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    description?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NonconformItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    partId?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PartOperationCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    version: string
    no: string
    name: string
    part: PartCreateNestedOneWithoutPartOperationInput
    partOperationInspectionItems?: PartOperationInspectionItemCreateNestedManyWithoutPartOperationInput
  }

  export type PartOperationUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    version: string
    no: string
    name: string
    partId: number
    partOperationInspectionItems?: PartOperationInspectionItemUncheckedCreateNestedManyWithoutPartOperationInput
  }

  export type PartOperationUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    version?: StringFieldUpdateOperationsInput | string
    no?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    part?: PartUpdateOneRequiredWithoutPartOperationNestedInput
    partOperationInspectionItems?: PartOperationInspectionItemUpdateManyWithoutPartOperationNestedInput
  }

  export type PartOperationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    version?: StringFieldUpdateOperationsInput | string
    no?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    partId?: IntFieldUpdateOperationsInput | number
    partOperationInspectionItems?: PartOperationInspectionItemUncheckedUpdateManyWithoutPartOperationNestedInput
  }

  export type PartOperationCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    version: string
    no: string
    name: string
    partId: number
  }

  export type PartOperationUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    version?: StringFieldUpdateOperationsInput | string
    no?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PartOperationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    version?: StringFieldUpdateOperationsInput | string
    no?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    partId?: IntFieldUpdateOperationsInput | number
  }

  export type PartOperationInspectionItemCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    partOperation: PartOperationCreateNestedOneWithoutPartOperationInspectionItemsInput
    operationInspectionRecordItems?: OperationInspectionRecordItemCreateNestedManyWithoutPartOperationInspectionItemInput
  }

  export type PartOperationInspectionItemUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    partOperationId: number
    operationInspectionRecordItems?: OperationInspectionRecordItemUncheckedCreateNestedManyWithoutPartOperationInspectionItemInput
  }

  export type PartOperationInspectionItemUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    partOperation?: PartOperationUpdateOneRequiredWithoutPartOperationInspectionItemsNestedInput
    operationInspectionRecordItems?: OperationInspectionRecordItemUpdateManyWithoutPartOperationInspectionItemNestedInput
  }

  export type PartOperationInspectionItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    partOperationId?: IntFieldUpdateOperationsInput | number
    operationInspectionRecordItems?: OperationInspectionRecordItemUncheckedUpdateManyWithoutPartOperationInspectionItemNestedInput
  }

  export type PartOperationInspectionItemCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    partOperationId: number
  }

  export type PartOperationInspectionItemUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PartOperationInspectionItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    partOperationId?: IntFieldUpdateOperationsInput | number
  }

  export type ReceiptCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    lot: string
    partVersion: PartVersionCreateNestedOneWithoutReceiptsInput
    incomingInspectionRecord?: IncomingInspectionRecordCreateNestedOneWithoutReceiptInput
  }

  export type ReceiptUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    lot: string
    partVersionId: number
    incomingInspectionRecord?: IncomingInspectionRecordUncheckedCreateNestedOneWithoutReceiptInput
  }

  export type ReceiptUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    lot?: StringFieldUpdateOperationsInput | string
    partVersion?: PartVersionUpdateOneRequiredWithoutReceiptsNestedInput
    incomingInspectionRecord?: IncomingInspectionRecordUpdateOneWithoutReceiptNestedInput
  }

  export type ReceiptUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    lot?: StringFieldUpdateOperationsInput | string
    partVersionId?: IntFieldUpdateOperationsInput | number
    incomingInspectionRecord?: IncomingInspectionRecordUncheckedUpdateOneWithoutReceiptNestedInput
  }

  export type ReceiptCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    lot: string
    partVersionId: number
  }

  export type ReceiptUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    lot?: StringFieldUpdateOperationsInput | string
  }

  export type ReceiptUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    lot?: StringFieldUpdateOperationsInput | string
    partVersionId?: IntFieldUpdateOperationsInput | number
  }

  export type IncomingInspectionRecordCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    note: string
    result: IncomingInspectionResult
    receipt: ReceiptCreateNestedOneWithoutIncomingInspectionRecordInput
    incomingInspectionSpec: IncomingInspectionSpecCreateNestedOneWithoutIncomingInspectionRecordsInput
    incomingInspectionRecordItems?: IncomingInspectionRecordItemCreateNestedManyWithoutIncomingInspectionRecordInput
  }

  export type IncomingInspectionRecordUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    note: string
    result: IncomingInspectionResult
    receiptId: number
    incomingInspectionSpecId: number
    incomingInspectionRecordItems?: IncomingInspectionRecordItemUncheckedCreateNestedManyWithoutIncomingInspectionRecordInput
  }

  export type IncomingInspectionRecordUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    note?: StringFieldUpdateOperationsInput | string
    result?: EnumIncomingInspectionResultFieldUpdateOperationsInput | IncomingInspectionResult
    receipt?: ReceiptUpdateOneRequiredWithoutIncomingInspectionRecordNestedInput
    incomingInspectionSpec?: IncomingInspectionSpecUpdateOneRequiredWithoutIncomingInspectionRecordsNestedInput
    incomingInspectionRecordItems?: IncomingInspectionRecordItemUpdateManyWithoutIncomingInspectionRecordNestedInput
  }

  export type IncomingInspectionRecordUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    note?: StringFieldUpdateOperationsInput | string
    result?: EnumIncomingInspectionResultFieldUpdateOperationsInput | IncomingInspectionResult
    receiptId?: IntFieldUpdateOperationsInput | number
    incomingInspectionSpecId?: IntFieldUpdateOperationsInput | number
    incomingInspectionRecordItems?: IncomingInspectionRecordItemUncheckedUpdateManyWithoutIncomingInspectionRecordNestedInput
  }

  export type IncomingInspectionRecordCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    note: string
    result: IncomingInspectionResult
    receiptId: number
    incomingInspectionSpecId: number
  }

  export type IncomingInspectionRecordUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    note?: StringFieldUpdateOperationsInput | string
    result?: EnumIncomingInspectionResultFieldUpdateOperationsInput | IncomingInspectionResult
  }

  export type IncomingInspectionRecordUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    note?: StringFieldUpdateOperationsInput | string
    result?: EnumIncomingInspectionResultFieldUpdateOperationsInput | IncomingInspectionResult
    receiptId?: IntFieldUpdateOperationsInput | number
    incomingInspectionSpecId?: IntFieldUpdateOperationsInput | number
  }

  export type IncomingInspectionRecordItemCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    result: boolean
    inspectionIteration: string
    incomingInspectionRecord: IncomingInspectionRecordCreateNestedOneWithoutIncomingInspectionRecordItemsInput
    incomingInspectionSpecItem: IncomingInspectionSpecItemCreateNestedOneWithoutIncomingInspectionRecordItemInput
  }

  export type IncomingInspectionRecordItemUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    result: boolean
    inspectionIteration: string
    incomingInspectionRecordId: number
    incomingInspectionSpecItemId: number
  }

  export type IncomingInspectionRecordItemUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    result?: BoolFieldUpdateOperationsInput | boolean
    inspectionIteration?: StringFieldUpdateOperationsInput | string
    incomingInspectionRecord?: IncomingInspectionRecordUpdateOneRequiredWithoutIncomingInspectionRecordItemsNestedInput
    incomingInspectionSpecItem?: IncomingInspectionSpecItemUpdateOneRequiredWithoutIncomingInspectionRecordItemNestedInput
  }

  export type IncomingInspectionRecordItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    result?: BoolFieldUpdateOperationsInput | boolean
    inspectionIteration?: StringFieldUpdateOperationsInput | string
    incomingInspectionRecordId?: IntFieldUpdateOperationsInput | number
    incomingInspectionSpecItemId?: IntFieldUpdateOperationsInput | number
  }

  export type IncomingInspectionRecordItemCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    result: boolean
    inspectionIteration: string
    incomingInspectionRecordId: number
    incomingInspectionSpecItemId: number
  }

  export type IncomingInspectionRecordItemUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    result?: BoolFieldUpdateOperationsInput | boolean
    inspectionIteration?: StringFieldUpdateOperationsInput | string
  }

  export type IncomingInspectionRecordItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    result?: BoolFieldUpdateOperationsInput | boolean
    inspectionIteration?: StringFieldUpdateOperationsInput | string
    incomingInspectionRecordId?: IntFieldUpdateOperationsInput | number
    incomingInspectionSpecItemId?: IntFieldUpdateOperationsInput | number
  }

  export type WorkerOrderCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    no: string
    part: PartCreateNestedOneWithoutWorkerOrdersInput
    operationInspectionRecords?: OperationInspectionRecordCreateNestedManyWithoutWorkerOrderInput
  }

  export type WorkerOrderUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    no: string
    partId: number
    operationInspectionRecords?: OperationInspectionRecordUncheckedCreateNestedManyWithoutWorkerOrderInput
  }

  export type WorkerOrderUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    no?: StringFieldUpdateOperationsInput | string
    part?: PartUpdateOneRequiredWithoutWorkerOrdersNestedInput
    operationInspectionRecords?: OperationInspectionRecordUpdateManyWithoutWorkerOrderNestedInput
  }

  export type WorkerOrderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    no?: StringFieldUpdateOperationsInput | string
    partId?: IntFieldUpdateOperationsInput | number
    operationInspectionRecords?: OperationInspectionRecordUncheckedUpdateManyWithoutWorkerOrderNestedInput
  }

  export type WorkerOrderCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    no: string
    partId: number
  }

  export type WorkerOrderUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    no?: StringFieldUpdateOperationsInput | string
  }

  export type WorkerOrderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    no?: StringFieldUpdateOperationsInput | string
    partId?: IntFieldUpdateOperationsInput | number
  }

  export type OperationInspectionRecordCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    note?: string | null
    workerOrder: WorkerOrderCreateNestedOneWithoutOperationInspectionRecordsInput
    inspector: UserCreateNestedOneWithoutReviewedOperationInspectionRecordsInput
    reviewer: UserCreateNestedOneWithoutInspectedOperationInspectionRecordsInput
    operationInspectionRecordItems?: OperationInspectionRecordItemCreateNestedManyWithoutOperationInspectionRecordInput
  }

  export type OperationInspectionRecordUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    note?: string | null
    workerOrderId: number
    inspectorId: number
    reviewerId: number
    operationInspectionRecordItems?: OperationInspectionRecordItemUncheckedCreateNestedManyWithoutOperationInspectionRecordInput
  }

  export type OperationInspectionRecordUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    note?: NullableStringFieldUpdateOperationsInput | string | null
    workerOrder?: WorkerOrderUpdateOneRequiredWithoutOperationInspectionRecordsNestedInput
    inspector?: UserUpdateOneRequiredWithoutReviewedOperationInspectionRecordsNestedInput
    reviewer?: UserUpdateOneRequiredWithoutInspectedOperationInspectionRecordsNestedInput
    operationInspectionRecordItems?: OperationInspectionRecordItemUpdateManyWithoutOperationInspectionRecordNestedInput
  }

  export type OperationInspectionRecordUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    note?: NullableStringFieldUpdateOperationsInput | string | null
    workerOrderId?: IntFieldUpdateOperationsInput | number
    inspectorId?: IntFieldUpdateOperationsInput | number
    reviewerId?: IntFieldUpdateOperationsInput | number
    operationInspectionRecordItems?: OperationInspectionRecordItemUncheckedUpdateManyWithoutOperationInspectionRecordNestedInput
  }

  export type OperationInspectionRecordCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    note?: string | null
    workerOrderId: number
    inspectorId: number
    reviewerId: number
  }

  export type OperationInspectionRecordUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OperationInspectionRecordUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    note?: NullableStringFieldUpdateOperationsInput | string | null
    workerOrderId?: IntFieldUpdateOperationsInput | number
    inspectorId?: IntFieldUpdateOperationsInput | number
    reviewerId?: IntFieldUpdateOperationsInput | number
  }

  export type OperationInspectionRecordItemCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    inspectionIteration: string
    partOperationInspectionItem: PartOperationInspectionItemCreateNestedOneWithoutOperationInspectionRecordItemsInput
    operationInspectionRecord: OperationInspectionRecordCreateNestedOneWithoutOperationInspectionRecordItemsInput
  }

  export type OperationInspectionRecordItemUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    inspectionIteration: string
    partOperationInspectionItemId: number
    operationInspectionRecordId: number
  }

  export type OperationInspectionRecordItemUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    inspectionIteration?: StringFieldUpdateOperationsInput | string
    partOperationInspectionItem?: PartOperationInspectionItemUpdateOneRequiredWithoutOperationInspectionRecordItemsNestedInput
    operationInspectionRecord?: OperationInspectionRecordUpdateOneRequiredWithoutOperationInspectionRecordItemsNestedInput
  }

  export type OperationInspectionRecordItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    inspectionIteration?: StringFieldUpdateOperationsInput | string
    partOperationInspectionItemId?: IntFieldUpdateOperationsInput | number
    operationInspectionRecordId?: IntFieldUpdateOperationsInput | number
  }

  export type OperationInspectionRecordItemCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    inspectionIteration: string
    partOperationInspectionItemId: number
    operationInspectionRecordId: number
  }

  export type OperationInspectionRecordItemUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    inspectionIteration?: StringFieldUpdateOperationsInput | string
  }

  export type OperationInspectionRecordItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    inspectionIteration?: StringFieldUpdateOperationsInput | string
    partOperationInspectionItemId?: IntFieldUpdateOperationsInput | number
    operationInspectionRecordId?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type TaskFormRelationCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    taskDefinitionKey?: SortOrder
    formKey?: SortOrder
  }

  export type TaskFormRelationAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TaskFormRelationMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    taskDefinitionKey?: SortOrder
    formKey?: SortOrder
  }

  export type TaskFormRelationMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    taskDefinitionKey?: SortOrder
    formKey?: SortOrder
  }

  export type TaskFormRelationSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type EnumUserStatusFilter = {
    equals?: UserStatus
    in?: Enumerable<UserStatus>
    notIn?: Enumerable<UserStatus>
    not?: NestedEnumUserStatusFilter | UserStatus
  }

  export type EnumUserGroupFilter = {
    equals?: UserGroup
    in?: Enumerable<UserGroup>
    notIn?: Enumerable<UserGroup>
    not?: NestedEnumUserGroupFilter | UserGroup
  }

  export type UserProfileRelationFilter = {
    is?: UserProfileWhereInput | null
    isNot?: UserProfileWhereInput | null
  }

  export type OperationInspectionRecordListRelationFilter = {
    every?: OperationInspectionRecordWhereInput
    some?: OperationInspectionRecordWhereInput
    none?: OperationInspectionRecordWhereInput
  }

  export type OperationInspectionRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    username?: SortOrder
    hashedPassword?: SortOrder
    hashedRefreshToken?: SortOrder
    status?: SortOrder
    role?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    username?: SortOrder
    hashedPassword?: SortOrder
    hashedRefreshToken?: SortOrder
    status?: SortOrder
    role?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    username?: SortOrder
    hashedPassword?: SortOrder
    hashedRefreshToken?: SortOrder
    status?: SortOrder
    role?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type EnumUserStatusWithAggregatesFilter = {
    equals?: UserStatus
    in?: Enumerable<UserStatus>
    notIn?: Enumerable<UserStatus>
    not?: NestedEnumUserStatusWithAggregatesFilter | UserStatus
    _count?: NestedIntFilter
    _min?: NestedEnumUserStatusFilter
    _max?: NestedEnumUserStatusFilter
  }

  export type EnumUserGroupWithAggregatesFilter = {
    equals?: UserGroup
    in?: Enumerable<UserGroup>
    notIn?: Enumerable<UserGroup>
    not?: NestedEnumUserGroupWithAggregatesFilter | UserGroup
    _count?: NestedIntFilter
    _min?: NestedEnumUserGroupFilter
    _max?: NestedEnumUserGroupFilter
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type UserProfileCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    userId?: SortOrder
    fullName?: SortOrder
  }

  export type UserProfileAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type UserProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    userId?: SortOrder
    fullName?: SortOrder
  }

  export type UserProfileMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    userId?: SortOrder
    fullName?: SortOrder
  }

  export type UserProfileSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type EquipmentListRelationFilter = {
    every?: EquipmentWhereInput
    some?: EquipmentWhereInput
    none?: EquipmentWhereInput
  }

  export type EquipmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductLineCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type ProductLineAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ProductLineMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type ProductLineMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type ProductLineSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ProductLineRelationFilter = {
    is?: ProductLineWhereInput
    isNot?: ProductLineWhereInput
  }

  export type RepairMaterialInventoryListRelationFilter = {
    every?: RepairMaterialInventoryWhereInput
    some?: RepairMaterialInventoryWhereInput
    none?: RepairMaterialInventoryWhereInput
  }

  export type RepairRecordListRelationFilter = {
    every?: RepairRecordWhereInput
    some?: RepairRecordWhereInput
    none?: RepairRecordWhereInput
  }

  export type RepairMaterialInventoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RepairRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EquipmentCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
    description?: SortOrder
    repairPlan?: SortOrder
    workStation?: SortOrder
    productLineId?: SortOrder
  }

  export type EquipmentAvgOrderByAggregateInput = {
    id?: SortOrder
    productLineId?: SortOrder
  }

  export type EquipmentMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
    description?: SortOrder
    repairPlan?: SortOrder
    workStation?: SortOrder
    productLineId?: SortOrder
  }

  export type EquipmentMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
    description?: SortOrder
    repairPlan?: SortOrder
    workStation?: SortOrder
    productLineId?: SortOrder
  }

  export type EquipmentSumOrderByAggregateInput = {
    id?: SortOrder
    productLineId?: SortOrder
  }

  export type EquipmentRelationFilter = {
    is?: EquipmentWhereInput
    isNot?: EquipmentWhereInput
  }

  export type RepairMaterialInventoryCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    minimumQuantity?: SortOrder
    equipmentId?: SortOrder
  }

  export type RepairMaterialInventoryAvgOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    minimumQuantity?: SortOrder
    equipmentId?: SortOrder
  }

  export type RepairMaterialInventoryMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    minimumQuantity?: SortOrder
    equipmentId?: SortOrder
  }

  export type RepairMaterialInventoryMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    minimumQuantity?: SortOrder
    equipmentId?: SortOrder
  }

  export type RepairMaterialInventorySumOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    minimumQuantity?: SortOrder
    equipmentId?: SortOrder
  }

  export type EnumRepairTypeFilter = {
    equals?: RepairType
    in?: Enumerable<RepairType>
    notIn?: Enumerable<RepairType>
    not?: NestedEnumRepairTypeFilter | RepairType
  }

  export type EnumRepairRecordStatusFilter = {
    equals?: RepairRecordStatus
    in?: Enumerable<RepairRecordStatus>
    notIn?: Enumerable<RepairRecordStatus>
    not?: NestedEnumRepairRecordStatusFilter | RepairRecordStatus
  }

  export type RepairRecordCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    type?: SortOrder
    equipmentId?: SortOrder
    status?: SortOrder
    description?: SortOrder
  }

  export type RepairRecordAvgOrderByAggregateInput = {
    id?: SortOrder
    equipmentId?: SortOrder
  }

  export type RepairRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    type?: SortOrder
    equipmentId?: SortOrder
    status?: SortOrder
    description?: SortOrder
  }

  export type RepairRecordMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    type?: SortOrder
    equipmentId?: SortOrder
    status?: SortOrder
    description?: SortOrder
  }

  export type RepairRecordSumOrderByAggregateInput = {
    id?: SortOrder
    equipmentId?: SortOrder
  }

  export type EnumRepairTypeWithAggregatesFilter = {
    equals?: RepairType
    in?: Enumerable<RepairType>
    notIn?: Enumerable<RepairType>
    not?: NestedEnumRepairTypeWithAggregatesFilter | RepairType
    _count?: NestedIntFilter
    _min?: NestedEnumRepairTypeFilter
    _max?: NestedEnumRepairTypeFilter
  }

  export type EnumRepairRecordStatusWithAggregatesFilter = {
    equals?: RepairRecordStatus
    in?: Enumerable<RepairRecordStatus>
    notIn?: Enumerable<RepairRecordStatus>
    not?: NestedEnumRepairRecordStatusWithAggregatesFilter | RepairRecordStatus
    _count?: NestedIntFilter
    _min?: NestedEnumRepairRecordStatusFilter
    _max?: NestedEnumRepairRecordStatusFilter
  }

  export type PartVersionListRelationFilter = {
    every?: PartVersionWhereInput
    some?: PartVersionWhereInput
    none?: PartVersionWhereInput
  }

  export type PartOperationListRelationFilter = {
    every?: PartOperationWhereInput
    some?: PartOperationWhereInput
    none?: PartOperationWhereInput
  }

  export type WorkerOrderListRelationFilter = {
    every?: WorkerOrderWhereInput
    some?: WorkerOrderWhereInput
    none?: WorkerOrderWhereInput
  }

  export type NonconformItemListRelationFilter = {
    every?: NonconformItemWhereInput
    some?: NonconformItemWhereInput
    none?: NonconformItemWhereInput
  }

  export type PartVersionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PartOperationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkerOrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NonconformItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PartCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    no?: SortOrder
    name?: SortOrder
  }

  export type PartAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PartMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    no?: SortOrder
    name?: SortOrder
  }

  export type PartMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    no?: SortOrder
    name?: SortOrder
  }

  export type PartSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PartRelationFilter = {
    is?: PartWhereInput
    isNot?: PartWhereInput
  }

  export type IncomingInspectionSpecRelationFilter = {
    is?: IncomingInspectionSpecWhereInput
    isNot?: IncomingInspectionSpecWhereInput
  }

  export type ReceiptListRelationFilter = {
    every?: ReceiptWhereInput
    some?: ReceiptWhereInput
    none?: ReceiptWhereInput
  }

  export type ReceiptOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PartVersionCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    version?: SortOrder
    note?: SortOrder
    partId?: SortOrder
  }

  export type PartVersionAvgOrderByAggregateInput = {
    id?: SortOrder
    partId?: SortOrder
  }

  export type PartVersionMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    version?: SortOrder
    note?: SortOrder
    partId?: SortOrder
  }

  export type PartVersionMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    version?: SortOrder
    note?: SortOrder
    partId?: SortOrder
  }

  export type PartVersionSumOrderByAggregateInput = {
    id?: SortOrder
    partId?: SortOrder
  }

  export type IncomingInspectionSpecItemListRelationFilter = {
    every?: IncomingInspectionSpecItemWhereInput
    some?: IncomingInspectionSpecItemWhereInput
    none?: IncomingInspectionSpecItemWhereInput
  }

  export type IncomingInspectionRecordListRelationFilter = {
    every?: IncomingInspectionRecordWhereInput
    some?: IncomingInspectionRecordWhereInput
    none?: IncomingInspectionRecordWhereInput
  }

  export type PartVersionRelationFilter = {
    is?: PartVersionWhereInput
    isNot?: PartVersionWhereInput
  }

  export type IncomingInspectionSpecItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IncomingInspectionRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IncomingInspectionSpecCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    version?: SortOrder
    attachment?: SortOrder
    partVersionId?: SortOrder
  }

  export type IncomingInspectionSpecAvgOrderByAggregateInput = {
    id?: SortOrder
    partVersionId?: SortOrder
  }

  export type IncomingInspectionSpecMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    version?: SortOrder
    attachment?: SortOrder
    partVersionId?: SortOrder
  }

  export type IncomingInspectionSpecMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    version?: SortOrder
    attachment?: SortOrder
    partVersionId?: SortOrder
  }

  export type IncomingInspectionSpecSumOrderByAggregateInput = {
    id?: SortOrder
    partVersionId?: SortOrder
  }

  export type IncomingInspectionRecordItemListRelationFilter = {
    every?: IncomingInspectionRecordItemWhereInput
    some?: IncomingInspectionRecordItemWhereInput
    none?: IncomingInspectionRecordItemWhereInput
  }

  export type IncomingInspectionRecordItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IncomingInspectionSpecItemCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    no?: SortOrder
    name?: SortOrder
    spec?: SortOrder
    incomingInspectionSpecId?: SortOrder
  }

  export type IncomingInspectionSpecItemAvgOrderByAggregateInput = {
    id?: SortOrder
    no?: SortOrder
    incomingInspectionSpecId?: SortOrder
  }

  export type IncomingInspectionSpecItemMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    no?: SortOrder
    name?: SortOrder
    spec?: SortOrder
    incomingInspectionSpecId?: SortOrder
  }

  export type IncomingInspectionSpecItemMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    no?: SortOrder
    name?: SortOrder
    spec?: SortOrder
    incomingInspectionSpecId?: SortOrder
  }

  export type IncomingInspectionSpecItemSumOrderByAggregateInput = {
    id?: SortOrder
    no?: SortOrder
    incomingInspectionSpecId?: SortOrder
  }

  export type NonconformItemCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    partId?: SortOrder
    description?: SortOrder
    note?: SortOrder
  }

  export type NonconformItemAvgOrderByAggregateInput = {
    id?: SortOrder
    partId?: SortOrder
  }

  export type NonconformItemMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    partId?: SortOrder
    description?: SortOrder
    note?: SortOrder
  }

  export type NonconformItemMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    partId?: SortOrder
    description?: SortOrder
    note?: SortOrder
  }

  export type NonconformItemSumOrderByAggregateInput = {
    id?: SortOrder
    partId?: SortOrder
  }

  export type PartOperationInspectionItemListRelationFilter = {
    every?: PartOperationInspectionItemWhereInput
    some?: PartOperationInspectionItemWhereInput
    none?: PartOperationInspectionItemWhereInput
  }

  export type PartOperationInspectionItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PartOperationCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    version?: SortOrder
    no?: SortOrder
    name?: SortOrder
    partId?: SortOrder
  }

  export type PartOperationAvgOrderByAggregateInput = {
    id?: SortOrder
    partId?: SortOrder
  }

  export type PartOperationMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    version?: SortOrder
    no?: SortOrder
    name?: SortOrder
    partId?: SortOrder
  }

  export type PartOperationMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    version?: SortOrder
    no?: SortOrder
    name?: SortOrder
    partId?: SortOrder
  }

  export type PartOperationSumOrderByAggregateInput = {
    id?: SortOrder
    partId?: SortOrder
  }

  export type PartOperationRelationFilter = {
    is?: PartOperationWhereInput
    isNot?: PartOperationWhereInput
  }

  export type OperationInspectionRecordItemListRelationFilter = {
    every?: OperationInspectionRecordItemWhereInput
    some?: OperationInspectionRecordItemWhereInput
    none?: OperationInspectionRecordItemWhereInput
  }

  export type OperationInspectionRecordItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PartOperationInspectionItemCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
    partOperationId?: SortOrder
  }

  export type PartOperationInspectionItemAvgOrderByAggregateInput = {
    id?: SortOrder
    partOperationId?: SortOrder
  }

  export type PartOperationInspectionItemMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
    partOperationId?: SortOrder
  }

  export type PartOperationInspectionItemMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
    partOperationId?: SortOrder
  }

  export type PartOperationInspectionItemSumOrderByAggregateInput = {
    id?: SortOrder
    partOperationId?: SortOrder
  }

  export type IncomingInspectionRecordRelationFilter = {
    is?: IncomingInspectionRecordWhereInput | null
    isNot?: IncomingInspectionRecordWhereInput | null
  }

  export type ReceiptCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    lot?: SortOrder
    partVersionId?: SortOrder
  }

  export type ReceiptAvgOrderByAggregateInput = {
    id?: SortOrder
    partVersionId?: SortOrder
  }

  export type ReceiptMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    lot?: SortOrder
    partVersionId?: SortOrder
  }

  export type ReceiptMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    lot?: SortOrder
    partVersionId?: SortOrder
  }

  export type ReceiptSumOrderByAggregateInput = {
    id?: SortOrder
    partVersionId?: SortOrder
  }

  export type EnumIncomingInspectionResultFilter = {
    equals?: IncomingInspectionResult
    in?: Enumerable<IncomingInspectionResult>
    notIn?: Enumerable<IncomingInspectionResult>
    not?: NestedEnumIncomingInspectionResultFilter | IncomingInspectionResult
  }

  export type ReceiptRelationFilter = {
    is?: ReceiptWhereInput
    isNot?: ReceiptWhereInput
  }

  export type IncomingInspectionRecordCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    note?: SortOrder
    result?: SortOrder
    receiptId?: SortOrder
    incomingInspectionSpecId?: SortOrder
  }

  export type IncomingInspectionRecordAvgOrderByAggregateInput = {
    id?: SortOrder
    receiptId?: SortOrder
    incomingInspectionSpecId?: SortOrder
  }

  export type IncomingInspectionRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    note?: SortOrder
    result?: SortOrder
    receiptId?: SortOrder
    incomingInspectionSpecId?: SortOrder
  }

  export type IncomingInspectionRecordMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    note?: SortOrder
    result?: SortOrder
    receiptId?: SortOrder
    incomingInspectionSpecId?: SortOrder
  }

  export type IncomingInspectionRecordSumOrderByAggregateInput = {
    id?: SortOrder
    receiptId?: SortOrder
    incomingInspectionSpecId?: SortOrder
  }

  export type EnumIncomingInspectionResultWithAggregatesFilter = {
    equals?: IncomingInspectionResult
    in?: Enumerable<IncomingInspectionResult>
    notIn?: Enumerable<IncomingInspectionResult>
    not?: NestedEnumIncomingInspectionResultWithAggregatesFilter | IncomingInspectionResult
    _count?: NestedIntFilter
    _min?: NestedEnumIncomingInspectionResultFilter
    _max?: NestedEnumIncomingInspectionResultFilter
  }

  export type IncomingInspectionSpecItemRelationFilter = {
    is?: IncomingInspectionSpecItemWhereInput
    isNot?: IncomingInspectionSpecItemWhereInput
  }

  export type IncomingInspectionRecordItemCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    result?: SortOrder
    inspectionIteration?: SortOrder
    incomingInspectionRecordId?: SortOrder
    incomingInspectionSpecItemId?: SortOrder
  }

  export type IncomingInspectionRecordItemAvgOrderByAggregateInput = {
    id?: SortOrder
    incomingInspectionRecordId?: SortOrder
    incomingInspectionSpecItemId?: SortOrder
  }

  export type IncomingInspectionRecordItemMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    result?: SortOrder
    inspectionIteration?: SortOrder
    incomingInspectionRecordId?: SortOrder
    incomingInspectionSpecItemId?: SortOrder
  }

  export type IncomingInspectionRecordItemMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    result?: SortOrder
    inspectionIteration?: SortOrder
    incomingInspectionRecordId?: SortOrder
    incomingInspectionSpecItemId?: SortOrder
  }

  export type IncomingInspectionRecordItemSumOrderByAggregateInput = {
    id?: SortOrder
    incomingInspectionRecordId?: SortOrder
    incomingInspectionSpecItemId?: SortOrder
  }

  export type WorkerOrderCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    no?: SortOrder
    partId?: SortOrder
  }

  export type WorkerOrderAvgOrderByAggregateInput = {
    id?: SortOrder
    partId?: SortOrder
  }

  export type WorkerOrderMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    no?: SortOrder
    partId?: SortOrder
  }

  export type WorkerOrderMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    no?: SortOrder
    partId?: SortOrder
  }

  export type WorkerOrderSumOrderByAggregateInput = {
    id?: SortOrder
    partId?: SortOrder
  }

  export type WorkerOrderRelationFilter = {
    is?: WorkerOrderWhereInput
    isNot?: WorkerOrderWhereInput
  }

  export type OperationInspectionRecordCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    note?: SortOrder
    workerOrderId?: SortOrder
    inspectorId?: SortOrder
    reviewerId?: SortOrder
  }

  export type OperationInspectionRecordAvgOrderByAggregateInput = {
    id?: SortOrder
    workerOrderId?: SortOrder
    inspectorId?: SortOrder
    reviewerId?: SortOrder
  }

  export type OperationInspectionRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    note?: SortOrder
    workerOrderId?: SortOrder
    inspectorId?: SortOrder
    reviewerId?: SortOrder
  }

  export type OperationInspectionRecordMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    note?: SortOrder
    workerOrderId?: SortOrder
    inspectorId?: SortOrder
    reviewerId?: SortOrder
  }

  export type OperationInspectionRecordSumOrderByAggregateInput = {
    id?: SortOrder
    workerOrderId?: SortOrder
    inspectorId?: SortOrder
    reviewerId?: SortOrder
  }

  export type PartOperationInspectionItemRelationFilter = {
    is?: PartOperationInspectionItemWhereInput
    isNot?: PartOperationInspectionItemWhereInput
  }

  export type OperationInspectionRecordRelationFilter = {
    is?: OperationInspectionRecordWhereInput
    isNot?: OperationInspectionRecordWhereInput
  }

  export type OperationInspectionRecordItemCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    inspectionIteration?: SortOrder
    partOperationInspectionItemId?: SortOrder
    operationInspectionRecordId?: SortOrder
  }

  export type OperationInspectionRecordItemAvgOrderByAggregateInput = {
    id?: SortOrder
    partOperationInspectionItemId?: SortOrder
    operationInspectionRecordId?: SortOrder
  }

  export type OperationInspectionRecordItemMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    inspectionIteration?: SortOrder
    partOperationInspectionItemId?: SortOrder
    operationInspectionRecordId?: SortOrder
  }

  export type OperationInspectionRecordItemMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    inspectionIteration?: SortOrder
    partOperationInspectionItemId?: SortOrder
    operationInspectionRecordId?: SortOrder
  }

  export type OperationInspectionRecordItemSumOrderByAggregateInput = {
    id?: SortOrder
    partOperationInspectionItemId?: SortOrder
    operationInspectionRecordId?: SortOrder
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutUserInput
    connect?: UserProfileWhereUniqueInput
  }

  export type OperationInspectionRecordCreateNestedManyWithoutInspectorInput = {
    create?: XOR<Enumerable<OperationInspectionRecordCreateWithoutInspectorInput>, Enumerable<OperationInspectionRecordUncheckedCreateWithoutInspectorInput>>
    connectOrCreate?: Enumerable<OperationInspectionRecordCreateOrConnectWithoutInspectorInput>
    createMany?: OperationInspectionRecordCreateManyInspectorInputEnvelope
    connect?: Enumerable<OperationInspectionRecordWhereUniqueInput>
  }

  export type OperationInspectionRecordCreateNestedManyWithoutReviewerInput = {
    create?: XOR<Enumerable<OperationInspectionRecordCreateWithoutReviewerInput>, Enumerable<OperationInspectionRecordUncheckedCreateWithoutReviewerInput>>
    connectOrCreate?: Enumerable<OperationInspectionRecordCreateOrConnectWithoutReviewerInput>
    createMany?: OperationInspectionRecordCreateManyReviewerInputEnvelope
    connect?: Enumerable<OperationInspectionRecordWhereUniqueInput>
  }

  export type UserProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutUserInput
    connect?: UserProfileWhereUniqueInput
  }

  export type OperationInspectionRecordUncheckedCreateNestedManyWithoutInspectorInput = {
    create?: XOR<Enumerable<OperationInspectionRecordCreateWithoutInspectorInput>, Enumerable<OperationInspectionRecordUncheckedCreateWithoutInspectorInput>>
    connectOrCreate?: Enumerable<OperationInspectionRecordCreateOrConnectWithoutInspectorInput>
    createMany?: OperationInspectionRecordCreateManyInspectorInputEnvelope
    connect?: Enumerable<OperationInspectionRecordWhereUniqueInput>
  }

  export type OperationInspectionRecordUncheckedCreateNestedManyWithoutReviewerInput = {
    create?: XOR<Enumerable<OperationInspectionRecordCreateWithoutReviewerInput>, Enumerable<OperationInspectionRecordUncheckedCreateWithoutReviewerInput>>
    connectOrCreate?: Enumerable<OperationInspectionRecordCreateOrConnectWithoutReviewerInput>
    createMany?: OperationInspectionRecordCreateManyReviewerInputEnvelope
    connect?: Enumerable<OperationInspectionRecordWhereUniqueInput>
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumUserStatusFieldUpdateOperationsInput = {
    set?: UserStatus
  }

  export type EnumUserGroupFieldUpdateOperationsInput = {
    set?: UserGroup
  }

  export type UserProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutUserInput
    upsert?: UserProfileUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserProfileWhereUniqueInput
    update?: XOR<UserProfileUpdateWithoutUserInput, UserProfileUncheckedUpdateWithoutUserInput>
  }

  export type OperationInspectionRecordUpdateManyWithoutInspectorNestedInput = {
    create?: XOR<Enumerable<OperationInspectionRecordCreateWithoutInspectorInput>, Enumerable<OperationInspectionRecordUncheckedCreateWithoutInspectorInput>>
    connectOrCreate?: Enumerable<OperationInspectionRecordCreateOrConnectWithoutInspectorInput>
    upsert?: Enumerable<OperationInspectionRecordUpsertWithWhereUniqueWithoutInspectorInput>
    createMany?: OperationInspectionRecordCreateManyInspectorInputEnvelope
    set?: Enumerable<OperationInspectionRecordWhereUniqueInput>
    disconnect?: Enumerable<OperationInspectionRecordWhereUniqueInput>
    delete?: Enumerable<OperationInspectionRecordWhereUniqueInput>
    connect?: Enumerable<OperationInspectionRecordWhereUniqueInput>
    update?: Enumerable<OperationInspectionRecordUpdateWithWhereUniqueWithoutInspectorInput>
    updateMany?: Enumerable<OperationInspectionRecordUpdateManyWithWhereWithoutInspectorInput>
    deleteMany?: Enumerable<OperationInspectionRecordScalarWhereInput>
  }

  export type OperationInspectionRecordUpdateManyWithoutReviewerNestedInput = {
    create?: XOR<Enumerable<OperationInspectionRecordCreateWithoutReviewerInput>, Enumerable<OperationInspectionRecordUncheckedCreateWithoutReviewerInput>>
    connectOrCreate?: Enumerable<OperationInspectionRecordCreateOrConnectWithoutReviewerInput>
    upsert?: Enumerable<OperationInspectionRecordUpsertWithWhereUniqueWithoutReviewerInput>
    createMany?: OperationInspectionRecordCreateManyReviewerInputEnvelope
    set?: Enumerable<OperationInspectionRecordWhereUniqueInput>
    disconnect?: Enumerable<OperationInspectionRecordWhereUniqueInput>
    delete?: Enumerable<OperationInspectionRecordWhereUniqueInput>
    connect?: Enumerable<OperationInspectionRecordWhereUniqueInput>
    update?: Enumerable<OperationInspectionRecordUpdateWithWhereUniqueWithoutReviewerInput>
    updateMany?: Enumerable<OperationInspectionRecordUpdateManyWithWhereWithoutReviewerInput>
    deleteMany?: Enumerable<OperationInspectionRecordScalarWhereInput>
  }

  export type UserProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutUserInput
    upsert?: UserProfileUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserProfileWhereUniqueInput
    update?: XOR<UserProfileUpdateWithoutUserInput, UserProfileUncheckedUpdateWithoutUserInput>
  }

  export type OperationInspectionRecordUncheckedUpdateManyWithoutInspectorNestedInput = {
    create?: XOR<Enumerable<OperationInspectionRecordCreateWithoutInspectorInput>, Enumerable<OperationInspectionRecordUncheckedCreateWithoutInspectorInput>>
    connectOrCreate?: Enumerable<OperationInspectionRecordCreateOrConnectWithoutInspectorInput>
    upsert?: Enumerable<OperationInspectionRecordUpsertWithWhereUniqueWithoutInspectorInput>
    createMany?: OperationInspectionRecordCreateManyInspectorInputEnvelope
    set?: Enumerable<OperationInspectionRecordWhereUniqueInput>
    disconnect?: Enumerable<OperationInspectionRecordWhereUniqueInput>
    delete?: Enumerable<OperationInspectionRecordWhereUniqueInput>
    connect?: Enumerable<OperationInspectionRecordWhereUniqueInput>
    update?: Enumerable<OperationInspectionRecordUpdateWithWhereUniqueWithoutInspectorInput>
    updateMany?: Enumerable<OperationInspectionRecordUpdateManyWithWhereWithoutInspectorInput>
    deleteMany?: Enumerable<OperationInspectionRecordScalarWhereInput>
  }

  export type OperationInspectionRecordUncheckedUpdateManyWithoutReviewerNestedInput = {
    create?: XOR<Enumerable<OperationInspectionRecordCreateWithoutReviewerInput>, Enumerable<OperationInspectionRecordUncheckedCreateWithoutReviewerInput>>
    connectOrCreate?: Enumerable<OperationInspectionRecordCreateOrConnectWithoutReviewerInput>
    upsert?: Enumerable<OperationInspectionRecordUpsertWithWhereUniqueWithoutReviewerInput>
    createMany?: OperationInspectionRecordCreateManyReviewerInputEnvelope
    set?: Enumerable<OperationInspectionRecordWhereUniqueInput>
    disconnect?: Enumerable<OperationInspectionRecordWhereUniqueInput>
    delete?: Enumerable<OperationInspectionRecordWhereUniqueInput>
    connect?: Enumerable<OperationInspectionRecordWhereUniqueInput>
    update?: Enumerable<OperationInspectionRecordUpdateWithWhereUniqueWithoutReviewerInput>
    updateMany?: Enumerable<OperationInspectionRecordUpdateManyWithWhereWithoutReviewerInput>
    deleteMany?: Enumerable<OperationInspectionRecordScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutProfileInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutProfileNestedInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    upsert?: UserUpsertWithoutProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
  }

  export type EquipmentCreateNestedManyWithoutProductLineInput = {
    create?: XOR<Enumerable<EquipmentCreateWithoutProductLineInput>, Enumerable<EquipmentUncheckedCreateWithoutProductLineInput>>
    connectOrCreate?: Enumerable<EquipmentCreateOrConnectWithoutProductLineInput>
    createMany?: EquipmentCreateManyProductLineInputEnvelope
    connect?: Enumerable<EquipmentWhereUniqueInput>
  }

  export type EquipmentUncheckedCreateNestedManyWithoutProductLineInput = {
    create?: XOR<Enumerable<EquipmentCreateWithoutProductLineInput>, Enumerable<EquipmentUncheckedCreateWithoutProductLineInput>>
    connectOrCreate?: Enumerable<EquipmentCreateOrConnectWithoutProductLineInput>
    createMany?: EquipmentCreateManyProductLineInputEnvelope
    connect?: Enumerable<EquipmentWhereUniqueInput>
  }

  export type EquipmentUpdateManyWithoutProductLineNestedInput = {
    create?: XOR<Enumerable<EquipmentCreateWithoutProductLineInput>, Enumerable<EquipmentUncheckedCreateWithoutProductLineInput>>
    connectOrCreate?: Enumerable<EquipmentCreateOrConnectWithoutProductLineInput>
    upsert?: Enumerable<EquipmentUpsertWithWhereUniqueWithoutProductLineInput>
    createMany?: EquipmentCreateManyProductLineInputEnvelope
    set?: Enumerable<EquipmentWhereUniqueInput>
    disconnect?: Enumerable<EquipmentWhereUniqueInput>
    delete?: Enumerable<EquipmentWhereUniqueInput>
    connect?: Enumerable<EquipmentWhereUniqueInput>
    update?: Enumerable<EquipmentUpdateWithWhereUniqueWithoutProductLineInput>
    updateMany?: Enumerable<EquipmentUpdateManyWithWhereWithoutProductLineInput>
    deleteMany?: Enumerable<EquipmentScalarWhereInput>
  }

  export type EquipmentUncheckedUpdateManyWithoutProductLineNestedInput = {
    create?: XOR<Enumerable<EquipmentCreateWithoutProductLineInput>, Enumerable<EquipmentUncheckedCreateWithoutProductLineInput>>
    connectOrCreate?: Enumerable<EquipmentCreateOrConnectWithoutProductLineInput>
    upsert?: Enumerable<EquipmentUpsertWithWhereUniqueWithoutProductLineInput>
    createMany?: EquipmentCreateManyProductLineInputEnvelope
    set?: Enumerable<EquipmentWhereUniqueInput>
    disconnect?: Enumerable<EquipmentWhereUniqueInput>
    delete?: Enumerable<EquipmentWhereUniqueInput>
    connect?: Enumerable<EquipmentWhereUniqueInput>
    update?: Enumerable<EquipmentUpdateWithWhereUniqueWithoutProductLineInput>
    updateMany?: Enumerable<EquipmentUpdateManyWithWhereWithoutProductLineInput>
    deleteMany?: Enumerable<EquipmentScalarWhereInput>
  }

  export type ProductLineCreateNestedOneWithoutEquipmentInput = {
    create?: XOR<ProductLineCreateWithoutEquipmentInput, ProductLineUncheckedCreateWithoutEquipmentInput>
    connectOrCreate?: ProductLineCreateOrConnectWithoutEquipmentInput
    connect?: ProductLineWhereUniqueInput
  }

  export type RepairMaterialInventoryCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<Enumerable<RepairMaterialInventoryCreateWithoutEquipmentInput>, Enumerable<RepairMaterialInventoryUncheckedCreateWithoutEquipmentInput>>
    connectOrCreate?: Enumerable<RepairMaterialInventoryCreateOrConnectWithoutEquipmentInput>
    createMany?: RepairMaterialInventoryCreateManyEquipmentInputEnvelope
    connect?: Enumerable<RepairMaterialInventoryWhereUniqueInput>
  }

  export type RepairRecordCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<Enumerable<RepairRecordCreateWithoutEquipmentInput>, Enumerable<RepairRecordUncheckedCreateWithoutEquipmentInput>>
    connectOrCreate?: Enumerable<RepairRecordCreateOrConnectWithoutEquipmentInput>
    createMany?: RepairRecordCreateManyEquipmentInputEnvelope
    connect?: Enumerable<RepairRecordWhereUniqueInput>
  }

  export type RepairMaterialInventoryUncheckedCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<Enumerable<RepairMaterialInventoryCreateWithoutEquipmentInput>, Enumerable<RepairMaterialInventoryUncheckedCreateWithoutEquipmentInput>>
    connectOrCreate?: Enumerable<RepairMaterialInventoryCreateOrConnectWithoutEquipmentInput>
    createMany?: RepairMaterialInventoryCreateManyEquipmentInputEnvelope
    connect?: Enumerable<RepairMaterialInventoryWhereUniqueInput>
  }

  export type RepairRecordUncheckedCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<Enumerable<RepairRecordCreateWithoutEquipmentInput>, Enumerable<RepairRecordUncheckedCreateWithoutEquipmentInput>>
    connectOrCreate?: Enumerable<RepairRecordCreateOrConnectWithoutEquipmentInput>
    createMany?: RepairRecordCreateManyEquipmentInputEnvelope
    connect?: Enumerable<RepairRecordWhereUniqueInput>
  }

  export type ProductLineUpdateOneRequiredWithoutEquipmentNestedInput = {
    create?: XOR<ProductLineCreateWithoutEquipmentInput, ProductLineUncheckedCreateWithoutEquipmentInput>
    connectOrCreate?: ProductLineCreateOrConnectWithoutEquipmentInput
    upsert?: ProductLineUpsertWithoutEquipmentInput
    connect?: ProductLineWhereUniqueInput
    update?: XOR<ProductLineUpdateWithoutEquipmentInput, ProductLineUncheckedUpdateWithoutEquipmentInput>
  }

  export type RepairMaterialInventoryUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<Enumerable<RepairMaterialInventoryCreateWithoutEquipmentInput>, Enumerable<RepairMaterialInventoryUncheckedCreateWithoutEquipmentInput>>
    connectOrCreate?: Enumerable<RepairMaterialInventoryCreateOrConnectWithoutEquipmentInput>
    upsert?: Enumerable<RepairMaterialInventoryUpsertWithWhereUniqueWithoutEquipmentInput>
    createMany?: RepairMaterialInventoryCreateManyEquipmentInputEnvelope
    set?: Enumerable<RepairMaterialInventoryWhereUniqueInput>
    disconnect?: Enumerable<RepairMaterialInventoryWhereUniqueInput>
    delete?: Enumerable<RepairMaterialInventoryWhereUniqueInput>
    connect?: Enumerable<RepairMaterialInventoryWhereUniqueInput>
    update?: Enumerable<RepairMaterialInventoryUpdateWithWhereUniqueWithoutEquipmentInput>
    updateMany?: Enumerable<RepairMaterialInventoryUpdateManyWithWhereWithoutEquipmentInput>
    deleteMany?: Enumerable<RepairMaterialInventoryScalarWhereInput>
  }

  export type RepairRecordUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<Enumerable<RepairRecordCreateWithoutEquipmentInput>, Enumerable<RepairRecordUncheckedCreateWithoutEquipmentInput>>
    connectOrCreate?: Enumerable<RepairRecordCreateOrConnectWithoutEquipmentInput>
    upsert?: Enumerable<RepairRecordUpsertWithWhereUniqueWithoutEquipmentInput>
    createMany?: RepairRecordCreateManyEquipmentInputEnvelope
    set?: Enumerable<RepairRecordWhereUniqueInput>
    disconnect?: Enumerable<RepairRecordWhereUniqueInput>
    delete?: Enumerable<RepairRecordWhereUniqueInput>
    connect?: Enumerable<RepairRecordWhereUniqueInput>
    update?: Enumerable<RepairRecordUpdateWithWhereUniqueWithoutEquipmentInput>
    updateMany?: Enumerable<RepairRecordUpdateManyWithWhereWithoutEquipmentInput>
    deleteMany?: Enumerable<RepairRecordScalarWhereInput>
  }

  export type RepairMaterialInventoryUncheckedUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<Enumerable<RepairMaterialInventoryCreateWithoutEquipmentInput>, Enumerable<RepairMaterialInventoryUncheckedCreateWithoutEquipmentInput>>
    connectOrCreate?: Enumerable<RepairMaterialInventoryCreateOrConnectWithoutEquipmentInput>
    upsert?: Enumerable<RepairMaterialInventoryUpsertWithWhereUniqueWithoutEquipmentInput>
    createMany?: RepairMaterialInventoryCreateManyEquipmentInputEnvelope
    set?: Enumerable<RepairMaterialInventoryWhereUniqueInput>
    disconnect?: Enumerable<RepairMaterialInventoryWhereUniqueInput>
    delete?: Enumerable<RepairMaterialInventoryWhereUniqueInput>
    connect?: Enumerable<RepairMaterialInventoryWhereUniqueInput>
    update?: Enumerable<RepairMaterialInventoryUpdateWithWhereUniqueWithoutEquipmentInput>
    updateMany?: Enumerable<RepairMaterialInventoryUpdateManyWithWhereWithoutEquipmentInput>
    deleteMany?: Enumerable<RepairMaterialInventoryScalarWhereInput>
  }

  export type RepairRecordUncheckedUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<Enumerable<RepairRecordCreateWithoutEquipmentInput>, Enumerable<RepairRecordUncheckedCreateWithoutEquipmentInput>>
    connectOrCreate?: Enumerable<RepairRecordCreateOrConnectWithoutEquipmentInput>
    upsert?: Enumerable<RepairRecordUpsertWithWhereUniqueWithoutEquipmentInput>
    createMany?: RepairRecordCreateManyEquipmentInputEnvelope
    set?: Enumerable<RepairRecordWhereUniqueInput>
    disconnect?: Enumerable<RepairRecordWhereUniqueInput>
    delete?: Enumerable<RepairRecordWhereUniqueInput>
    connect?: Enumerable<RepairRecordWhereUniqueInput>
    update?: Enumerable<RepairRecordUpdateWithWhereUniqueWithoutEquipmentInput>
    updateMany?: Enumerable<RepairRecordUpdateManyWithWhereWithoutEquipmentInput>
    deleteMany?: Enumerable<RepairRecordScalarWhereInput>
  }

  export type EquipmentCreateNestedOneWithoutRepairMaterialInventoriesInput = {
    create?: XOR<EquipmentCreateWithoutRepairMaterialInventoriesInput, EquipmentUncheckedCreateWithoutRepairMaterialInventoriesInput>
    connectOrCreate?: EquipmentCreateOrConnectWithoutRepairMaterialInventoriesInput
    connect?: EquipmentWhereUniqueInput
  }

  export type EquipmentUpdateOneRequiredWithoutRepairMaterialInventoriesNestedInput = {
    create?: XOR<EquipmentCreateWithoutRepairMaterialInventoriesInput, EquipmentUncheckedCreateWithoutRepairMaterialInventoriesInput>
    connectOrCreate?: EquipmentCreateOrConnectWithoutRepairMaterialInventoriesInput
    upsert?: EquipmentUpsertWithoutRepairMaterialInventoriesInput
    connect?: EquipmentWhereUniqueInput
    update?: XOR<EquipmentUpdateWithoutRepairMaterialInventoriesInput, EquipmentUncheckedUpdateWithoutRepairMaterialInventoriesInput>
  }

  export type EquipmentCreateNestedOneWithoutRepairRecordsInput = {
    create?: XOR<EquipmentCreateWithoutRepairRecordsInput, EquipmentUncheckedCreateWithoutRepairRecordsInput>
    connectOrCreate?: EquipmentCreateOrConnectWithoutRepairRecordsInput
    connect?: EquipmentWhereUniqueInput
  }

  export type EnumRepairTypeFieldUpdateOperationsInput = {
    set?: RepairType
  }

  export type EnumRepairRecordStatusFieldUpdateOperationsInput = {
    set?: RepairRecordStatus
  }

  export type EquipmentUpdateOneRequiredWithoutRepairRecordsNestedInput = {
    create?: XOR<EquipmentCreateWithoutRepairRecordsInput, EquipmentUncheckedCreateWithoutRepairRecordsInput>
    connectOrCreate?: EquipmentCreateOrConnectWithoutRepairRecordsInput
    upsert?: EquipmentUpsertWithoutRepairRecordsInput
    connect?: EquipmentWhereUniqueInput
    update?: XOR<EquipmentUpdateWithoutRepairRecordsInput, EquipmentUncheckedUpdateWithoutRepairRecordsInput>
  }

  export type PartVersionCreateNestedManyWithoutPartInput = {
    create?: XOR<Enumerable<PartVersionCreateWithoutPartInput>, Enumerable<PartVersionUncheckedCreateWithoutPartInput>>
    connectOrCreate?: Enumerable<PartVersionCreateOrConnectWithoutPartInput>
    createMany?: PartVersionCreateManyPartInputEnvelope
    connect?: Enumerable<PartVersionWhereUniqueInput>
  }

  export type PartOperationCreateNestedManyWithoutPartInput = {
    create?: XOR<Enumerable<PartOperationCreateWithoutPartInput>, Enumerable<PartOperationUncheckedCreateWithoutPartInput>>
    connectOrCreate?: Enumerable<PartOperationCreateOrConnectWithoutPartInput>
    createMany?: PartOperationCreateManyPartInputEnvelope
    connect?: Enumerable<PartOperationWhereUniqueInput>
  }

  export type WorkerOrderCreateNestedManyWithoutPartInput = {
    create?: XOR<Enumerable<WorkerOrderCreateWithoutPartInput>, Enumerable<WorkerOrderUncheckedCreateWithoutPartInput>>
    connectOrCreate?: Enumerable<WorkerOrderCreateOrConnectWithoutPartInput>
    createMany?: WorkerOrderCreateManyPartInputEnvelope
    connect?: Enumerable<WorkerOrderWhereUniqueInput>
  }

  export type NonconformItemCreateNestedManyWithoutPartInput = {
    create?: XOR<Enumerable<NonconformItemCreateWithoutPartInput>, Enumerable<NonconformItemUncheckedCreateWithoutPartInput>>
    connectOrCreate?: Enumerable<NonconformItemCreateOrConnectWithoutPartInput>
    createMany?: NonconformItemCreateManyPartInputEnvelope
    connect?: Enumerable<NonconformItemWhereUniqueInput>
  }

  export type PartVersionUncheckedCreateNestedManyWithoutPartInput = {
    create?: XOR<Enumerable<PartVersionCreateWithoutPartInput>, Enumerable<PartVersionUncheckedCreateWithoutPartInput>>
    connectOrCreate?: Enumerable<PartVersionCreateOrConnectWithoutPartInput>
    createMany?: PartVersionCreateManyPartInputEnvelope
    connect?: Enumerable<PartVersionWhereUniqueInput>
  }

  export type PartOperationUncheckedCreateNestedManyWithoutPartInput = {
    create?: XOR<Enumerable<PartOperationCreateWithoutPartInput>, Enumerable<PartOperationUncheckedCreateWithoutPartInput>>
    connectOrCreate?: Enumerable<PartOperationCreateOrConnectWithoutPartInput>
    createMany?: PartOperationCreateManyPartInputEnvelope
    connect?: Enumerable<PartOperationWhereUniqueInput>
  }

  export type WorkerOrderUncheckedCreateNestedManyWithoutPartInput = {
    create?: XOR<Enumerable<WorkerOrderCreateWithoutPartInput>, Enumerable<WorkerOrderUncheckedCreateWithoutPartInput>>
    connectOrCreate?: Enumerable<WorkerOrderCreateOrConnectWithoutPartInput>
    createMany?: WorkerOrderCreateManyPartInputEnvelope
    connect?: Enumerable<WorkerOrderWhereUniqueInput>
  }

  export type NonconformItemUncheckedCreateNestedManyWithoutPartInput = {
    create?: XOR<Enumerable<NonconformItemCreateWithoutPartInput>, Enumerable<NonconformItemUncheckedCreateWithoutPartInput>>
    connectOrCreate?: Enumerable<NonconformItemCreateOrConnectWithoutPartInput>
    createMany?: NonconformItemCreateManyPartInputEnvelope
    connect?: Enumerable<NonconformItemWhereUniqueInput>
  }

  export type PartVersionUpdateManyWithoutPartNestedInput = {
    create?: XOR<Enumerable<PartVersionCreateWithoutPartInput>, Enumerable<PartVersionUncheckedCreateWithoutPartInput>>
    connectOrCreate?: Enumerable<PartVersionCreateOrConnectWithoutPartInput>
    upsert?: Enumerable<PartVersionUpsertWithWhereUniqueWithoutPartInput>
    createMany?: PartVersionCreateManyPartInputEnvelope
    set?: Enumerable<PartVersionWhereUniqueInput>
    disconnect?: Enumerable<PartVersionWhereUniqueInput>
    delete?: Enumerable<PartVersionWhereUniqueInput>
    connect?: Enumerable<PartVersionWhereUniqueInput>
    update?: Enumerable<PartVersionUpdateWithWhereUniqueWithoutPartInput>
    updateMany?: Enumerable<PartVersionUpdateManyWithWhereWithoutPartInput>
    deleteMany?: Enumerable<PartVersionScalarWhereInput>
  }

  export type PartOperationUpdateManyWithoutPartNestedInput = {
    create?: XOR<Enumerable<PartOperationCreateWithoutPartInput>, Enumerable<PartOperationUncheckedCreateWithoutPartInput>>
    connectOrCreate?: Enumerable<PartOperationCreateOrConnectWithoutPartInput>
    upsert?: Enumerable<PartOperationUpsertWithWhereUniqueWithoutPartInput>
    createMany?: PartOperationCreateManyPartInputEnvelope
    set?: Enumerable<PartOperationWhereUniqueInput>
    disconnect?: Enumerable<PartOperationWhereUniqueInput>
    delete?: Enumerable<PartOperationWhereUniqueInput>
    connect?: Enumerable<PartOperationWhereUniqueInput>
    update?: Enumerable<PartOperationUpdateWithWhereUniqueWithoutPartInput>
    updateMany?: Enumerable<PartOperationUpdateManyWithWhereWithoutPartInput>
    deleteMany?: Enumerable<PartOperationScalarWhereInput>
  }

  export type WorkerOrderUpdateManyWithoutPartNestedInput = {
    create?: XOR<Enumerable<WorkerOrderCreateWithoutPartInput>, Enumerable<WorkerOrderUncheckedCreateWithoutPartInput>>
    connectOrCreate?: Enumerable<WorkerOrderCreateOrConnectWithoutPartInput>
    upsert?: Enumerable<WorkerOrderUpsertWithWhereUniqueWithoutPartInput>
    createMany?: WorkerOrderCreateManyPartInputEnvelope
    set?: Enumerable<WorkerOrderWhereUniqueInput>
    disconnect?: Enumerable<WorkerOrderWhereUniqueInput>
    delete?: Enumerable<WorkerOrderWhereUniqueInput>
    connect?: Enumerable<WorkerOrderWhereUniqueInput>
    update?: Enumerable<WorkerOrderUpdateWithWhereUniqueWithoutPartInput>
    updateMany?: Enumerable<WorkerOrderUpdateManyWithWhereWithoutPartInput>
    deleteMany?: Enumerable<WorkerOrderScalarWhereInput>
  }

  export type NonconformItemUpdateManyWithoutPartNestedInput = {
    create?: XOR<Enumerable<NonconformItemCreateWithoutPartInput>, Enumerable<NonconformItemUncheckedCreateWithoutPartInput>>
    connectOrCreate?: Enumerable<NonconformItemCreateOrConnectWithoutPartInput>
    upsert?: Enumerable<NonconformItemUpsertWithWhereUniqueWithoutPartInput>
    createMany?: NonconformItemCreateManyPartInputEnvelope
    set?: Enumerable<NonconformItemWhereUniqueInput>
    disconnect?: Enumerable<NonconformItemWhereUniqueInput>
    delete?: Enumerable<NonconformItemWhereUniqueInput>
    connect?: Enumerable<NonconformItemWhereUniqueInput>
    update?: Enumerable<NonconformItemUpdateWithWhereUniqueWithoutPartInput>
    updateMany?: Enumerable<NonconformItemUpdateManyWithWhereWithoutPartInput>
    deleteMany?: Enumerable<NonconformItemScalarWhereInput>
  }

  export type PartVersionUncheckedUpdateManyWithoutPartNestedInput = {
    create?: XOR<Enumerable<PartVersionCreateWithoutPartInput>, Enumerable<PartVersionUncheckedCreateWithoutPartInput>>
    connectOrCreate?: Enumerable<PartVersionCreateOrConnectWithoutPartInput>
    upsert?: Enumerable<PartVersionUpsertWithWhereUniqueWithoutPartInput>
    createMany?: PartVersionCreateManyPartInputEnvelope
    set?: Enumerable<PartVersionWhereUniqueInput>
    disconnect?: Enumerable<PartVersionWhereUniqueInput>
    delete?: Enumerable<PartVersionWhereUniqueInput>
    connect?: Enumerable<PartVersionWhereUniqueInput>
    update?: Enumerable<PartVersionUpdateWithWhereUniqueWithoutPartInput>
    updateMany?: Enumerable<PartVersionUpdateManyWithWhereWithoutPartInput>
    deleteMany?: Enumerable<PartVersionScalarWhereInput>
  }

  export type PartOperationUncheckedUpdateManyWithoutPartNestedInput = {
    create?: XOR<Enumerable<PartOperationCreateWithoutPartInput>, Enumerable<PartOperationUncheckedCreateWithoutPartInput>>
    connectOrCreate?: Enumerable<PartOperationCreateOrConnectWithoutPartInput>
    upsert?: Enumerable<PartOperationUpsertWithWhereUniqueWithoutPartInput>
    createMany?: PartOperationCreateManyPartInputEnvelope
    set?: Enumerable<PartOperationWhereUniqueInput>
    disconnect?: Enumerable<PartOperationWhereUniqueInput>
    delete?: Enumerable<PartOperationWhereUniqueInput>
    connect?: Enumerable<PartOperationWhereUniqueInput>
    update?: Enumerable<PartOperationUpdateWithWhereUniqueWithoutPartInput>
    updateMany?: Enumerable<PartOperationUpdateManyWithWhereWithoutPartInput>
    deleteMany?: Enumerable<PartOperationScalarWhereInput>
  }

  export type WorkerOrderUncheckedUpdateManyWithoutPartNestedInput = {
    create?: XOR<Enumerable<WorkerOrderCreateWithoutPartInput>, Enumerable<WorkerOrderUncheckedCreateWithoutPartInput>>
    connectOrCreate?: Enumerable<WorkerOrderCreateOrConnectWithoutPartInput>
    upsert?: Enumerable<WorkerOrderUpsertWithWhereUniqueWithoutPartInput>
    createMany?: WorkerOrderCreateManyPartInputEnvelope
    set?: Enumerable<WorkerOrderWhereUniqueInput>
    disconnect?: Enumerable<WorkerOrderWhereUniqueInput>
    delete?: Enumerable<WorkerOrderWhereUniqueInput>
    connect?: Enumerable<WorkerOrderWhereUniqueInput>
    update?: Enumerable<WorkerOrderUpdateWithWhereUniqueWithoutPartInput>
    updateMany?: Enumerable<WorkerOrderUpdateManyWithWhereWithoutPartInput>
    deleteMany?: Enumerable<WorkerOrderScalarWhereInput>
  }

  export type NonconformItemUncheckedUpdateManyWithoutPartNestedInput = {
    create?: XOR<Enumerable<NonconformItemCreateWithoutPartInput>, Enumerable<NonconformItemUncheckedCreateWithoutPartInput>>
    connectOrCreate?: Enumerable<NonconformItemCreateOrConnectWithoutPartInput>
    upsert?: Enumerable<NonconformItemUpsertWithWhereUniqueWithoutPartInput>
    createMany?: NonconformItemCreateManyPartInputEnvelope
    set?: Enumerable<NonconformItemWhereUniqueInput>
    disconnect?: Enumerable<NonconformItemWhereUniqueInput>
    delete?: Enumerable<NonconformItemWhereUniqueInput>
    connect?: Enumerable<NonconformItemWhereUniqueInput>
    update?: Enumerable<NonconformItemUpdateWithWhereUniqueWithoutPartInput>
    updateMany?: Enumerable<NonconformItemUpdateManyWithWhereWithoutPartInput>
    deleteMany?: Enumerable<NonconformItemScalarWhereInput>
  }

  export type PartCreateNestedOneWithoutPartVersionsInput = {
    create?: XOR<PartCreateWithoutPartVersionsInput, PartUncheckedCreateWithoutPartVersionsInput>
    connectOrCreate?: PartCreateOrConnectWithoutPartVersionsInput
    connect?: PartWhereUniqueInput
  }

  export type IncomingInspectionSpecCreateNestedOneWithoutPartVersionInput = {
    create?: XOR<IncomingInspectionSpecCreateWithoutPartVersionInput, IncomingInspectionSpecUncheckedCreateWithoutPartVersionInput>
    connectOrCreate?: IncomingInspectionSpecCreateOrConnectWithoutPartVersionInput
    connect?: IncomingInspectionSpecWhereUniqueInput
  }

  export type ReceiptCreateNestedManyWithoutPartVersionInput = {
    create?: XOR<Enumerable<ReceiptCreateWithoutPartVersionInput>, Enumerable<ReceiptUncheckedCreateWithoutPartVersionInput>>
    connectOrCreate?: Enumerable<ReceiptCreateOrConnectWithoutPartVersionInput>
    createMany?: ReceiptCreateManyPartVersionInputEnvelope
    connect?: Enumerable<ReceiptWhereUniqueInput>
  }

  export type IncomingInspectionSpecUncheckedCreateNestedOneWithoutPartVersionInput = {
    create?: XOR<IncomingInspectionSpecCreateWithoutPartVersionInput, IncomingInspectionSpecUncheckedCreateWithoutPartVersionInput>
    connectOrCreate?: IncomingInspectionSpecCreateOrConnectWithoutPartVersionInput
    connect?: IncomingInspectionSpecWhereUniqueInput
  }

  export type ReceiptUncheckedCreateNestedManyWithoutPartVersionInput = {
    create?: XOR<Enumerable<ReceiptCreateWithoutPartVersionInput>, Enumerable<ReceiptUncheckedCreateWithoutPartVersionInput>>
    connectOrCreate?: Enumerable<ReceiptCreateOrConnectWithoutPartVersionInput>
    createMany?: ReceiptCreateManyPartVersionInputEnvelope
    connect?: Enumerable<ReceiptWhereUniqueInput>
  }

  export type PartUpdateOneRequiredWithoutPartVersionsNestedInput = {
    create?: XOR<PartCreateWithoutPartVersionsInput, PartUncheckedCreateWithoutPartVersionsInput>
    connectOrCreate?: PartCreateOrConnectWithoutPartVersionsInput
    upsert?: PartUpsertWithoutPartVersionsInput
    connect?: PartWhereUniqueInput
    update?: XOR<PartUpdateWithoutPartVersionsInput, PartUncheckedUpdateWithoutPartVersionsInput>
  }

  export type IncomingInspectionSpecUpdateOneWithoutPartVersionNestedInput = {
    create?: XOR<IncomingInspectionSpecCreateWithoutPartVersionInput, IncomingInspectionSpecUncheckedCreateWithoutPartVersionInput>
    connectOrCreate?: IncomingInspectionSpecCreateOrConnectWithoutPartVersionInput
    upsert?: IncomingInspectionSpecUpsertWithoutPartVersionInput
    disconnect?: boolean
    delete?: boolean
    connect?: IncomingInspectionSpecWhereUniqueInput
    update?: XOR<IncomingInspectionSpecUpdateWithoutPartVersionInput, IncomingInspectionSpecUncheckedUpdateWithoutPartVersionInput>
  }

  export type ReceiptUpdateManyWithoutPartVersionNestedInput = {
    create?: XOR<Enumerable<ReceiptCreateWithoutPartVersionInput>, Enumerable<ReceiptUncheckedCreateWithoutPartVersionInput>>
    connectOrCreate?: Enumerable<ReceiptCreateOrConnectWithoutPartVersionInput>
    upsert?: Enumerable<ReceiptUpsertWithWhereUniqueWithoutPartVersionInput>
    createMany?: ReceiptCreateManyPartVersionInputEnvelope
    set?: Enumerable<ReceiptWhereUniqueInput>
    disconnect?: Enumerable<ReceiptWhereUniqueInput>
    delete?: Enumerable<ReceiptWhereUniqueInput>
    connect?: Enumerable<ReceiptWhereUniqueInput>
    update?: Enumerable<ReceiptUpdateWithWhereUniqueWithoutPartVersionInput>
    updateMany?: Enumerable<ReceiptUpdateManyWithWhereWithoutPartVersionInput>
    deleteMany?: Enumerable<ReceiptScalarWhereInput>
  }

  export type IncomingInspectionSpecUncheckedUpdateOneWithoutPartVersionNestedInput = {
    create?: XOR<IncomingInspectionSpecCreateWithoutPartVersionInput, IncomingInspectionSpecUncheckedCreateWithoutPartVersionInput>
    connectOrCreate?: IncomingInspectionSpecCreateOrConnectWithoutPartVersionInput
    upsert?: IncomingInspectionSpecUpsertWithoutPartVersionInput
    disconnect?: boolean
    delete?: boolean
    connect?: IncomingInspectionSpecWhereUniqueInput
    update?: XOR<IncomingInspectionSpecUpdateWithoutPartVersionInput, IncomingInspectionSpecUncheckedUpdateWithoutPartVersionInput>
  }

  export type ReceiptUncheckedUpdateManyWithoutPartVersionNestedInput = {
    create?: XOR<Enumerable<ReceiptCreateWithoutPartVersionInput>, Enumerable<ReceiptUncheckedCreateWithoutPartVersionInput>>
    connectOrCreate?: Enumerable<ReceiptCreateOrConnectWithoutPartVersionInput>
    upsert?: Enumerable<ReceiptUpsertWithWhereUniqueWithoutPartVersionInput>
    createMany?: ReceiptCreateManyPartVersionInputEnvelope
    set?: Enumerable<ReceiptWhereUniqueInput>
    disconnect?: Enumerable<ReceiptWhereUniqueInput>
    delete?: Enumerable<ReceiptWhereUniqueInput>
    connect?: Enumerable<ReceiptWhereUniqueInput>
    update?: Enumerable<ReceiptUpdateWithWhereUniqueWithoutPartVersionInput>
    updateMany?: Enumerable<ReceiptUpdateManyWithWhereWithoutPartVersionInput>
    deleteMany?: Enumerable<ReceiptScalarWhereInput>
  }

  export type IncomingInspectionSpecItemCreateNestedManyWithoutIncomingInspectionSpecInput = {
    create?: XOR<Enumerable<IncomingInspectionSpecItemCreateWithoutIncomingInspectionSpecInput>, Enumerable<IncomingInspectionSpecItemUncheckedCreateWithoutIncomingInspectionSpecInput>>
    connectOrCreate?: Enumerable<IncomingInspectionSpecItemCreateOrConnectWithoutIncomingInspectionSpecInput>
    createMany?: IncomingInspectionSpecItemCreateManyIncomingInspectionSpecInputEnvelope
    connect?: Enumerable<IncomingInspectionSpecItemWhereUniqueInput>
  }

  export type IncomingInspectionRecordCreateNestedManyWithoutIncomingInspectionSpecInput = {
    create?: XOR<Enumerable<IncomingInspectionRecordCreateWithoutIncomingInspectionSpecInput>, Enumerable<IncomingInspectionRecordUncheckedCreateWithoutIncomingInspectionSpecInput>>
    connectOrCreate?: Enumerable<IncomingInspectionRecordCreateOrConnectWithoutIncomingInspectionSpecInput>
    createMany?: IncomingInspectionRecordCreateManyIncomingInspectionSpecInputEnvelope
    connect?: Enumerable<IncomingInspectionRecordWhereUniqueInput>
  }

  export type PartVersionCreateNestedOneWithoutIncomingInspectionSpecInput = {
    create?: XOR<PartVersionCreateWithoutIncomingInspectionSpecInput, PartVersionUncheckedCreateWithoutIncomingInspectionSpecInput>
    connectOrCreate?: PartVersionCreateOrConnectWithoutIncomingInspectionSpecInput
    connect?: PartVersionWhereUniqueInput
  }

  export type IncomingInspectionSpecItemUncheckedCreateNestedManyWithoutIncomingInspectionSpecInput = {
    create?: XOR<Enumerable<IncomingInspectionSpecItemCreateWithoutIncomingInspectionSpecInput>, Enumerable<IncomingInspectionSpecItemUncheckedCreateWithoutIncomingInspectionSpecInput>>
    connectOrCreate?: Enumerable<IncomingInspectionSpecItemCreateOrConnectWithoutIncomingInspectionSpecInput>
    createMany?: IncomingInspectionSpecItemCreateManyIncomingInspectionSpecInputEnvelope
    connect?: Enumerable<IncomingInspectionSpecItemWhereUniqueInput>
  }

  export type IncomingInspectionRecordUncheckedCreateNestedManyWithoutIncomingInspectionSpecInput = {
    create?: XOR<Enumerable<IncomingInspectionRecordCreateWithoutIncomingInspectionSpecInput>, Enumerable<IncomingInspectionRecordUncheckedCreateWithoutIncomingInspectionSpecInput>>
    connectOrCreate?: Enumerable<IncomingInspectionRecordCreateOrConnectWithoutIncomingInspectionSpecInput>
    createMany?: IncomingInspectionRecordCreateManyIncomingInspectionSpecInputEnvelope
    connect?: Enumerable<IncomingInspectionRecordWhereUniqueInput>
  }

  export type IncomingInspectionSpecItemUpdateManyWithoutIncomingInspectionSpecNestedInput = {
    create?: XOR<Enumerable<IncomingInspectionSpecItemCreateWithoutIncomingInspectionSpecInput>, Enumerable<IncomingInspectionSpecItemUncheckedCreateWithoutIncomingInspectionSpecInput>>
    connectOrCreate?: Enumerable<IncomingInspectionSpecItemCreateOrConnectWithoutIncomingInspectionSpecInput>
    upsert?: Enumerable<IncomingInspectionSpecItemUpsertWithWhereUniqueWithoutIncomingInspectionSpecInput>
    createMany?: IncomingInspectionSpecItemCreateManyIncomingInspectionSpecInputEnvelope
    set?: Enumerable<IncomingInspectionSpecItemWhereUniqueInput>
    disconnect?: Enumerable<IncomingInspectionSpecItemWhereUniqueInput>
    delete?: Enumerable<IncomingInspectionSpecItemWhereUniqueInput>
    connect?: Enumerable<IncomingInspectionSpecItemWhereUniqueInput>
    update?: Enumerable<IncomingInspectionSpecItemUpdateWithWhereUniqueWithoutIncomingInspectionSpecInput>
    updateMany?: Enumerable<IncomingInspectionSpecItemUpdateManyWithWhereWithoutIncomingInspectionSpecInput>
    deleteMany?: Enumerable<IncomingInspectionSpecItemScalarWhereInput>
  }

  export type IncomingInspectionRecordUpdateManyWithoutIncomingInspectionSpecNestedInput = {
    create?: XOR<Enumerable<IncomingInspectionRecordCreateWithoutIncomingInspectionSpecInput>, Enumerable<IncomingInspectionRecordUncheckedCreateWithoutIncomingInspectionSpecInput>>
    connectOrCreate?: Enumerable<IncomingInspectionRecordCreateOrConnectWithoutIncomingInspectionSpecInput>
    upsert?: Enumerable<IncomingInspectionRecordUpsertWithWhereUniqueWithoutIncomingInspectionSpecInput>
    createMany?: IncomingInspectionRecordCreateManyIncomingInspectionSpecInputEnvelope
    set?: Enumerable<IncomingInspectionRecordWhereUniqueInput>
    disconnect?: Enumerable<IncomingInspectionRecordWhereUniqueInput>
    delete?: Enumerable<IncomingInspectionRecordWhereUniqueInput>
    connect?: Enumerable<IncomingInspectionRecordWhereUniqueInput>
    update?: Enumerable<IncomingInspectionRecordUpdateWithWhereUniqueWithoutIncomingInspectionSpecInput>
    updateMany?: Enumerable<IncomingInspectionRecordUpdateManyWithWhereWithoutIncomingInspectionSpecInput>
    deleteMany?: Enumerable<IncomingInspectionRecordScalarWhereInput>
  }

  export type PartVersionUpdateOneRequiredWithoutIncomingInspectionSpecNestedInput = {
    create?: XOR<PartVersionCreateWithoutIncomingInspectionSpecInput, PartVersionUncheckedCreateWithoutIncomingInspectionSpecInput>
    connectOrCreate?: PartVersionCreateOrConnectWithoutIncomingInspectionSpecInput
    upsert?: PartVersionUpsertWithoutIncomingInspectionSpecInput
    connect?: PartVersionWhereUniqueInput
    update?: XOR<PartVersionUpdateWithoutIncomingInspectionSpecInput, PartVersionUncheckedUpdateWithoutIncomingInspectionSpecInput>
  }

  export type IncomingInspectionSpecItemUncheckedUpdateManyWithoutIncomingInspectionSpecNestedInput = {
    create?: XOR<Enumerable<IncomingInspectionSpecItemCreateWithoutIncomingInspectionSpecInput>, Enumerable<IncomingInspectionSpecItemUncheckedCreateWithoutIncomingInspectionSpecInput>>
    connectOrCreate?: Enumerable<IncomingInspectionSpecItemCreateOrConnectWithoutIncomingInspectionSpecInput>
    upsert?: Enumerable<IncomingInspectionSpecItemUpsertWithWhereUniqueWithoutIncomingInspectionSpecInput>
    createMany?: IncomingInspectionSpecItemCreateManyIncomingInspectionSpecInputEnvelope
    set?: Enumerable<IncomingInspectionSpecItemWhereUniqueInput>
    disconnect?: Enumerable<IncomingInspectionSpecItemWhereUniqueInput>
    delete?: Enumerable<IncomingInspectionSpecItemWhereUniqueInput>
    connect?: Enumerable<IncomingInspectionSpecItemWhereUniqueInput>
    update?: Enumerable<IncomingInspectionSpecItemUpdateWithWhereUniqueWithoutIncomingInspectionSpecInput>
    updateMany?: Enumerable<IncomingInspectionSpecItemUpdateManyWithWhereWithoutIncomingInspectionSpecInput>
    deleteMany?: Enumerable<IncomingInspectionSpecItemScalarWhereInput>
  }

  export type IncomingInspectionRecordUncheckedUpdateManyWithoutIncomingInspectionSpecNestedInput = {
    create?: XOR<Enumerable<IncomingInspectionRecordCreateWithoutIncomingInspectionSpecInput>, Enumerable<IncomingInspectionRecordUncheckedCreateWithoutIncomingInspectionSpecInput>>
    connectOrCreate?: Enumerable<IncomingInspectionRecordCreateOrConnectWithoutIncomingInspectionSpecInput>
    upsert?: Enumerable<IncomingInspectionRecordUpsertWithWhereUniqueWithoutIncomingInspectionSpecInput>
    createMany?: IncomingInspectionRecordCreateManyIncomingInspectionSpecInputEnvelope
    set?: Enumerable<IncomingInspectionRecordWhereUniqueInput>
    disconnect?: Enumerable<IncomingInspectionRecordWhereUniqueInput>
    delete?: Enumerable<IncomingInspectionRecordWhereUniqueInput>
    connect?: Enumerable<IncomingInspectionRecordWhereUniqueInput>
    update?: Enumerable<IncomingInspectionRecordUpdateWithWhereUniqueWithoutIncomingInspectionSpecInput>
    updateMany?: Enumerable<IncomingInspectionRecordUpdateManyWithWhereWithoutIncomingInspectionSpecInput>
    deleteMany?: Enumerable<IncomingInspectionRecordScalarWhereInput>
  }

  export type IncomingInspectionSpecCreateNestedOneWithoutIncomingInspectionSpecItemsInput = {
    create?: XOR<IncomingInspectionSpecCreateWithoutIncomingInspectionSpecItemsInput, IncomingInspectionSpecUncheckedCreateWithoutIncomingInspectionSpecItemsInput>
    connectOrCreate?: IncomingInspectionSpecCreateOrConnectWithoutIncomingInspectionSpecItemsInput
    connect?: IncomingInspectionSpecWhereUniqueInput
  }

  export type IncomingInspectionRecordItemCreateNestedManyWithoutIncomingInspectionSpecItemInput = {
    create?: XOR<Enumerable<IncomingInspectionRecordItemCreateWithoutIncomingInspectionSpecItemInput>, Enumerable<IncomingInspectionRecordItemUncheckedCreateWithoutIncomingInspectionSpecItemInput>>
    connectOrCreate?: Enumerable<IncomingInspectionRecordItemCreateOrConnectWithoutIncomingInspectionSpecItemInput>
    createMany?: IncomingInspectionRecordItemCreateManyIncomingInspectionSpecItemInputEnvelope
    connect?: Enumerable<IncomingInspectionRecordItemWhereUniqueInput>
  }

  export type IncomingInspectionRecordItemUncheckedCreateNestedManyWithoutIncomingInspectionSpecItemInput = {
    create?: XOR<Enumerable<IncomingInspectionRecordItemCreateWithoutIncomingInspectionSpecItemInput>, Enumerable<IncomingInspectionRecordItemUncheckedCreateWithoutIncomingInspectionSpecItemInput>>
    connectOrCreate?: Enumerable<IncomingInspectionRecordItemCreateOrConnectWithoutIncomingInspectionSpecItemInput>
    createMany?: IncomingInspectionRecordItemCreateManyIncomingInspectionSpecItemInputEnvelope
    connect?: Enumerable<IncomingInspectionRecordItemWhereUniqueInput>
  }

  export type IncomingInspectionSpecUpdateOneRequiredWithoutIncomingInspectionSpecItemsNestedInput = {
    create?: XOR<IncomingInspectionSpecCreateWithoutIncomingInspectionSpecItemsInput, IncomingInspectionSpecUncheckedCreateWithoutIncomingInspectionSpecItemsInput>
    connectOrCreate?: IncomingInspectionSpecCreateOrConnectWithoutIncomingInspectionSpecItemsInput
    upsert?: IncomingInspectionSpecUpsertWithoutIncomingInspectionSpecItemsInput
    connect?: IncomingInspectionSpecWhereUniqueInput
    update?: XOR<IncomingInspectionSpecUpdateWithoutIncomingInspectionSpecItemsInput, IncomingInspectionSpecUncheckedUpdateWithoutIncomingInspectionSpecItemsInput>
  }

  export type IncomingInspectionRecordItemUpdateManyWithoutIncomingInspectionSpecItemNestedInput = {
    create?: XOR<Enumerable<IncomingInspectionRecordItemCreateWithoutIncomingInspectionSpecItemInput>, Enumerable<IncomingInspectionRecordItemUncheckedCreateWithoutIncomingInspectionSpecItemInput>>
    connectOrCreate?: Enumerable<IncomingInspectionRecordItemCreateOrConnectWithoutIncomingInspectionSpecItemInput>
    upsert?: Enumerable<IncomingInspectionRecordItemUpsertWithWhereUniqueWithoutIncomingInspectionSpecItemInput>
    createMany?: IncomingInspectionRecordItemCreateManyIncomingInspectionSpecItemInputEnvelope
    set?: Enumerable<IncomingInspectionRecordItemWhereUniqueInput>
    disconnect?: Enumerable<IncomingInspectionRecordItemWhereUniqueInput>
    delete?: Enumerable<IncomingInspectionRecordItemWhereUniqueInput>
    connect?: Enumerable<IncomingInspectionRecordItemWhereUniqueInput>
    update?: Enumerable<IncomingInspectionRecordItemUpdateWithWhereUniqueWithoutIncomingInspectionSpecItemInput>
    updateMany?: Enumerable<IncomingInspectionRecordItemUpdateManyWithWhereWithoutIncomingInspectionSpecItemInput>
    deleteMany?: Enumerable<IncomingInspectionRecordItemScalarWhereInput>
  }

  export type IncomingInspectionRecordItemUncheckedUpdateManyWithoutIncomingInspectionSpecItemNestedInput = {
    create?: XOR<Enumerable<IncomingInspectionRecordItemCreateWithoutIncomingInspectionSpecItemInput>, Enumerable<IncomingInspectionRecordItemUncheckedCreateWithoutIncomingInspectionSpecItemInput>>
    connectOrCreate?: Enumerable<IncomingInspectionRecordItemCreateOrConnectWithoutIncomingInspectionSpecItemInput>
    upsert?: Enumerable<IncomingInspectionRecordItemUpsertWithWhereUniqueWithoutIncomingInspectionSpecItemInput>
    createMany?: IncomingInspectionRecordItemCreateManyIncomingInspectionSpecItemInputEnvelope
    set?: Enumerable<IncomingInspectionRecordItemWhereUniqueInput>
    disconnect?: Enumerable<IncomingInspectionRecordItemWhereUniqueInput>
    delete?: Enumerable<IncomingInspectionRecordItemWhereUniqueInput>
    connect?: Enumerable<IncomingInspectionRecordItemWhereUniqueInput>
    update?: Enumerable<IncomingInspectionRecordItemUpdateWithWhereUniqueWithoutIncomingInspectionSpecItemInput>
    updateMany?: Enumerable<IncomingInspectionRecordItemUpdateManyWithWhereWithoutIncomingInspectionSpecItemInput>
    deleteMany?: Enumerable<IncomingInspectionRecordItemScalarWhereInput>
  }

  export type PartCreateNestedOneWithoutNonconformItemsInput = {
    create?: XOR<PartCreateWithoutNonconformItemsInput, PartUncheckedCreateWithoutNonconformItemsInput>
    connectOrCreate?: PartCreateOrConnectWithoutNonconformItemsInput
    connect?: PartWhereUniqueInput
  }

  export type PartUpdateOneRequiredWithoutNonconformItemsNestedInput = {
    create?: XOR<PartCreateWithoutNonconformItemsInput, PartUncheckedCreateWithoutNonconformItemsInput>
    connectOrCreate?: PartCreateOrConnectWithoutNonconformItemsInput
    upsert?: PartUpsertWithoutNonconformItemsInput
    connect?: PartWhereUniqueInput
    update?: XOR<PartUpdateWithoutNonconformItemsInput, PartUncheckedUpdateWithoutNonconformItemsInput>
  }

  export type PartCreateNestedOneWithoutPartOperationInput = {
    create?: XOR<PartCreateWithoutPartOperationInput, PartUncheckedCreateWithoutPartOperationInput>
    connectOrCreate?: PartCreateOrConnectWithoutPartOperationInput
    connect?: PartWhereUniqueInput
  }

  export type PartOperationInspectionItemCreateNestedManyWithoutPartOperationInput = {
    create?: XOR<Enumerable<PartOperationInspectionItemCreateWithoutPartOperationInput>, Enumerable<PartOperationInspectionItemUncheckedCreateWithoutPartOperationInput>>
    connectOrCreate?: Enumerable<PartOperationInspectionItemCreateOrConnectWithoutPartOperationInput>
    createMany?: PartOperationInspectionItemCreateManyPartOperationInputEnvelope
    connect?: Enumerable<PartOperationInspectionItemWhereUniqueInput>
  }

  export type PartOperationInspectionItemUncheckedCreateNestedManyWithoutPartOperationInput = {
    create?: XOR<Enumerable<PartOperationInspectionItemCreateWithoutPartOperationInput>, Enumerable<PartOperationInspectionItemUncheckedCreateWithoutPartOperationInput>>
    connectOrCreate?: Enumerable<PartOperationInspectionItemCreateOrConnectWithoutPartOperationInput>
    createMany?: PartOperationInspectionItemCreateManyPartOperationInputEnvelope
    connect?: Enumerable<PartOperationInspectionItemWhereUniqueInput>
  }

  export type PartUpdateOneRequiredWithoutPartOperationNestedInput = {
    create?: XOR<PartCreateWithoutPartOperationInput, PartUncheckedCreateWithoutPartOperationInput>
    connectOrCreate?: PartCreateOrConnectWithoutPartOperationInput
    upsert?: PartUpsertWithoutPartOperationInput
    connect?: PartWhereUniqueInput
    update?: XOR<PartUpdateWithoutPartOperationInput, PartUncheckedUpdateWithoutPartOperationInput>
  }

  export type PartOperationInspectionItemUpdateManyWithoutPartOperationNestedInput = {
    create?: XOR<Enumerable<PartOperationInspectionItemCreateWithoutPartOperationInput>, Enumerable<PartOperationInspectionItemUncheckedCreateWithoutPartOperationInput>>
    connectOrCreate?: Enumerable<PartOperationInspectionItemCreateOrConnectWithoutPartOperationInput>
    upsert?: Enumerable<PartOperationInspectionItemUpsertWithWhereUniqueWithoutPartOperationInput>
    createMany?: PartOperationInspectionItemCreateManyPartOperationInputEnvelope
    set?: Enumerable<PartOperationInspectionItemWhereUniqueInput>
    disconnect?: Enumerable<PartOperationInspectionItemWhereUniqueInput>
    delete?: Enumerable<PartOperationInspectionItemWhereUniqueInput>
    connect?: Enumerable<PartOperationInspectionItemWhereUniqueInput>
    update?: Enumerable<PartOperationInspectionItemUpdateWithWhereUniqueWithoutPartOperationInput>
    updateMany?: Enumerable<PartOperationInspectionItemUpdateManyWithWhereWithoutPartOperationInput>
    deleteMany?: Enumerable<PartOperationInspectionItemScalarWhereInput>
  }

  export type PartOperationInspectionItemUncheckedUpdateManyWithoutPartOperationNestedInput = {
    create?: XOR<Enumerable<PartOperationInspectionItemCreateWithoutPartOperationInput>, Enumerable<PartOperationInspectionItemUncheckedCreateWithoutPartOperationInput>>
    connectOrCreate?: Enumerable<PartOperationInspectionItemCreateOrConnectWithoutPartOperationInput>
    upsert?: Enumerable<PartOperationInspectionItemUpsertWithWhereUniqueWithoutPartOperationInput>
    createMany?: PartOperationInspectionItemCreateManyPartOperationInputEnvelope
    set?: Enumerable<PartOperationInspectionItemWhereUniqueInput>
    disconnect?: Enumerable<PartOperationInspectionItemWhereUniqueInput>
    delete?: Enumerable<PartOperationInspectionItemWhereUniqueInput>
    connect?: Enumerable<PartOperationInspectionItemWhereUniqueInput>
    update?: Enumerable<PartOperationInspectionItemUpdateWithWhereUniqueWithoutPartOperationInput>
    updateMany?: Enumerable<PartOperationInspectionItemUpdateManyWithWhereWithoutPartOperationInput>
    deleteMany?: Enumerable<PartOperationInspectionItemScalarWhereInput>
  }

  export type PartOperationCreateNestedOneWithoutPartOperationInspectionItemsInput = {
    create?: XOR<PartOperationCreateWithoutPartOperationInspectionItemsInput, PartOperationUncheckedCreateWithoutPartOperationInspectionItemsInput>
    connectOrCreate?: PartOperationCreateOrConnectWithoutPartOperationInspectionItemsInput
    connect?: PartOperationWhereUniqueInput
  }

  export type OperationInspectionRecordItemCreateNestedManyWithoutPartOperationInspectionItemInput = {
    create?: XOR<Enumerable<OperationInspectionRecordItemCreateWithoutPartOperationInspectionItemInput>, Enumerable<OperationInspectionRecordItemUncheckedCreateWithoutPartOperationInspectionItemInput>>
    connectOrCreate?: Enumerable<OperationInspectionRecordItemCreateOrConnectWithoutPartOperationInspectionItemInput>
    createMany?: OperationInspectionRecordItemCreateManyPartOperationInspectionItemInputEnvelope
    connect?: Enumerable<OperationInspectionRecordItemWhereUniqueInput>
  }

  export type OperationInspectionRecordItemUncheckedCreateNestedManyWithoutPartOperationInspectionItemInput = {
    create?: XOR<Enumerable<OperationInspectionRecordItemCreateWithoutPartOperationInspectionItemInput>, Enumerable<OperationInspectionRecordItemUncheckedCreateWithoutPartOperationInspectionItemInput>>
    connectOrCreate?: Enumerable<OperationInspectionRecordItemCreateOrConnectWithoutPartOperationInspectionItemInput>
    createMany?: OperationInspectionRecordItemCreateManyPartOperationInspectionItemInputEnvelope
    connect?: Enumerable<OperationInspectionRecordItemWhereUniqueInput>
  }

  export type PartOperationUpdateOneRequiredWithoutPartOperationInspectionItemsNestedInput = {
    create?: XOR<PartOperationCreateWithoutPartOperationInspectionItemsInput, PartOperationUncheckedCreateWithoutPartOperationInspectionItemsInput>
    connectOrCreate?: PartOperationCreateOrConnectWithoutPartOperationInspectionItemsInput
    upsert?: PartOperationUpsertWithoutPartOperationInspectionItemsInput
    connect?: PartOperationWhereUniqueInput
    update?: XOR<PartOperationUpdateWithoutPartOperationInspectionItemsInput, PartOperationUncheckedUpdateWithoutPartOperationInspectionItemsInput>
  }

  export type OperationInspectionRecordItemUpdateManyWithoutPartOperationInspectionItemNestedInput = {
    create?: XOR<Enumerable<OperationInspectionRecordItemCreateWithoutPartOperationInspectionItemInput>, Enumerable<OperationInspectionRecordItemUncheckedCreateWithoutPartOperationInspectionItemInput>>
    connectOrCreate?: Enumerable<OperationInspectionRecordItemCreateOrConnectWithoutPartOperationInspectionItemInput>
    upsert?: Enumerable<OperationInspectionRecordItemUpsertWithWhereUniqueWithoutPartOperationInspectionItemInput>
    createMany?: OperationInspectionRecordItemCreateManyPartOperationInspectionItemInputEnvelope
    set?: Enumerable<OperationInspectionRecordItemWhereUniqueInput>
    disconnect?: Enumerable<OperationInspectionRecordItemWhereUniqueInput>
    delete?: Enumerable<OperationInspectionRecordItemWhereUniqueInput>
    connect?: Enumerable<OperationInspectionRecordItemWhereUniqueInput>
    update?: Enumerable<OperationInspectionRecordItemUpdateWithWhereUniqueWithoutPartOperationInspectionItemInput>
    updateMany?: Enumerable<OperationInspectionRecordItemUpdateManyWithWhereWithoutPartOperationInspectionItemInput>
    deleteMany?: Enumerable<OperationInspectionRecordItemScalarWhereInput>
  }

  export type OperationInspectionRecordItemUncheckedUpdateManyWithoutPartOperationInspectionItemNestedInput = {
    create?: XOR<Enumerable<OperationInspectionRecordItemCreateWithoutPartOperationInspectionItemInput>, Enumerable<OperationInspectionRecordItemUncheckedCreateWithoutPartOperationInspectionItemInput>>
    connectOrCreate?: Enumerable<OperationInspectionRecordItemCreateOrConnectWithoutPartOperationInspectionItemInput>
    upsert?: Enumerable<OperationInspectionRecordItemUpsertWithWhereUniqueWithoutPartOperationInspectionItemInput>
    createMany?: OperationInspectionRecordItemCreateManyPartOperationInspectionItemInputEnvelope
    set?: Enumerable<OperationInspectionRecordItemWhereUniqueInput>
    disconnect?: Enumerable<OperationInspectionRecordItemWhereUniqueInput>
    delete?: Enumerable<OperationInspectionRecordItemWhereUniqueInput>
    connect?: Enumerable<OperationInspectionRecordItemWhereUniqueInput>
    update?: Enumerable<OperationInspectionRecordItemUpdateWithWhereUniqueWithoutPartOperationInspectionItemInput>
    updateMany?: Enumerable<OperationInspectionRecordItemUpdateManyWithWhereWithoutPartOperationInspectionItemInput>
    deleteMany?: Enumerable<OperationInspectionRecordItemScalarWhereInput>
  }

  export type PartVersionCreateNestedOneWithoutReceiptsInput = {
    create?: XOR<PartVersionCreateWithoutReceiptsInput, PartVersionUncheckedCreateWithoutReceiptsInput>
    connectOrCreate?: PartVersionCreateOrConnectWithoutReceiptsInput
    connect?: PartVersionWhereUniqueInput
  }

  export type IncomingInspectionRecordCreateNestedOneWithoutReceiptInput = {
    create?: XOR<IncomingInspectionRecordCreateWithoutReceiptInput, IncomingInspectionRecordUncheckedCreateWithoutReceiptInput>
    connectOrCreate?: IncomingInspectionRecordCreateOrConnectWithoutReceiptInput
    connect?: IncomingInspectionRecordWhereUniqueInput
  }

  export type IncomingInspectionRecordUncheckedCreateNestedOneWithoutReceiptInput = {
    create?: XOR<IncomingInspectionRecordCreateWithoutReceiptInput, IncomingInspectionRecordUncheckedCreateWithoutReceiptInput>
    connectOrCreate?: IncomingInspectionRecordCreateOrConnectWithoutReceiptInput
    connect?: IncomingInspectionRecordWhereUniqueInput
  }

  export type PartVersionUpdateOneRequiredWithoutReceiptsNestedInput = {
    create?: XOR<PartVersionCreateWithoutReceiptsInput, PartVersionUncheckedCreateWithoutReceiptsInput>
    connectOrCreate?: PartVersionCreateOrConnectWithoutReceiptsInput
    upsert?: PartVersionUpsertWithoutReceiptsInput
    connect?: PartVersionWhereUniqueInput
    update?: XOR<PartVersionUpdateWithoutReceiptsInput, PartVersionUncheckedUpdateWithoutReceiptsInput>
  }

  export type IncomingInspectionRecordUpdateOneWithoutReceiptNestedInput = {
    create?: XOR<IncomingInspectionRecordCreateWithoutReceiptInput, IncomingInspectionRecordUncheckedCreateWithoutReceiptInput>
    connectOrCreate?: IncomingInspectionRecordCreateOrConnectWithoutReceiptInput
    upsert?: IncomingInspectionRecordUpsertWithoutReceiptInput
    disconnect?: boolean
    delete?: boolean
    connect?: IncomingInspectionRecordWhereUniqueInput
    update?: XOR<IncomingInspectionRecordUpdateWithoutReceiptInput, IncomingInspectionRecordUncheckedUpdateWithoutReceiptInput>
  }

  export type IncomingInspectionRecordUncheckedUpdateOneWithoutReceiptNestedInput = {
    create?: XOR<IncomingInspectionRecordCreateWithoutReceiptInput, IncomingInspectionRecordUncheckedCreateWithoutReceiptInput>
    connectOrCreate?: IncomingInspectionRecordCreateOrConnectWithoutReceiptInput
    upsert?: IncomingInspectionRecordUpsertWithoutReceiptInput
    disconnect?: boolean
    delete?: boolean
    connect?: IncomingInspectionRecordWhereUniqueInput
    update?: XOR<IncomingInspectionRecordUpdateWithoutReceiptInput, IncomingInspectionRecordUncheckedUpdateWithoutReceiptInput>
  }

  export type ReceiptCreateNestedOneWithoutIncomingInspectionRecordInput = {
    create?: XOR<ReceiptCreateWithoutIncomingInspectionRecordInput, ReceiptUncheckedCreateWithoutIncomingInspectionRecordInput>
    connectOrCreate?: ReceiptCreateOrConnectWithoutIncomingInspectionRecordInput
    connect?: ReceiptWhereUniqueInput
  }

  export type IncomingInspectionSpecCreateNestedOneWithoutIncomingInspectionRecordsInput = {
    create?: XOR<IncomingInspectionSpecCreateWithoutIncomingInspectionRecordsInput, IncomingInspectionSpecUncheckedCreateWithoutIncomingInspectionRecordsInput>
    connectOrCreate?: IncomingInspectionSpecCreateOrConnectWithoutIncomingInspectionRecordsInput
    connect?: IncomingInspectionSpecWhereUniqueInput
  }

  export type IncomingInspectionRecordItemCreateNestedManyWithoutIncomingInspectionRecordInput = {
    create?: XOR<Enumerable<IncomingInspectionRecordItemCreateWithoutIncomingInspectionRecordInput>, Enumerable<IncomingInspectionRecordItemUncheckedCreateWithoutIncomingInspectionRecordInput>>
    connectOrCreate?: Enumerable<IncomingInspectionRecordItemCreateOrConnectWithoutIncomingInspectionRecordInput>
    createMany?: IncomingInspectionRecordItemCreateManyIncomingInspectionRecordInputEnvelope
    connect?: Enumerable<IncomingInspectionRecordItemWhereUniqueInput>
  }

  export type IncomingInspectionRecordItemUncheckedCreateNestedManyWithoutIncomingInspectionRecordInput = {
    create?: XOR<Enumerable<IncomingInspectionRecordItemCreateWithoutIncomingInspectionRecordInput>, Enumerable<IncomingInspectionRecordItemUncheckedCreateWithoutIncomingInspectionRecordInput>>
    connectOrCreate?: Enumerable<IncomingInspectionRecordItemCreateOrConnectWithoutIncomingInspectionRecordInput>
    createMany?: IncomingInspectionRecordItemCreateManyIncomingInspectionRecordInputEnvelope
    connect?: Enumerable<IncomingInspectionRecordItemWhereUniqueInput>
  }

  export type EnumIncomingInspectionResultFieldUpdateOperationsInput = {
    set?: IncomingInspectionResult
  }

  export type ReceiptUpdateOneRequiredWithoutIncomingInspectionRecordNestedInput = {
    create?: XOR<ReceiptCreateWithoutIncomingInspectionRecordInput, ReceiptUncheckedCreateWithoutIncomingInspectionRecordInput>
    connectOrCreate?: ReceiptCreateOrConnectWithoutIncomingInspectionRecordInput
    upsert?: ReceiptUpsertWithoutIncomingInspectionRecordInput
    connect?: ReceiptWhereUniqueInput
    update?: XOR<ReceiptUpdateWithoutIncomingInspectionRecordInput, ReceiptUncheckedUpdateWithoutIncomingInspectionRecordInput>
  }

  export type IncomingInspectionSpecUpdateOneRequiredWithoutIncomingInspectionRecordsNestedInput = {
    create?: XOR<IncomingInspectionSpecCreateWithoutIncomingInspectionRecordsInput, IncomingInspectionSpecUncheckedCreateWithoutIncomingInspectionRecordsInput>
    connectOrCreate?: IncomingInspectionSpecCreateOrConnectWithoutIncomingInspectionRecordsInput
    upsert?: IncomingInspectionSpecUpsertWithoutIncomingInspectionRecordsInput
    connect?: IncomingInspectionSpecWhereUniqueInput
    update?: XOR<IncomingInspectionSpecUpdateWithoutIncomingInspectionRecordsInput, IncomingInspectionSpecUncheckedUpdateWithoutIncomingInspectionRecordsInput>
  }

  export type IncomingInspectionRecordItemUpdateManyWithoutIncomingInspectionRecordNestedInput = {
    create?: XOR<Enumerable<IncomingInspectionRecordItemCreateWithoutIncomingInspectionRecordInput>, Enumerable<IncomingInspectionRecordItemUncheckedCreateWithoutIncomingInspectionRecordInput>>
    connectOrCreate?: Enumerable<IncomingInspectionRecordItemCreateOrConnectWithoutIncomingInspectionRecordInput>
    upsert?: Enumerable<IncomingInspectionRecordItemUpsertWithWhereUniqueWithoutIncomingInspectionRecordInput>
    createMany?: IncomingInspectionRecordItemCreateManyIncomingInspectionRecordInputEnvelope
    set?: Enumerable<IncomingInspectionRecordItemWhereUniqueInput>
    disconnect?: Enumerable<IncomingInspectionRecordItemWhereUniqueInput>
    delete?: Enumerable<IncomingInspectionRecordItemWhereUniqueInput>
    connect?: Enumerable<IncomingInspectionRecordItemWhereUniqueInput>
    update?: Enumerable<IncomingInspectionRecordItemUpdateWithWhereUniqueWithoutIncomingInspectionRecordInput>
    updateMany?: Enumerable<IncomingInspectionRecordItemUpdateManyWithWhereWithoutIncomingInspectionRecordInput>
    deleteMany?: Enumerable<IncomingInspectionRecordItemScalarWhereInput>
  }

  export type IncomingInspectionRecordItemUncheckedUpdateManyWithoutIncomingInspectionRecordNestedInput = {
    create?: XOR<Enumerable<IncomingInspectionRecordItemCreateWithoutIncomingInspectionRecordInput>, Enumerable<IncomingInspectionRecordItemUncheckedCreateWithoutIncomingInspectionRecordInput>>
    connectOrCreate?: Enumerable<IncomingInspectionRecordItemCreateOrConnectWithoutIncomingInspectionRecordInput>
    upsert?: Enumerable<IncomingInspectionRecordItemUpsertWithWhereUniqueWithoutIncomingInspectionRecordInput>
    createMany?: IncomingInspectionRecordItemCreateManyIncomingInspectionRecordInputEnvelope
    set?: Enumerable<IncomingInspectionRecordItemWhereUniqueInput>
    disconnect?: Enumerable<IncomingInspectionRecordItemWhereUniqueInput>
    delete?: Enumerable<IncomingInspectionRecordItemWhereUniqueInput>
    connect?: Enumerable<IncomingInspectionRecordItemWhereUniqueInput>
    update?: Enumerable<IncomingInspectionRecordItemUpdateWithWhereUniqueWithoutIncomingInspectionRecordInput>
    updateMany?: Enumerable<IncomingInspectionRecordItemUpdateManyWithWhereWithoutIncomingInspectionRecordInput>
    deleteMany?: Enumerable<IncomingInspectionRecordItemScalarWhereInput>
  }

  export type IncomingInspectionRecordCreateNestedOneWithoutIncomingInspectionRecordItemsInput = {
    create?: XOR<IncomingInspectionRecordCreateWithoutIncomingInspectionRecordItemsInput, IncomingInspectionRecordUncheckedCreateWithoutIncomingInspectionRecordItemsInput>
    connectOrCreate?: IncomingInspectionRecordCreateOrConnectWithoutIncomingInspectionRecordItemsInput
    connect?: IncomingInspectionRecordWhereUniqueInput
  }

  export type IncomingInspectionSpecItemCreateNestedOneWithoutIncomingInspectionRecordItemInput = {
    create?: XOR<IncomingInspectionSpecItemCreateWithoutIncomingInspectionRecordItemInput, IncomingInspectionSpecItemUncheckedCreateWithoutIncomingInspectionRecordItemInput>
    connectOrCreate?: IncomingInspectionSpecItemCreateOrConnectWithoutIncomingInspectionRecordItemInput
    connect?: IncomingInspectionSpecItemWhereUniqueInput
  }

  export type IncomingInspectionRecordUpdateOneRequiredWithoutIncomingInspectionRecordItemsNestedInput = {
    create?: XOR<IncomingInspectionRecordCreateWithoutIncomingInspectionRecordItemsInput, IncomingInspectionRecordUncheckedCreateWithoutIncomingInspectionRecordItemsInput>
    connectOrCreate?: IncomingInspectionRecordCreateOrConnectWithoutIncomingInspectionRecordItemsInput
    upsert?: IncomingInspectionRecordUpsertWithoutIncomingInspectionRecordItemsInput
    connect?: IncomingInspectionRecordWhereUniqueInput
    update?: XOR<IncomingInspectionRecordUpdateWithoutIncomingInspectionRecordItemsInput, IncomingInspectionRecordUncheckedUpdateWithoutIncomingInspectionRecordItemsInput>
  }

  export type IncomingInspectionSpecItemUpdateOneRequiredWithoutIncomingInspectionRecordItemNestedInput = {
    create?: XOR<IncomingInspectionSpecItemCreateWithoutIncomingInspectionRecordItemInput, IncomingInspectionSpecItemUncheckedCreateWithoutIncomingInspectionRecordItemInput>
    connectOrCreate?: IncomingInspectionSpecItemCreateOrConnectWithoutIncomingInspectionRecordItemInput
    upsert?: IncomingInspectionSpecItemUpsertWithoutIncomingInspectionRecordItemInput
    connect?: IncomingInspectionSpecItemWhereUniqueInput
    update?: XOR<IncomingInspectionSpecItemUpdateWithoutIncomingInspectionRecordItemInput, IncomingInspectionSpecItemUncheckedUpdateWithoutIncomingInspectionRecordItemInput>
  }

  export type PartCreateNestedOneWithoutWorkerOrdersInput = {
    create?: XOR<PartCreateWithoutWorkerOrdersInput, PartUncheckedCreateWithoutWorkerOrdersInput>
    connectOrCreate?: PartCreateOrConnectWithoutWorkerOrdersInput
    connect?: PartWhereUniqueInput
  }

  export type OperationInspectionRecordCreateNestedManyWithoutWorkerOrderInput = {
    create?: XOR<Enumerable<OperationInspectionRecordCreateWithoutWorkerOrderInput>, Enumerable<OperationInspectionRecordUncheckedCreateWithoutWorkerOrderInput>>
    connectOrCreate?: Enumerable<OperationInspectionRecordCreateOrConnectWithoutWorkerOrderInput>
    createMany?: OperationInspectionRecordCreateManyWorkerOrderInputEnvelope
    connect?: Enumerable<OperationInspectionRecordWhereUniqueInput>
  }

  export type OperationInspectionRecordUncheckedCreateNestedManyWithoutWorkerOrderInput = {
    create?: XOR<Enumerable<OperationInspectionRecordCreateWithoutWorkerOrderInput>, Enumerable<OperationInspectionRecordUncheckedCreateWithoutWorkerOrderInput>>
    connectOrCreate?: Enumerable<OperationInspectionRecordCreateOrConnectWithoutWorkerOrderInput>
    createMany?: OperationInspectionRecordCreateManyWorkerOrderInputEnvelope
    connect?: Enumerable<OperationInspectionRecordWhereUniqueInput>
  }

  export type PartUpdateOneRequiredWithoutWorkerOrdersNestedInput = {
    create?: XOR<PartCreateWithoutWorkerOrdersInput, PartUncheckedCreateWithoutWorkerOrdersInput>
    connectOrCreate?: PartCreateOrConnectWithoutWorkerOrdersInput
    upsert?: PartUpsertWithoutWorkerOrdersInput
    connect?: PartWhereUniqueInput
    update?: XOR<PartUpdateWithoutWorkerOrdersInput, PartUncheckedUpdateWithoutWorkerOrdersInput>
  }

  export type OperationInspectionRecordUpdateManyWithoutWorkerOrderNestedInput = {
    create?: XOR<Enumerable<OperationInspectionRecordCreateWithoutWorkerOrderInput>, Enumerable<OperationInspectionRecordUncheckedCreateWithoutWorkerOrderInput>>
    connectOrCreate?: Enumerable<OperationInspectionRecordCreateOrConnectWithoutWorkerOrderInput>
    upsert?: Enumerable<OperationInspectionRecordUpsertWithWhereUniqueWithoutWorkerOrderInput>
    createMany?: OperationInspectionRecordCreateManyWorkerOrderInputEnvelope
    set?: Enumerable<OperationInspectionRecordWhereUniqueInput>
    disconnect?: Enumerable<OperationInspectionRecordWhereUniqueInput>
    delete?: Enumerable<OperationInspectionRecordWhereUniqueInput>
    connect?: Enumerable<OperationInspectionRecordWhereUniqueInput>
    update?: Enumerable<OperationInspectionRecordUpdateWithWhereUniqueWithoutWorkerOrderInput>
    updateMany?: Enumerable<OperationInspectionRecordUpdateManyWithWhereWithoutWorkerOrderInput>
    deleteMany?: Enumerable<OperationInspectionRecordScalarWhereInput>
  }

  export type OperationInspectionRecordUncheckedUpdateManyWithoutWorkerOrderNestedInput = {
    create?: XOR<Enumerable<OperationInspectionRecordCreateWithoutWorkerOrderInput>, Enumerable<OperationInspectionRecordUncheckedCreateWithoutWorkerOrderInput>>
    connectOrCreate?: Enumerable<OperationInspectionRecordCreateOrConnectWithoutWorkerOrderInput>
    upsert?: Enumerable<OperationInspectionRecordUpsertWithWhereUniqueWithoutWorkerOrderInput>
    createMany?: OperationInspectionRecordCreateManyWorkerOrderInputEnvelope
    set?: Enumerable<OperationInspectionRecordWhereUniqueInput>
    disconnect?: Enumerable<OperationInspectionRecordWhereUniqueInput>
    delete?: Enumerable<OperationInspectionRecordWhereUniqueInput>
    connect?: Enumerable<OperationInspectionRecordWhereUniqueInput>
    update?: Enumerable<OperationInspectionRecordUpdateWithWhereUniqueWithoutWorkerOrderInput>
    updateMany?: Enumerable<OperationInspectionRecordUpdateManyWithWhereWithoutWorkerOrderInput>
    deleteMany?: Enumerable<OperationInspectionRecordScalarWhereInput>
  }

  export type WorkerOrderCreateNestedOneWithoutOperationInspectionRecordsInput = {
    create?: XOR<WorkerOrderCreateWithoutOperationInspectionRecordsInput, WorkerOrderUncheckedCreateWithoutOperationInspectionRecordsInput>
    connectOrCreate?: WorkerOrderCreateOrConnectWithoutOperationInspectionRecordsInput
    connect?: WorkerOrderWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReviewedOperationInspectionRecordsInput = {
    create?: XOR<UserCreateWithoutReviewedOperationInspectionRecordsInput, UserUncheckedCreateWithoutReviewedOperationInspectionRecordsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewedOperationInspectionRecordsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutInspectedOperationInspectionRecordsInput = {
    create?: XOR<UserCreateWithoutInspectedOperationInspectionRecordsInput, UserUncheckedCreateWithoutInspectedOperationInspectionRecordsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInspectedOperationInspectionRecordsInput
    connect?: UserWhereUniqueInput
  }

  export type OperationInspectionRecordItemCreateNestedManyWithoutOperationInspectionRecordInput = {
    create?: XOR<Enumerable<OperationInspectionRecordItemCreateWithoutOperationInspectionRecordInput>, Enumerable<OperationInspectionRecordItemUncheckedCreateWithoutOperationInspectionRecordInput>>
    connectOrCreate?: Enumerable<OperationInspectionRecordItemCreateOrConnectWithoutOperationInspectionRecordInput>
    createMany?: OperationInspectionRecordItemCreateManyOperationInspectionRecordInputEnvelope
    connect?: Enumerable<OperationInspectionRecordItemWhereUniqueInput>
  }

  export type OperationInspectionRecordItemUncheckedCreateNestedManyWithoutOperationInspectionRecordInput = {
    create?: XOR<Enumerable<OperationInspectionRecordItemCreateWithoutOperationInspectionRecordInput>, Enumerable<OperationInspectionRecordItemUncheckedCreateWithoutOperationInspectionRecordInput>>
    connectOrCreate?: Enumerable<OperationInspectionRecordItemCreateOrConnectWithoutOperationInspectionRecordInput>
    createMany?: OperationInspectionRecordItemCreateManyOperationInspectionRecordInputEnvelope
    connect?: Enumerable<OperationInspectionRecordItemWhereUniqueInput>
  }

  export type WorkerOrderUpdateOneRequiredWithoutOperationInspectionRecordsNestedInput = {
    create?: XOR<WorkerOrderCreateWithoutOperationInspectionRecordsInput, WorkerOrderUncheckedCreateWithoutOperationInspectionRecordsInput>
    connectOrCreate?: WorkerOrderCreateOrConnectWithoutOperationInspectionRecordsInput
    upsert?: WorkerOrderUpsertWithoutOperationInspectionRecordsInput
    connect?: WorkerOrderWhereUniqueInput
    update?: XOR<WorkerOrderUpdateWithoutOperationInspectionRecordsInput, WorkerOrderUncheckedUpdateWithoutOperationInspectionRecordsInput>
  }

  export type UserUpdateOneRequiredWithoutReviewedOperationInspectionRecordsNestedInput = {
    create?: XOR<UserCreateWithoutReviewedOperationInspectionRecordsInput, UserUncheckedCreateWithoutReviewedOperationInspectionRecordsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewedOperationInspectionRecordsInput
    upsert?: UserUpsertWithoutReviewedOperationInspectionRecordsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutReviewedOperationInspectionRecordsInput, UserUncheckedUpdateWithoutReviewedOperationInspectionRecordsInput>
  }

  export type UserUpdateOneRequiredWithoutInspectedOperationInspectionRecordsNestedInput = {
    create?: XOR<UserCreateWithoutInspectedOperationInspectionRecordsInput, UserUncheckedCreateWithoutInspectedOperationInspectionRecordsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInspectedOperationInspectionRecordsInput
    upsert?: UserUpsertWithoutInspectedOperationInspectionRecordsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutInspectedOperationInspectionRecordsInput, UserUncheckedUpdateWithoutInspectedOperationInspectionRecordsInput>
  }

  export type OperationInspectionRecordItemUpdateManyWithoutOperationInspectionRecordNestedInput = {
    create?: XOR<Enumerable<OperationInspectionRecordItemCreateWithoutOperationInspectionRecordInput>, Enumerable<OperationInspectionRecordItemUncheckedCreateWithoutOperationInspectionRecordInput>>
    connectOrCreate?: Enumerable<OperationInspectionRecordItemCreateOrConnectWithoutOperationInspectionRecordInput>
    upsert?: Enumerable<OperationInspectionRecordItemUpsertWithWhereUniqueWithoutOperationInspectionRecordInput>
    createMany?: OperationInspectionRecordItemCreateManyOperationInspectionRecordInputEnvelope
    set?: Enumerable<OperationInspectionRecordItemWhereUniqueInput>
    disconnect?: Enumerable<OperationInspectionRecordItemWhereUniqueInput>
    delete?: Enumerable<OperationInspectionRecordItemWhereUniqueInput>
    connect?: Enumerable<OperationInspectionRecordItemWhereUniqueInput>
    update?: Enumerable<OperationInspectionRecordItemUpdateWithWhereUniqueWithoutOperationInspectionRecordInput>
    updateMany?: Enumerable<OperationInspectionRecordItemUpdateManyWithWhereWithoutOperationInspectionRecordInput>
    deleteMany?: Enumerable<OperationInspectionRecordItemScalarWhereInput>
  }

  export type OperationInspectionRecordItemUncheckedUpdateManyWithoutOperationInspectionRecordNestedInput = {
    create?: XOR<Enumerable<OperationInspectionRecordItemCreateWithoutOperationInspectionRecordInput>, Enumerable<OperationInspectionRecordItemUncheckedCreateWithoutOperationInspectionRecordInput>>
    connectOrCreate?: Enumerable<OperationInspectionRecordItemCreateOrConnectWithoutOperationInspectionRecordInput>
    upsert?: Enumerable<OperationInspectionRecordItemUpsertWithWhereUniqueWithoutOperationInspectionRecordInput>
    createMany?: OperationInspectionRecordItemCreateManyOperationInspectionRecordInputEnvelope
    set?: Enumerable<OperationInspectionRecordItemWhereUniqueInput>
    disconnect?: Enumerable<OperationInspectionRecordItemWhereUniqueInput>
    delete?: Enumerable<OperationInspectionRecordItemWhereUniqueInput>
    connect?: Enumerable<OperationInspectionRecordItemWhereUniqueInput>
    update?: Enumerable<OperationInspectionRecordItemUpdateWithWhereUniqueWithoutOperationInspectionRecordInput>
    updateMany?: Enumerable<OperationInspectionRecordItemUpdateManyWithWhereWithoutOperationInspectionRecordInput>
    deleteMany?: Enumerable<OperationInspectionRecordItemScalarWhereInput>
  }

  export type PartOperationInspectionItemCreateNestedOneWithoutOperationInspectionRecordItemsInput = {
    create?: XOR<PartOperationInspectionItemCreateWithoutOperationInspectionRecordItemsInput, PartOperationInspectionItemUncheckedCreateWithoutOperationInspectionRecordItemsInput>
    connectOrCreate?: PartOperationInspectionItemCreateOrConnectWithoutOperationInspectionRecordItemsInput
    connect?: PartOperationInspectionItemWhereUniqueInput
  }

  export type OperationInspectionRecordCreateNestedOneWithoutOperationInspectionRecordItemsInput = {
    create?: XOR<OperationInspectionRecordCreateWithoutOperationInspectionRecordItemsInput, OperationInspectionRecordUncheckedCreateWithoutOperationInspectionRecordItemsInput>
    connectOrCreate?: OperationInspectionRecordCreateOrConnectWithoutOperationInspectionRecordItemsInput
    connect?: OperationInspectionRecordWhereUniqueInput
  }

  export type PartOperationInspectionItemUpdateOneRequiredWithoutOperationInspectionRecordItemsNestedInput = {
    create?: XOR<PartOperationInspectionItemCreateWithoutOperationInspectionRecordItemsInput, PartOperationInspectionItemUncheckedCreateWithoutOperationInspectionRecordItemsInput>
    connectOrCreate?: PartOperationInspectionItemCreateOrConnectWithoutOperationInspectionRecordItemsInput
    upsert?: PartOperationInspectionItemUpsertWithoutOperationInspectionRecordItemsInput
    connect?: PartOperationInspectionItemWhereUniqueInput
    update?: XOR<PartOperationInspectionItemUpdateWithoutOperationInspectionRecordItemsInput, PartOperationInspectionItemUncheckedUpdateWithoutOperationInspectionRecordItemsInput>
  }

  export type OperationInspectionRecordUpdateOneRequiredWithoutOperationInspectionRecordItemsNestedInput = {
    create?: XOR<OperationInspectionRecordCreateWithoutOperationInspectionRecordItemsInput, OperationInspectionRecordUncheckedCreateWithoutOperationInspectionRecordItemsInput>
    connectOrCreate?: OperationInspectionRecordCreateOrConnectWithoutOperationInspectionRecordItemsInput
    upsert?: OperationInspectionRecordUpsertWithoutOperationInspectionRecordItemsInput
    connect?: OperationInspectionRecordWhereUniqueInput
    update?: XOR<OperationInspectionRecordUpdateWithoutOperationInspectionRecordItemsInput, OperationInspectionRecordUncheckedUpdateWithoutOperationInspectionRecordItemsInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedEnumUserStatusFilter = {
    equals?: UserStatus
    in?: Enumerable<UserStatus>
    notIn?: Enumerable<UserStatus>
    not?: NestedEnumUserStatusFilter | UserStatus
  }

  export type NestedEnumUserGroupFilter = {
    equals?: UserGroup
    in?: Enumerable<UserGroup>
    notIn?: Enumerable<UserGroup>
    not?: NestedEnumUserGroupFilter | UserGroup
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedEnumUserStatusWithAggregatesFilter = {
    equals?: UserStatus
    in?: Enumerable<UserStatus>
    notIn?: Enumerable<UserStatus>
    not?: NestedEnumUserStatusWithAggregatesFilter | UserStatus
    _count?: NestedIntFilter
    _min?: NestedEnumUserStatusFilter
    _max?: NestedEnumUserStatusFilter
  }

  export type NestedEnumUserGroupWithAggregatesFilter = {
    equals?: UserGroup
    in?: Enumerable<UserGroup>
    notIn?: Enumerable<UserGroup>
    not?: NestedEnumUserGroupWithAggregatesFilter | UserGroup
    _count?: NestedIntFilter
    _min?: NestedEnumUserGroupFilter
    _max?: NestedEnumUserGroupFilter
  }

  export type NestedEnumRepairTypeFilter = {
    equals?: RepairType
    in?: Enumerable<RepairType>
    notIn?: Enumerable<RepairType>
    not?: NestedEnumRepairTypeFilter | RepairType
  }

  export type NestedEnumRepairRecordStatusFilter = {
    equals?: RepairRecordStatus
    in?: Enumerable<RepairRecordStatus>
    notIn?: Enumerable<RepairRecordStatus>
    not?: NestedEnumRepairRecordStatusFilter | RepairRecordStatus
  }

  export type NestedEnumRepairTypeWithAggregatesFilter = {
    equals?: RepairType
    in?: Enumerable<RepairType>
    notIn?: Enumerable<RepairType>
    not?: NestedEnumRepairTypeWithAggregatesFilter | RepairType
    _count?: NestedIntFilter
    _min?: NestedEnumRepairTypeFilter
    _max?: NestedEnumRepairTypeFilter
  }

  export type NestedEnumRepairRecordStatusWithAggregatesFilter = {
    equals?: RepairRecordStatus
    in?: Enumerable<RepairRecordStatus>
    notIn?: Enumerable<RepairRecordStatus>
    not?: NestedEnumRepairRecordStatusWithAggregatesFilter | RepairRecordStatus
    _count?: NestedIntFilter
    _min?: NestedEnumRepairRecordStatusFilter
    _max?: NestedEnumRepairRecordStatusFilter
  }

  export type NestedEnumIncomingInspectionResultFilter = {
    equals?: IncomingInspectionResult
    in?: Enumerable<IncomingInspectionResult>
    notIn?: Enumerable<IncomingInspectionResult>
    not?: NestedEnumIncomingInspectionResultFilter | IncomingInspectionResult
  }

  export type NestedEnumIncomingInspectionResultWithAggregatesFilter = {
    equals?: IncomingInspectionResult
    in?: Enumerable<IncomingInspectionResult>
    notIn?: Enumerable<IncomingInspectionResult>
    not?: NestedEnumIncomingInspectionResultWithAggregatesFilter | IncomingInspectionResult
    _count?: NestedIntFilter
    _min?: NestedEnumIncomingInspectionResultFilter
    _max?: NestedEnumIncomingInspectionResultFilter
  }

  export type UserProfileCreateWithoutUserInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    fullName: string
  }

  export type UserProfileUncheckedCreateWithoutUserInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    fullName: string
  }

  export type UserProfileCreateOrConnectWithoutUserInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
  }

  export type OperationInspectionRecordCreateWithoutInspectorInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    note?: string | null
    workerOrder: WorkerOrderCreateNestedOneWithoutOperationInspectionRecordsInput
    reviewer: UserCreateNestedOneWithoutInspectedOperationInspectionRecordsInput
    operationInspectionRecordItems?: OperationInspectionRecordItemCreateNestedManyWithoutOperationInspectionRecordInput
  }

  export type OperationInspectionRecordUncheckedCreateWithoutInspectorInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    note?: string | null
    workerOrderId: number
    reviewerId: number
    operationInspectionRecordItems?: OperationInspectionRecordItemUncheckedCreateNestedManyWithoutOperationInspectionRecordInput
  }

  export type OperationInspectionRecordCreateOrConnectWithoutInspectorInput = {
    where: OperationInspectionRecordWhereUniqueInput
    create: XOR<OperationInspectionRecordCreateWithoutInspectorInput, OperationInspectionRecordUncheckedCreateWithoutInspectorInput>
  }

  export type OperationInspectionRecordCreateManyInspectorInputEnvelope = {
    data: Enumerable<OperationInspectionRecordCreateManyInspectorInput>
    skipDuplicates?: boolean
  }

  export type OperationInspectionRecordCreateWithoutReviewerInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    note?: string | null
    workerOrder: WorkerOrderCreateNestedOneWithoutOperationInspectionRecordsInput
    inspector: UserCreateNestedOneWithoutReviewedOperationInspectionRecordsInput
    operationInspectionRecordItems?: OperationInspectionRecordItemCreateNestedManyWithoutOperationInspectionRecordInput
  }

  export type OperationInspectionRecordUncheckedCreateWithoutReviewerInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    note?: string | null
    workerOrderId: number
    inspectorId: number
    operationInspectionRecordItems?: OperationInspectionRecordItemUncheckedCreateNestedManyWithoutOperationInspectionRecordInput
  }

  export type OperationInspectionRecordCreateOrConnectWithoutReviewerInput = {
    where: OperationInspectionRecordWhereUniqueInput
    create: XOR<OperationInspectionRecordCreateWithoutReviewerInput, OperationInspectionRecordUncheckedCreateWithoutReviewerInput>
  }

  export type OperationInspectionRecordCreateManyReviewerInputEnvelope = {
    data: Enumerable<OperationInspectionRecordCreateManyReviewerInput>
    skipDuplicates?: boolean
  }

  export type UserProfileUpsertWithoutUserInput = {
    update: XOR<UserProfileUpdateWithoutUserInput, UserProfileUncheckedUpdateWithoutUserInput>
    create: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
  }

  export type UserProfileUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    fullName?: StringFieldUpdateOperationsInput | string
  }

  export type UserProfileUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    fullName?: StringFieldUpdateOperationsInput | string
  }

  export type OperationInspectionRecordUpsertWithWhereUniqueWithoutInspectorInput = {
    where: OperationInspectionRecordWhereUniqueInput
    update: XOR<OperationInspectionRecordUpdateWithoutInspectorInput, OperationInspectionRecordUncheckedUpdateWithoutInspectorInput>
    create: XOR<OperationInspectionRecordCreateWithoutInspectorInput, OperationInspectionRecordUncheckedCreateWithoutInspectorInput>
  }

  export type OperationInspectionRecordUpdateWithWhereUniqueWithoutInspectorInput = {
    where: OperationInspectionRecordWhereUniqueInput
    data: XOR<OperationInspectionRecordUpdateWithoutInspectorInput, OperationInspectionRecordUncheckedUpdateWithoutInspectorInput>
  }

  export type OperationInspectionRecordUpdateManyWithWhereWithoutInspectorInput = {
    where: OperationInspectionRecordScalarWhereInput
    data: XOR<OperationInspectionRecordUpdateManyMutationInput, OperationInspectionRecordUncheckedUpdateManyWithoutReviewedOperationInspectionRecordsInput>
  }

  export type OperationInspectionRecordScalarWhereInput = {
    AND?: Enumerable<OperationInspectionRecordScalarWhereInput>
    OR?: Enumerable<OperationInspectionRecordScalarWhereInput>
    NOT?: Enumerable<OperationInspectionRecordScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    note?: StringNullableFilter | string | null
    workerOrderId?: IntFilter | number
    inspectorId?: IntFilter | number
    reviewerId?: IntFilter | number
  }

  export type OperationInspectionRecordUpsertWithWhereUniqueWithoutReviewerInput = {
    where: OperationInspectionRecordWhereUniqueInput
    update: XOR<OperationInspectionRecordUpdateWithoutReviewerInput, OperationInspectionRecordUncheckedUpdateWithoutReviewerInput>
    create: XOR<OperationInspectionRecordCreateWithoutReviewerInput, OperationInspectionRecordUncheckedCreateWithoutReviewerInput>
  }

  export type OperationInspectionRecordUpdateWithWhereUniqueWithoutReviewerInput = {
    where: OperationInspectionRecordWhereUniqueInput
    data: XOR<OperationInspectionRecordUpdateWithoutReviewerInput, OperationInspectionRecordUncheckedUpdateWithoutReviewerInput>
  }

  export type OperationInspectionRecordUpdateManyWithWhereWithoutReviewerInput = {
    where: OperationInspectionRecordScalarWhereInput
    data: XOR<OperationInspectionRecordUpdateManyMutationInput, OperationInspectionRecordUncheckedUpdateManyWithoutInspectedOperationInspectionRecordsInput>
  }

  export type UserCreateWithoutProfileInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    username: string
    hashedPassword?: string | null
    hashedRefreshToken?: string | null
    status: UserStatus
    role?: UserGroup
    reviewedOperationInspectionRecords?: OperationInspectionRecordCreateNestedManyWithoutInspectorInput
    inspectedOperationInspectionRecords?: OperationInspectionRecordCreateNestedManyWithoutReviewerInput
  }

  export type UserUncheckedCreateWithoutProfileInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    username: string
    hashedPassword?: string | null
    hashedRefreshToken?: string | null
    status: UserStatus
    role?: UserGroup
    reviewedOperationInspectionRecords?: OperationInspectionRecordUncheckedCreateNestedManyWithoutInspectorInput
    inspectedOperationInspectionRecords?: OperationInspectionRecordUncheckedCreateNestedManyWithoutReviewerInput
  }

  export type UserCreateOrConnectWithoutProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
  }

  export type UserUpsertWithoutProfileInput = {
    update: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
  }

  export type UserUpdateWithoutProfileInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    username?: StringFieldUpdateOperationsInput | string
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    hashedRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | UserStatus
    role?: EnumUserGroupFieldUpdateOperationsInput | UserGroup
    reviewedOperationInspectionRecords?: OperationInspectionRecordUpdateManyWithoutInspectorNestedInput
    inspectedOperationInspectionRecords?: OperationInspectionRecordUpdateManyWithoutReviewerNestedInput
  }

  export type UserUncheckedUpdateWithoutProfileInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    username?: StringFieldUpdateOperationsInput | string
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    hashedRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | UserStatus
    role?: EnumUserGroupFieldUpdateOperationsInput | UserGroup
    reviewedOperationInspectionRecords?: OperationInspectionRecordUncheckedUpdateManyWithoutInspectorNestedInput
    inspectedOperationInspectionRecords?: OperationInspectionRecordUncheckedUpdateManyWithoutReviewerNestedInput
  }

  export type EquipmentCreateWithoutProductLineInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    description: string
    repairPlan: string
    workStation: string
    repairMaterialInventories?: RepairMaterialInventoryCreateNestedManyWithoutEquipmentInput
    repairRecords?: RepairRecordCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentUncheckedCreateWithoutProductLineInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    description: string
    repairPlan: string
    workStation: string
    repairMaterialInventories?: RepairMaterialInventoryUncheckedCreateNestedManyWithoutEquipmentInput
    repairRecords?: RepairRecordUncheckedCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentCreateOrConnectWithoutProductLineInput = {
    where: EquipmentWhereUniqueInput
    create: XOR<EquipmentCreateWithoutProductLineInput, EquipmentUncheckedCreateWithoutProductLineInput>
  }

  export type EquipmentCreateManyProductLineInputEnvelope = {
    data: Enumerable<EquipmentCreateManyProductLineInput>
    skipDuplicates?: boolean
  }

  export type EquipmentUpsertWithWhereUniqueWithoutProductLineInput = {
    where: EquipmentWhereUniqueInput
    update: XOR<EquipmentUpdateWithoutProductLineInput, EquipmentUncheckedUpdateWithoutProductLineInput>
    create: XOR<EquipmentCreateWithoutProductLineInput, EquipmentUncheckedCreateWithoutProductLineInput>
  }

  export type EquipmentUpdateWithWhereUniqueWithoutProductLineInput = {
    where: EquipmentWhereUniqueInput
    data: XOR<EquipmentUpdateWithoutProductLineInput, EquipmentUncheckedUpdateWithoutProductLineInput>
  }

  export type EquipmentUpdateManyWithWhereWithoutProductLineInput = {
    where: EquipmentScalarWhereInput
    data: XOR<EquipmentUpdateManyMutationInput, EquipmentUncheckedUpdateManyWithoutEquipmentInput>
  }

  export type EquipmentScalarWhereInput = {
    AND?: Enumerable<EquipmentScalarWhereInput>
    OR?: Enumerable<EquipmentScalarWhereInput>
    NOT?: Enumerable<EquipmentScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    name?: StringFilter | string
    description?: StringFilter | string
    repairPlan?: StringFilter | string
    workStation?: StringFilter | string
    productLineId?: IntFilter | number
  }

  export type ProductLineCreateWithoutEquipmentInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    description: string
  }

  export type ProductLineUncheckedCreateWithoutEquipmentInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    description: string
  }

  export type ProductLineCreateOrConnectWithoutEquipmentInput = {
    where: ProductLineWhereUniqueInput
    create: XOR<ProductLineCreateWithoutEquipmentInput, ProductLineUncheckedCreateWithoutEquipmentInput>
  }

  export type RepairMaterialInventoryCreateWithoutEquipmentInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    description: string
    quantity: number
    minimumQuantity: number
  }

  export type RepairMaterialInventoryUncheckedCreateWithoutEquipmentInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    description: string
    quantity: number
    minimumQuantity: number
  }

  export type RepairMaterialInventoryCreateOrConnectWithoutEquipmentInput = {
    where: RepairMaterialInventoryWhereUniqueInput
    create: XOR<RepairMaterialInventoryCreateWithoutEquipmentInput, RepairMaterialInventoryUncheckedCreateWithoutEquipmentInput>
  }

  export type RepairMaterialInventoryCreateManyEquipmentInputEnvelope = {
    data: Enumerable<RepairMaterialInventoryCreateManyEquipmentInput>
    skipDuplicates?: boolean
  }

  export type RepairRecordCreateWithoutEquipmentInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    type: RepairType
    status: RepairRecordStatus
    description: string
  }

  export type RepairRecordUncheckedCreateWithoutEquipmentInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    type: RepairType
    status: RepairRecordStatus
    description: string
  }

  export type RepairRecordCreateOrConnectWithoutEquipmentInput = {
    where: RepairRecordWhereUniqueInput
    create: XOR<RepairRecordCreateWithoutEquipmentInput, RepairRecordUncheckedCreateWithoutEquipmentInput>
  }

  export type RepairRecordCreateManyEquipmentInputEnvelope = {
    data: Enumerable<RepairRecordCreateManyEquipmentInput>
    skipDuplicates?: boolean
  }

  export type ProductLineUpsertWithoutEquipmentInput = {
    update: XOR<ProductLineUpdateWithoutEquipmentInput, ProductLineUncheckedUpdateWithoutEquipmentInput>
    create: XOR<ProductLineCreateWithoutEquipmentInput, ProductLineUncheckedCreateWithoutEquipmentInput>
  }

  export type ProductLineUpdateWithoutEquipmentInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type ProductLineUncheckedUpdateWithoutEquipmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type RepairMaterialInventoryUpsertWithWhereUniqueWithoutEquipmentInput = {
    where: RepairMaterialInventoryWhereUniqueInput
    update: XOR<RepairMaterialInventoryUpdateWithoutEquipmentInput, RepairMaterialInventoryUncheckedUpdateWithoutEquipmentInput>
    create: XOR<RepairMaterialInventoryCreateWithoutEquipmentInput, RepairMaterialInventoryUncheckedCreateWithoutEquipmentInput>
  }

  export type RepairMaterialInventoryUpdateWithWhereUniqueWithoutEquipmentInput = {
    where: RepairMaterialInventoryWhereUniqueInput
    data: XOR<RepairMaterialInventoryUpdateWithoutEquipmentInput, RepairMaterialInventoryUncheckedUpdateWithoutEquipmentInput>
  }

  export type RepairMaterialInventoryUpdateManyWithWhereWithoutEquipmentInput = {
    where: RepairMaterialInventoryScalarWhereInput
    data: XOR<RepairMaterialInventoryUpdateManyMutationInput, RepairMaterialInventoryUncheckedUpdateManyWithoutRepairMaterialInventoriesInput>
  }

  export type RepairMaterialInventoryScalarWhereInput = {
    AND?: Enumerable<RepairMaterialInventoryScalarWhereInput>
    OR?: Enumerable<RepairMaterialInventoryScalarWhereInput>
    NOT?: Enumerable<RepairMaterialInventoryScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    name?: StringFilter | string
    description?: StringFilter | string
    quantity?: IntFilter | number
    minimumQuantity?: IntFilter | number
    equipmentId?: IntFilter | number
  }

  export type RepairRecordUpsertWithWhereUniqueWithoutEquipmentInput = {
    where: RepairRecordWhereUniqueInput
    update: XOR<RepairRecordUpdateWithoutEquipmentInput, RepairRecordUncheckedUpdateWithoutEquipmentInput>
    create: XOR<RepairRecordCreateWithoutEquipmentInput, RepairRecordUncheckedCreateWithoutEquipmentInput>
  }

  export type RepairRecordUpdateWithWhereUniqueWithoutEquipmentInput = {
    where: RepairRecordWhereUniqueInput
    data: XOR<RepairRecordUpdateWithoutEquipmentInput, RepairRecordUncheckedUpdateWithoutEquipmentInput>
  }

  export type RepairRecordUpdateManyWithWhereWithoutEquipmentInput = {
    where: RepairRecordScalarWhereInput
    data: XOR<RepairRecordUpdateManyMutationInput, RepairRecordUncheckedUpdateManyWithoutRepairRecordsInput>
  }

  export type RepairRecordScalarWhereInput = {
    AND?: Enumerable<RepairRecordScalarWhereInput>
    OR?: Enumerable<RepairRecordScalarWhereInput>
    NOT?: Enumerable<RepairRecordScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    type?: EnumRepairTypeFilter | RepairType
    equipmentId?: IntFilter | number
    status?: EnumRepairRecordStatusFilter | RepairRecordStatus
    description?: StringFilter | string
  }

  export type EquipmentCreateWithoutRepairMaterialInventoriesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    description: string
    repairPlan: string
    workStation: string
    productLine: ProductLineCreateNestedOneWithoutEquipmentInput
    repairRecords?: RepairRecordCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentUncheckedCreateWithoutRepairMaterialInventoriesInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    description: string
    repairPlan: string
    workStation: string
    productLineId: number
    repairRecords?: RepairRecordUncheckedCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentCreateOrConnectWithoutRepairMaterialInventoriesInput = {
    where: EquipmentWhereUniqueInput
    create: XOR<EquipmentCreateWithoutRepairMaterialInventoriesInput, EquipmentUncheckedCreateWithoutRepairMaterialInventoriesInput>
  }

  export type EquipmentUpsertWithoutRepairMaterialInventoriesInput = {
    update: XOR<EquipmentUpdateWithoutRepairMaterialInventoriesInput, EquipmentUncheckedUpdateWithoutRepairMaterialInventoriesInput>
    create: XOR<EquipmentCreateWithoutRepairMaterialInventoriesInput, EquipmentUncheckedCreateWithoutRepairMaterialInventoriesInput>
  }

  export type EquipmentUpdateWithoutRepairMaterialInventoriesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    repairPlan?: StringFieldUpdateOperationsInput | string
    workStation?: StringFieldUpdateOperationsInput | string
    productLine?: ProductLineUpdateOneRequiredWithoutEquipmentNestedInput
    repairRecords?: RepairRecordUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentUncheckedUpdateWithoutRepairMaterialInventoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    repairPlan?: StringFieldUpdateOperationsInput | string
    workStation?: StringFieldUpdateOperationsInput | string
    productLineId?: IntFieldUpdateOperationsInput | number
    repairRecords?: RepairRecordUncheckedUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentCreateWithoutRepairRecordsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    description: string
    repairPlan: string
    workStation: string
    productLine: ProductLineCreateNestedOneWithoutEquipmentInput
    repairMaterialInventories?: RepairMaterialInventoryCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentUncheckedCreateWithoutRepairRecordsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    description: string
    repairPlan: string
    workStation: string
    productLineId: number
    repairMaterialInventories?: RepairMaterialInventoryUncheckedCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentCreateOrConnectWithoutRepairRecordsInput = {
    where: EquipmentWhereUniqueInput
    create: XOR<EquipmentCreateWithoutRepairRecordsInput, EquipmentUncheckedCreateWithoutRepairRecordsInput>
  }

  export type EquipmentUpsertWithoutRepairRecordsInput = {
    update: XOR<EquipmentUpdateWithoutRepairRecordsInput, EquipmentUncheckedUpdateWithoutRepairRecordsInput>
    create: XOR<EquipmentCreateWithoutRepairRecordsInput, EquipmentUncheckedCreateWithoutRepairRecordsInput>
  }

  export type EquipmentUpdateWithoutRepairRecordsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    repairPlan?: StringFieldUpdateOperationsInput | string
    workStation?: StringFieldUpdateOperationsInput | string
    productLine?: ProductLineUpdateOneRequiredWithoutEquipmentNestedInput
    repairMaterialInventories?: RepairMaterialInventoryUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentUncheckedUpdateWithoutRepairRecordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    repairPlan?: StringFieldUpdateOperationsInput | string
    workStation?: StringFieldUpdateOperationsInput | string
    productLineId?: IntFieldUpdateOperationsInput | number
    repairMaterialInventories?: RepairMaterialInventoryUncheckedUpdateManyWithoutEquipmentNestedInput
  }

  export type PartVersionCreateWithoutPartInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    version: string
    note?: string | null
    incomingInspectionSpec?: IncomingInspectionSpecCreateNestedOneWithoutPartVersionInput
    receipts?: ReceiptCreateNestedManyWithoutPartVersionInput
  }

  export type PartVersionUncheckedCreateWithoutPartInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    version: string
    note?: string | null
    incomingInspectionSpec?: IncomingInspectionSpecUncheckedCreateNestedOneWithoutPartVersionInput
    receipts?: ReceiptUncheckedCreateNestedManyWithoutPartVersionInput
  }

  export type PartVersionCreateOrConnectWithoutPartInput = {
    where: PartVersionWhereUniqueInput
    create: XOR<PartVersionCreateWithoutPartInput, PartVersionUncheckedCreateWithoutPartInput>
  }

  export type PartVersionCreateManyPartInputEnvelope = {
    data: Enumerable<PartVersionCreateManyPartInput>
    skipDuplicates?: boolean
  }

  export type PartOperationCreateWithoutPartInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    version: string
    no: string
    name: string
    partOperationInspectionItems?: PartOperationInspectionItemCreateNestedManyWithoutPartOperationInput
  }

  export type PartOperationUncheckedCreateWithoutPartInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    version: string
    no: string
    name: string
    partOperationInspectionItems?: PartOperationInspectionItemUncheckedCreateNestedManyWithoutPartOperationInput
  }

  export type PartOperationCreateOrConnectWithoutPartInput = {
    where: PartOperationWhereUniqueInput
    create: XOR<PartOperationCreateWithoutPartInput, PartOperationUncheckedCreateWithoutPartInput>
  }

  export type PartOperationCreateManyPartInputEnvelope = {
    data: Enumerable<PartOperationCreateManyPartInput>
    skipDuplicates?: boolean
  }

  export type WorkerOrderCreateWithoutPartInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    no: string
    operationInspectionRecords?: OperationInspectionRecordCreateNestedManyWithoutWorkerOrderInput
  }

  export type WorkerOrderUncheckedCreateWithoutPartInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    no: string
    operationInspectionRecords?: OperationInspectionRecordUncheckedCreateNestedManyWithoutWorkerOrderInput
  }

  export type WorkerOrderCreateOrConnectWithoutPartInput = {
    where: WorkerOrderWhereUniqueInput
    create: XOR<WorkerOrderCreateWithoutPartInput, WorkerOrderUncheckedCreateWithoutPartInput>
  }

  export type WorkerOrderCreateManyPartInputEnvelope = {
    data: Enumerable<WorkerOrderCreateManyPartInput>
    skipDuplicates?: boolean
  }

  export type NonconformItemCreateWithoutPartInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    description: string
    note?: string | null
  }

  export type NonconformItemUncheckedCreateWithoutPartInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    description: string
    note?: string | null
  }

  export type NonconformItemCreateOrConnectWithoutPartInput = {
    where: NonconformItemWhereUniqueInput
    create: XOR<NonconformItemCreateWithoutPartInput, NonconformItemUncheckedCreateWithoutPartInput>
  }

  export type NonconformItemCreateManyPartInputEnvelope = {
    data: Enumerable<NonconformItemCreateManyPartInput>
    skipDuplicates?: boolean
  }

  export type PartVersionUpsertWithWhereUniqueWithoutPartInput = {
    where: PartVersionWhereUniqueInput
    update: XOR<PartVersionUpdateWithoutPartInput, PartVersionUncheckedUpdateWithoutPartInput>
    create: XOR<PartVersionCreateWithoutPartInput, PartVersionUncheckedCreateWithoutPartInput>
  }

  export type PartVersionUpdateWithWhereUniqueWithoutPartInput = {
    where: PartVersionWhereUniqueInput
    data: XOR<PartVersionUpdateWithoutPartInput, PartVersionUncheckedUpdateWithoutPartInput>
  }

  export type PartVersionUpdateManyWithWhereWithoutPartInput = {
    where: PartVersionScalarWhereInput
    data: XOR<PartVersionUpdateManyMutationInput, PartVersionUncheckedUpdateManyWithoutPartVersionsInput>
  }

  export type PartVersionScalarWhereInput = {
    AND?: Enumerable<PartVersionScalarWhereInput>
    OR?: Enumerable<PartVersionScalarWhereInput>
    NOT?: Enumerable<PartVersionScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    version?: StringFilter | string
    note?: StringNullableFilter | string | null
    partId?: IntFilter | number
  }

  export type PartOperationUpsertWithWhereUniqueWithoutPartInput = {
    where: PartOperationWhereUniqueInput
    update: XOR<PartOperationUpdateWithoutPartInput, PartOperationUncheckedUpdateWithoutPartInput>
    create: XOR<PartOperationCreateWithoutPartInput, PartOperationUncheckedCreateWithoutPartInput>
  }

  export type PartOperationUpdateWithWhereUniqueWithoutPartInput = {
    where: PartOperationWhereUniqueInput
    data: XOR<PartOperationUpdateWithoutPartInput, PartOperationUncheckedUpdateWithoutPartInput>
  }

  export type PartOperationUpdateManyWithWhereWithoutPartInput = {
    where: PartOperationScalarWhereInput
    data: XOR<PartOperationUpdateManyMutationInput, PartOperationUncheckedUpdateManyWithoutPartOperationInput>
  }

  export type PartOperationScalarWhereInput = {
    AND?: Enumerable<PartOperationScalarWhereInput>
    OR?: Enumerable<PartOperationScalarWhereInput>
    NOT?: Enumerable<PartOperationScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    version?: StringFilter | string
    no?: StringFilter | string
    name?: StringFilter | string
    partId?: IntFilter | number
  }

  export type WorkerOrderUpsertWithWhereUniqueWithoutPartInput = {
    where: WorkerOrderWhereUniqueInput
    update: XOR<WorkerOrderUpdateWithoutPartInput, WorkerOrderUncheckedUpdateWithoutPartInput>
    create: XOR<WorkerOrderCreateWithoutPartInput, WorkerOrderUncheckedCreateWithoutPartInput>
  }

  export type WorkerOrderUpdateWithWhereUniqueWithoutPartInput = {
    where: WorkerOrderWhereUniqueInput
    data: XOR<WorkerOrderUpdateWithoutPartInput, WorkerOrderUncheckedUpdateWithoutPartInput>
  }

  export type WorkerOrderUpdateManyWithWhereWithoutPartInput = {
    where: WorkerOrderScalarWhereInput
    data: XOR<WorkerOrderUpdateManyMutationInput, WorkerOrderUncheckedUpdateManyWithoutWorkerOrdersInput>
  }

  export type WorkerOrderScalarWhereInput = {
    AND?: Enumerable<WorkerOrderScalarWhereInput>
    OR?: Enumerable<WorkerOrderScalarWhereInput>
    NOT?: Enumerable<WorkerOrderScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    no?: StringFilter | string
    partId?: IntFilter | number
  }

  export type NonconformItemUpsertWithWhereUniqueWithoutPartInput = {
    where: NonconformItemWhereUniqueInput
    update: XOR<NonconformItemUpdateWithoutPartInput, NonconformItemUncheckedUpdateWithoutPartInput>
    create: XOR<NonconformItemCreateWithoutPartInput, NonconformItemUncheckedCreateWithoutPartInput>
  }

  export type NonconformItemUpdateWithWhereUniqueWithoutPartInput = {
    where: NonconformItemWhereUniqueInput
    data: XOR<NonconformItemUpdateWithoutPartInput, NonconformItemUncheckedUpdateWithoutPartInput>
  }

  export type NonconformItemUpdateManyWithWhereWithoutPartInput = {
    where: NonconformItemScalarWhereInput
    data: XOR<NonconformItemUpdateManyMutationInput, NonconformItemUncheckedUpdateManyWithoutNonconformItemsInput>
  }

  export type NonconformItemScalarWhereInput = {
    AND?: Enumerable<NonconformItemScalarWhereInput>
    OR?: Enumerable<NonconformItemScalarWhereInput>
    NOT?: Enumerable<NonconformItemScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    partId?: IntFilter | number
    description?: StringFilter | string
    note?: StringNullableFilter | string | null
  }

  export type PartCreateWithoutPartVersionsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    no: string
    name: string
    partOperation?: PartOperationCreateNestedManyWithoutPartInput
    workerOrders?: WorkerOrderCreateNestedManyWithoutPartInput
    nonconformItems?: NonconformItemCreateNestedManyWithoutPartInput
  }

  export type PartUncheckedCreateWithoutPartVersionsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    no: string
    name: string
    partOperation?: PartOperationUncheckedCreateNestedManyWithoutPartInput
    workerOrders?: WorkerOrderUncheckedCreateNestedManyWithoutPartInput
    nonconformItems?: NonconformItemUncheckedCreateNestedManyWithoutPartInput
  }

  export type PartCreateOrConnectWithoutPartVersionsInput = {
    where: PartWhereUniqueInput
    create: XOR<PartCreateWithoutPartVersionsInput, PartUncheckedCreateWithoutPartVersionsInput>
  }

  export type IncomingInspectionSpecCreateWithoutPartVersionInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    version: string
    attachment: string
    incomingInspectionSpecItems?: IncomingInspectionSpecItemCreateNestedManyWithoutIncomingInspectionSpecInput
    incomingInspectionRecords?: IncomingInspectionRecordCreateNestedManyWithoutIncomingInspectionSpecInput
  }

  export type IncomingInspectionSpecUncheckedCreateWithoutPartVersionInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    version: string
    attachment: string
    incomingInspectionSpecItems?: IncomingInspectionSpecItemUncheckedCreateNestedManyWithoutIncomingInspectionSpecInput
    incomingInspectionRecords?: IncomingInspectionRecordUncheckedCreateNestedManyWithoutIncomingInspectionSpecInput
  }

  export type IncomingInspectionSpecCreateOrConnectWithoutPartVersionInput = {
    where: IncomingInspectionSpecWhereUniqueInput
    create: XOR<IncomingInspectionSpecCreateWithoutPartVersionInput, IncomingInspectionSpecUncheckedCreateWithoutPartVersionInput>
  }

  export type ReceiptCreateWithoutPartVersionInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    lot: string
    incomingInspectionRecord?: IncomingInspectionRecordCreateNestedOneWithoutReceiptInput
  }

  export type ReceiptUncheckedCreateWithoutPartVersionInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    lot: string
    incomingInspectionRecord?: IncomingInspectionRecordUncheckedCreateNestedOneWithoutReceiptInput
  }

  export type ReceiptCreateOrConnectWithoutPartVersionInput = {
    where: ReceiptWhereUniqueInput
    create: XOR<ReceiptCreateWithoutPartVersionInput, ReceiptUncheckedCreateWithoutPartVersionInput>
  }

  export type ReceiptCreateManyPartVersionInputEnvelope = {
    data: Enumerable<ReceiptCreateManyPartVersionInput>
    skipDuplicates?: boolean
  }

  export type PartUpsertWithoutPartVersionsInput = {
    update: XOR<PartUpdateWithoutPartVersionsInput, PartUncheckedUpdateWithoutPartVersionsInput>
    create: XOR<PartCreateWithoutPartVersionsInput, PartUncheckedCreateWithoutPartVersionsInput>
  }

  export type PartUpdateWithoutPartVersionsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    no?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    partOperation?: PartOperationUpdateManyWithoutPartNestedInput
    workerOrders?: WorkerOrderUpdateManyWithoutPartNestedInput
    nonconformItems?: NonconformItemUpdateManyWithoutPartNestedInput
  }

  export type PartUncheckedUpdateWithoutPartVersionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    no?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    partOperation?: PartOperationUncheckedUpdateManyWithoutPartNestedInput
    workerOrders?: WorkerOrderUncheckedUpdateManyWithoutPartNestedInput
    nonconformItems?: NonconformItemUncheckedUpdateManyWithoutPartNestedInput
  }

  export type IncomingInspectionSpecUpsertWithoutPartVersionInput = {
    update: XOR<IncomingInspectionSpecUpdateWithoutPartVersionInput, IncomingInspectionSpecUncheckedUpdateWithoutPartVersionInput>
    create: XOR<IncomingInspectionSpecCreateWithoutPartVersionInput, IncomingInspectionSpecUncheckedCreateWithoutPartVersionInput>
  }

  export type IncomingInspectionSpecUpdateWithoutPartVersionInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    version?: StringFieldUpdateOperationsInput | string
    attachment?: StringFieldUpdateOperationsInput | string
    incomingInspectionSpecItems?: IncomingInspectionSpecItemUpdateManyWithoutIncomingInspectionSpecNestedInput
    incomingInspectionRecords?: IncomingInspectionRecordUpdateManyWithoutIncomingInspectionSpecNestedInput
  }

  export type IncomingInspectionSpecUncheckedUpdateWithoutPartVersionInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    version?: StringFieldUpdateOperationsInput | string
    attachment?: StringFieldUpdateOperationsInput | string
    incomingInspectionSpecItems?: IncomingInspectionSpecItemUncheckedUpdateManyWithoutIncomingInspectionSpecNestedInput
    incomingInspectionRecords?: IncomingInspectionRecordUncheckedUpdateManyWithoutIncomingInspectionSpecNestedInput
  }

  export type ReceiptUpsertWithWhereUniqueWithoutPartVersionInput = {
    where: ReceiptWhereUniqueInput
    update: XOR<ReceiptUpdateWithoutPartVersionInput, ReceiptUncheckedUpdateWithoutPartVersionInput>
    create: XOR<ReceiptCreateWithoutPartVersionInput, ReceiptUncheckedCreateWithoutPartVersionInput>
  }

  export type ReceiptUpdateWithWhereUniqueWithoutPartVersionInput = {
    where: ReceiptWhereUniqueInput
    data: XOR<ReceiptUpdateWithoutPartVersionInput, ReceiptUncheckedUpdateWithoutPartVersionInput>
  }

  export type ReceiptUpdateManyWithWhereWithoutPartVersionInput = {
    where: ReceiptScalarWhereInput
    data: XOR<ReceiptUpdateManyMutationInput, ReceiptUncheckedUpdateManyWithoutReceiptsInput>
  }

  export type ReceiptScalarWhereInput = {
    AND?: Enumerable<ReceiptScalarWhereInput>
    OR?: Enumerable<ReceiptScalarWhereInput>
    NOT?: Enumerable<ReceiptScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    lot?: StringFilter | string
    partVersionId?: IntFilter | number
  }

  export type IncomingInspectionSpecItemCreateWithoutIncomingInspectionSpecInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    no: number
    name: string
    spec: string
    incomingInspectionRecordItem?: IncomingInspectionRecordItemCreateNestedManyWithoutIncomingInspectionSpecItemInput
  }

  export type IncomingInspectionSpecItemUncheckedCreateWithoutIncomingInspectionSpecInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    no: number
    name: string
    spec: string
    incomingInspectionRecordItem?: IncomingInspectionRecordItemUncheckedCreateNestedManyWithoutIncomingInspectionSpecItemInput
  }

  export type IncomingInspectionSpecItemCreateOrConnectWithoutIncomingInspectionSpecInput = {
    where: IncomingInspectionSpecItemWhereUniqueInput
    create: XOR<IncomingInspectionSpecItemCreateWithoutIncomingInspectionSpecInput, IncomingInspectionSpecItemUncheckedCreateWithoutIncomingInspectionSpecInput>
  }

  export type IncomingInspectionSpecItemCreateManyIncomingInspectionSpecInputEnvelope = {
    data: Enumerable<IncomingInspectionSpecItemCreateManyIncomingInspectionSpecInput>
    skipDuplicates?: boolean
  }

  export type IncomingInspectionRecordCreateWithoutIncomingInspectionSpecInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    note: string
    result: IncomingInspectionResult
    receipt: ReceiptCreateNestedOneWithoutIncomingInspectionRecordInput
    incomingInspectionRecordItems?: IncomingInspectionRecordItemCreateNestedManyWithoutIncomingInspectionRecordInput
  }

  export type IncomingInspectionRecordUncheckedCreateWithoutIncomingInspectionSpecInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    note: string
    result: IncomingInspectionResult
    receiptId: number
    incomingInspectionRecordItems?: IncomingInspectionRecordItemUncheckedCreateNestedManyWithoutIncomingInspectionRecordInput
  }

  export type IncomingInspectionRecordCreateOrConnectWithoutIncomingInspectionSpecInput = {
    where: IncomingInspectionRecordWhereUniqueInput
    create: XOR<IncomingInspectionRecordCreateWithoutIncomingInspectionSpecInput, IncomingInspectionRecordUncheckedCreateWithoutIncomingInspectionSpecInput>
  }

  export type IncomingInspectionRecordCreateManyIncomingInspectionSpecInputEnvelope = {
    data: Enumerable<IncomingInspectionRecordCreateManyIncomingInspectionSpecInput>
    skipDuplicates?: boolean
  }

  export type PartVersionCreateWithoutIncomingInspectionSpecInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    version: string
    note?: string | null
    part: PartCreateNestedOneWithoutPartVersionsInput
    receipts?: ReceiptCreateNestedManyWithoutPartVersionInput
  }

  export type PartVersionUncheckedCreateWithoutIncomingInspectionSpecInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    version: string
    note?: string | null
    partId: number
    receipts?: ReceiptUncheckedCreateNestedManyWithoutPartVersionInput
  }

  export type PartVersionCreateOrConnectWithoutIncomingInspectionSpecInput = {
    where: PartVersionWhereUniqueInput
    create: XOR<PartVersionCreateWithoutIncomingInspectionSpecInput, PartVersionUncheckedCreateWithoutIncomingInspectionSpecInput>
  }

  export type IncomingInspectionSpecItemUpsertWithWhereUniqueWithoutIncomingInspectionSpecInput = {
    where: IncomingInspectionSpecItemWhereUniqueInput
    update: XOR<IncomingInspectionSpecItemUpdateWithoutIncomingInspectionSpecInput, IncomingInspectionSpecItemUncheckedUpdateWithoutIncomingInspectionSpecInput>
    create: XOR<IncomingInspectionSpecItemCreateWithoutIncomingInspectionSpecInput, IncomingInspectionSpecItemUncheckedCreateWithoutIncomingInspectionSpecInput>
  }

  export type IncomingInspectionSpecItemUpdateWithWhereUniqueWithoutIncomingInspectionSpecInput = {
    where: IncomingInspectionSpecItemWhereUniqueInput
    data: XOR<IncomingInspectionSpecItemUpdateWithoutIncomingInspectionSpecInput, IncomingInspectionSpecItemUncheckedUpdateWithoutIncomingInspectionSpecInput>
  }

  export type IncomingInspectionSpecItemUpdateManyWithWhereWithoutIncomingInspectionSpecInput = {
    where: IncomingInspectionSpecItemScalarWhereInput
    data: XOR<IncomingInspectionSpecItemUpdateManyMutationInput, IncomingInspectionSpecItemUncheckedUpdateManyWithoutIncomingInspectionSpecItemsInput>
  }

  export type IncomingInspectionSpecItemScalarWhereInput = {
    AND?: Enumerable<IncomingInspectionSpecItemScalarWhereInput>
    OR?: Enumerable<IncomingInspectionSpecItemScalarWhereInput>
    NOT?: Enumerable<IncomingInspectionSpecItemScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    no?: IntFilter | number
    name?: StringFilter | string
    spec?: StringFilter | string
    incomingInspectionSpecId?: IntFilter | number
  }

  export type IncomingInspectionRecordUpsertWithWhereUniqueWithoutIncomingInspectionSpecInput = {
    where: IncomingInspectionRecordWhereUniqueInput
    update: XOR<IncomingInspectionRecordUpdateWithoutIncomingInspectionSpecInput, IncomingInspectionRecordUncheckedUpdateWithoutIncomingInspectionSpecInput>
    create: XOR<IncomingInspectionRecordCreateWithoutIncomingInspectionSpecInput, IncomingInspectionRecordUncheckedCreateWithoutIncomingInspectionSpecInput>
  }

  export type IncomingInspectionRecordUpdateWithWhereUniqueWithoutIncomingInspectionSpecInput = {
    where: IncomingInspectionRecordWhereUniqueInput
    data: XOR<IncomingInspectionRecordUpdateWithoutIncomingInspectionSpecInput, IncomingInspectionRecordUncheckedUpdateWithoutIncomingInspectionSpecInput>
  }

  export type IncomingInspectionRecordUpdateManyWithWhereWithoutIncomingInspectionSpecInput = {
    where: IncomingInspectionRecordScalarWhereInput
    data: XOR<IncomingInspectionRecordUpdateManyMutationInput, IncomingInspectionRecordUncheckedUpdateManyWithoutIncomingInspectionRecordsInput>
  }

  export type IncomingInspectionRecordScalarWhereInput = {
    AND?: Enumerable<IncomingInspectionRecordScalarWhereInput>
    OR?: Enumerable<IncomingInspectionRecordScalarWhereInput>
    NOT?: Enumerable<IncomingInspectionRecordScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    note?: StringFilter | string
    result?: EnumIncomingInspectionResultFilter | IncomingInspectionResult
    receiptId?: IntFilter | number
    incomingInspectionSpecId?: IntFilter | number
  }

  export type PartVersionUpsertWithoutIncomingInspectionSpecInput = {
    update: XOR<PartVersionUpdateWithoutIncomingInspectionSpecInput, PartVersionUncheckedUpdateWithoutIncomingInspectionSpecInput>
    create: XOR<PartVersionCreateWithoutIncomingInspectionSpecInput, PartVersionUncheckedCreateWithoutIncomingInspectionSpecInput>
  }

  export type PartVersionUpdateWithoutIncomingInspectionSpecInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    version?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    part?: PartUpdateOneRequiredWithoutPartVersionsNestedInput
    receipts?: ReceiptUpdateManyWithoutPartVersionNestedInput
  }

  export type PartVersionUncheckedUpdateWithoutIncomingInspectionSpecInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    version?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    partId?: IntFieldUpdateOperationsInput | number
    receipts?: ReceiptUncheckedUpdateManyWithoutPartVersionNestedInput
  }

  export type IncomingInspectionSpecCreateWithoutIncomingInspectionSpecItemsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    version: string
    attachment: string
    incomingInspectionRecords?: IncomingInspectionRecordCreateNestedManyWithoutIncomingInspectionSpecInput
    partVersion: PartVersionCreateNestedOneWithoutIncomingInspectionSpecInput
  }

  export type IncomingInspectionSpecUncheckedCreateWithoutIncomingInspectionSpecItemsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    version: string
    attachment: string
    partVersionId: number
    incomingInspectionRecords?: IncomingInspectionRecordUncheckedCreateNestedManyWithoutIncomingInspectionSpecInput
  }

  export type IncomingInspectionSpecCreateOrConnectWithoutIncomingInspectionSpecItemsInput = {
    where: IncomingInspectionSpecWhereUniqueInput
    create: XOR<IncomingInspectionSpecCreateWithoutIncomingInspectionSpecItemsInput, IncomingInspectionSpecUncheckedCreateWithoutIncomingInspectionSpecItemsInput>
  }

  export type IncomingInspectionRecordItemCreateWithoutIncomingInspectionSpecItemInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    result: boolean
    inspectionIteration: string
    incomingInspectionRecord: IncomingInspectionRecordCreateNestedOneWithoutIncomingInspectionRecordItemsInput
  }

  export type IncomingInspectionRecordItemUncheckedCreateWithoutIncomingInspectionSpecItemInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    result: boolean
    inspectionIteration: string
    incomingInspectionRecordId: number
  }

  export type IncomingInspectionRecordItemCreateOrConnectWithoutIncomingInspectionSpecItemInput = {
    where: IncomingInspectionRecordItemWhereUniqueInput
    create: XOR<IncomingInspectionRecordItemCreateWithoutIncomingInspectionSpecItemInput, IncomingInspectionRecordItemUncheckedCreateWithoutIncomingInspectionSpecItemInput>
  }

  export type IncomingInspectionRecordItemCreateManyIncomingInspectionSpecItemInputEnvelope = {
    data: Enumerable<IncomingInspectionRecordItemCreateManyIncomingInspectionSpecItemInput>
    skipDuplicates?: boolean
  }

  export type IncomingInspectionSpecUpsertWithoutIncomingInspectionSpecItemsInput = {
    update: XOR<IncomingInspectionSpecUpdateWithoutIncomingInspectionSpecItemsInput, IncomingInspectionSpecUncheckedUpdateWithoutIncomingInspectionSpecItemsInput>
    create: XOR<IncomingInspectionSpecCreateWithoutIncomingInspectionSpecItemsInput, IncomingInspectionSpecUncheckedCreateWithoutIncomingInspectionSpecItemsInput>
  }

  export type IncomingInspectionSpecUpdateWithoutIncomingInspectionSpecItemsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    version?: StringFieldUpdateOperationsInput | string
    attachment?: StringFieldUpdateOperationsInput | string
    incomingInspectionRecords?: IncomingInspectionRecordUpdateManyWithoutIncomingInspectionSpecNestedInput
    partVersion?: PartVersionUpdateOneRequiredWithoutIncomingInspectionSpecNestedInput
  }

  export type IncomingInspectionSpecUncheckedUpdateWithoutIncomingInspectionSpecItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    version?: StringFieldUpdateOperationsInput | string
    attachment?: StringFieldUpdateOperationsInput | string
    partVersionId?: IntFieldUpdateOperationsInput | number
    incomingInspectionRecords?: IncomingInspectionRecordUncheckedUpdateManyWithoutIncomingInspectionSpecNestedInput
  }

  export type IncomingInspectionRecordItemUpsertWithWhereUniqueWithoutIncomingInspectionSpecItemInput = {
    where: IncomingInspectionRecordItemWhereUniqueInput
    update: XOR<IncomingInspectionRecordItemUpdateWithoutIncomingInspectionSpecItemInput, IncomingInspectionRecordItemUncheckedUpdateWithoutIncomingInspectionSpecItemInput>
    create: XOR<IncomingInspectionRecordItemCreateWithoutIncomingInspectionSpecItemInput, IncomingInspectionRecordItemUncheckedCreateWithoutIncomingInspectionSpecItemInput>
  }

  export type IncomingInspectionRecordItemUpdateWithWhereUniqueWithoutIncomingInspectionSpecItemInput = {
    where: IncomingInspectionRecordItemWhereUniqueInput
    data: XOR<IncomingInspectionRecordItemUpdateWithoutIncomingInspectionSpecItemInput, IncomingInspectionRecordItemUncheckedUpdateWithoutIncomingInspectionSpecItemInput>
  }

  export type IncomingInspectionRecordItemUpdateManyWithWhereWithoutIncomingInspectionSpecItemInput = {
    where: IncomingInspectionRecordItemScalarWhereInput
    data: XOR<IncomingInspectionRecordItemUpdateManyMutationInput, IncomingInspectionRecordItemUncheckedUpdateManyWithoutIncomingInspectionRecordItemInput>
  }

  export type IncomingInspectionRecordItemScalarWhereInput = {
    AND?: Enumerable<IncomingInspectionRecordItemScalarWhereInput>
    OR?: Enumerable<IncomingInspectionRecordItemScalarWhereInput>
    NOT?: Enumerable<IncomingInspectionRecordItemScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    result?: BoolFilter | boolean
    inspectionIteration?: StringFilter | string
    incomingInspectionRecordId?: IntFilter | number
    incomingInspectionSpecItemId?: IntFilter | number
  }

  export type PartCreateWithoutNonconformItemsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    no: string
    name: string
    partVersions?: PartVersionCreateNestedManyWithoutPartInput
    partOperation?: PartOperationCreateNestedManyWithoutPartInput
    workerOrders?: WorkerOrderCreateNestedManyWithoutPartInput
  }

  export type PartUncheckedCreateWithoutNonconformItemsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    no: string
    name: string
    partVersions?: PartVersionUncheckedCreateNestedManyWithoutPartInput
    partOperation?: PartOperationUncheckedCreateNestedManyWithoutPartInput
    workerOrders?: WorkerOrderUncheckedCreateNestedManyWithoutPartInput
  }

  export type PartCreateOrConnectWithoutNonconformItemsInput = {
    where: PartWhereUniqueInput
    create: XOR<PartCreateWithoutNonconformItemsInput, PartUncheckedCreateWithoutNonconformItemsInput>
  }

  export type PartUpsertWithoutNonconformItemsInput = {
    update: XOR<PartUpdateWithoutNonconformItemsInput, PartUncheckedUpdateWithoutNonconformItemsInput>
    create: XOR<PartCreateWithoutNonconformItemsInput, PartUncheckedCreateWithoutNonconformItemsInput>
  }

  export type PartUpdateWithoutNonconformItemsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    no?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    partVersions?: PartVersionUpdateManyWithoutPartNestedInput
    partOperation?: PartOperationUpdateManyWithoutPartNestedInput
    workerOrders?: WorkerOrderUpdateManyWithoutPartNestedInput
  }

  export type PartUncheckedUpdateWithoutNonconformItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    no?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    partVersions?: PartVersionUncheckedUpdateManyWithoutPartNestedInput
    partOperation?: PartOperationUncheckedUpdateManyWithoutPartNestedInput
    workerOrders?: WorkerOrderUncheckedUpdateManyWithoutPartNestedInput
  }

  export type PartCreateWithoutPartOperationInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    no: string
    name: string
    partVersions?: PartVersionCreateNestedManyWithoutPartInput
    workerOrders?: WorkerOrderCreateNestedManyWithoutPartInput
    nonconformItems?: NonconformItemCreateNestedManyWithoutPartInput
  }

  export type PartUncheckedCreateWithoutPartOperationInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    no: string
    name: string
    partVersions?: PartVersionUncheckedCreateNestedManyWithoutPartInput
    workerOrders?: WorkerOrderUncheckedCreateNestedManyWithoutPartInput
    nonconformItems?: NonconformItemUncheckedCreateNestedManyWithoutPartInput
  }

  export type PartCreateOrConnectWithoutPartOperationInput = {
    where: PartWhereUniqueInput
    create: XOR<PartCreateWithoutPartOperationInput, PartUncheckedCreateWithoutPartOperationInput>
  }

  export type PartOperationInspectionItemCreateWithoutPartOperationInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    operationInspectionRecordItems?: OperationInspectionRecordItemCreateNestedManyWithoutPartOperationInspectionItemInput
  }

  export type PartOperationInspectionItemUncheckedCreateWithoutPartOperationInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    operationInspectionRecordItems?: OperationInspectionRecordItemUncheckedCreateNestedManyWithoutPartOperationInspectionItemInput
  }

  export type PartOperationInspectionItemCreateOrConnectWithoutPartOperationInput = {
    where: PartOperationInspectionItemWhereUniqueInput
    create: XOR<PartOperationInspectionItemCreateWithoutPartOperationInput, PartOperationInspectionItemUncheckedCreateWithoutPartOperationInput>
  }

  export type PartOperationInspectionItemCreateManyPartOperationInputEnvelope = {
    data: Enumerable<PartOperationInspectionItemCreateManyPartOperationInput>
    skipDuplicates?: boolean
  }

  export type PartUpsertWithoutPartOperationInput = {
    update: XOR<PartUpdateWithoutPartOperationInput, PartUncheckedUpdateWithoutPartOperationInput>
    create: XOR<PartCreateWithoutPartOperationInput, PartUncheckedCreateWithoutPartOperationInput>
  }

  export type PartUpdateWithoutPartOperationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    no?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    partVersions?: PartVersionUpdateManyWithoutPartNestedInput
    workerOrders?: WorkerOrderUpdateManyWithoutPartNestedInput
    nonconformItems?: NonconformItemUpdateManyWithoutPartNestedInput
  }

  export type PartUncheckedUpdateWithoutPartOperationInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    no?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    partVersions?: PartVersionUncheckedUpdateManyWithoutPartNestedInput
    workerOrders?: WorkerOrderUncheckedUpdateManyWithoutPartNestedInput
    nonconformItems?: NonconformItemUncheckedUpdateManyWithoutPartNestedInput
  }

  export type PartOperationInspectionItemUpsertWithWhereUniqueWithoutPartOperationInput = {
    where: PartOperationInspectionItemWhereUniqueInput
    update: XOR<PartOperationInspectionItemUpdateWithoutPartOperationInput, PartOperationInspectionItemUncheckedUpdateWithoutPartOperationInput>
    create: XOR<PartOperationInspectionItemCreateWithoutPartOperationInput, PartOperationInspectionItemUncheckedCreateWithoutPartOperationInput>
  }

  export type PartOperationInspectionItemUpdateWithWhereUniqueWithoutPartOperationInput = {
    where: PartOperationInspectionItemWhereUniqueInput
    data: XOR<PartOperationInspectionItemUpdateWithoutPartOperationInput, PartOperationInspectionItemUncheckedUpdateWithoutPartOperationInput>
  }

  export type PartOperationInspectionItemUpdateManyWithWhereWithoutPartOperationInput = {
    where: PartOperationInspectionItemScalarWhereInput
    data: XOR<PartOperationInspectionItemUpdateManyMutationInput, PartOperationInspectionItemUncheckedUpdateManyWithoutPartOperationInspectionItemsInput>
  }

  export type PartOperationInspectionItemScalarWhereInput = {
    AND?: Enumerable<PartOperationInspectionItemScalarWhereInput>
    OR?: Enumerable<PartOperationInspectionItemScalarWhereInput>
    NOT?: Enumerable<PartOperationInspectionItemScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    name?: StringFilter | string
    partOperationId?: IntFilter | number
  }

  export type PartOperationCreateWithoutPartOperationInspectionItemsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    version: string
    no: string
    name: string
    part: PartCreateNestedOneWithoutPartOperationInput
  }

  export type PartOperationUncheckedCreateWithoutPartOperationInspectionItemsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    version: string
    no: string
    name: string
    partId: number
  }

  export type PartOperationCreateOrConnectWithoutPartOperationInspectionItemsInput = {
    where: PartOperationWhereUniqueInput
    create: XOR<PartOperationCreateWithoutPartOperationInspectionItemsInput, PartOperationUncheckedCreateWithoutPartOperationInspectionItemsInput>
  }

  export type OperationInspectionRecordItemCreateWithoutPartOperationInspectionItemInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    inspectionIteration: string
    operationInspectionRecord: OperationInspectionRecordCreateNestedOneWithoutOperationInspectionRecordItemsInput
  }

  export type OperationInspectionRecordItemUncheckedCreateWithoutPartOperationInspectionItemInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    inspectionIteration: string
    operationInspectionRecordId: number
  }

  export type OperationInspectionRecordItemCreateOrConnectWithoutPartOperationInspectionItemInput = {
    where: OperationInspectionRecordItemWhereUniqueInput
    create: XOR<OperationInspectionRecordItemCreateWithoutPartOperationInspectionItemInput, OperationInspectionRecordItemUncheckedCreateWithoutPartOperationInspectionItemInput>
  }

  export type OperationInspectionRecordItemCreateManyPartOperationInspectionItemInputEnvelope = {
    data: Enumerable<OperationInspectionRecordItemCreateManyPartOperationInspectionItemInput>
    skipDuplicates?: boolean
  }

  export type PartOperationUpsertWithoutPartOperationInspectionItemsInput = {
    update: XOR<PartOperationUpdateWithoutPartOperationInspectionItemsInput, PartOperationUncheckedUpdateWithoutPartOperationInspectionItemsInput>
    create: XOR<PartOperationCreateWithoutPartOperationInspectionItemsInput, PartOperationUncheckedCreateWithoutPartOperationInspectionItemsInput>
  }

  export type PartOperationUpdateWithoutPartOperationInspectionItemsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    version?: StringFieldUpdateOperationsInput | string
    no?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    part?: PartUpdateOneRequiredWithoutPartOperationNestedInput
  }

  export type PartOperationUncheckedUpdateWithoutPartOperationInspectionItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    version?: StringFieldUpdateOperationsInput | string
    no?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    partId?: IntFieldUpdateOperationsInput | number
  }

  export type OperationInspectionRecordItemUpsertWithWhereUniqueWithoutPartOperationInspectionItemInput = {
    where: OperationInspectionRecordItemWhereUniqueInput
    update: XOR<OperationInspectionRecordItemUpdateWithoutPartOperationInspectionItemInput, OperationInspectionRecordItemUncheckedUpdateWithoutPartOperationInspectionItemInput>
    create: XOR<OperationInspectionRecordItemCreateWithoutPartOperationInspectionItemInput, OperationInspectionRecordItemUncheckedCreateWithoutPartOperationInspectionItemInput>
  }

  export type OperationInspectionRecordItemUpdateWithWhereUniqueWithoutPartOperationInspectionItemInput = {
    where: OperationInspectionRecordItemWhereUniqueInput
    data: XOR<OperationInspectionRecordItemUpdateWithoutPartOperationInspectionItemInput, OperationInspectionRecordItemUncheckedUpdateWithoutPartOperationInspectionItemInput>
  }

  export type OperationInspectionRecordItemUpdateManyWithWhereWithoutPartOperationInspectionItemInput = {
    where: OperationInspectionRecordItemScalarWhereInput
    data: XOR<OperationInspectionRecordItemUpdateManyMutationInput, OperationInspectionRecordItemUncheckedUpdateManyWithoutOperationInspectionRecordItemsInput>
  }

  export type OperationInspectionRecordItemScalarWhereInput = {
    AND?: Enumerable<OperationInspectionRecordItemScalarWhereInput>
    OR?: Enumerable<OperationInspectionRecordItemScalarWhereInput>
    NOT?: Enumerable<OperationInspectionRecordItemScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    inspectionIteration?: StringFilter | string
    partOperationInspectionItemId?: IntFilter | number
    operationInspectionRecordId?: IntFilter | number
  }

  export type PartVersionCreateWithoutReceiptsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    version: string
    note?: string | null
    part: PartCreateNestedOneWithoutPartVersionsInput
    incomingInspectionSpec?: IncomingInspectionSpecCreateNestedOneWithoutPartVersionInput
  }

  export type PartVersionUncheckedCreateWithoutReceiptsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    version: string
    note?: string | null
    partId: number
    incomingInspectionSpec?: IncomingInspectionSpecUncheckedCreateNestedOneWithoutPartVersionInput
  }

  export type PartVersionCreateOrConnectWithoutReceiptsInput = {
    where: PartVersionWhereUniqueInput
    create: XOR<PartVersionCreateWithoutReceiptsInput, PartVersionUncheckedCreateWithoutReceiptsInput>
  }

  export type IncomingInspectionRecordCreateWithoutReceiptInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    note: string
    result: IncomingInspectionResult
    incomingInspectionSpec: IncomingInspectionSpecCreateNestedOneWithoutIncomingInspectionRecordsInput
    incomingInspectionRecordItems?: IncomingInspectionRecordItemCreateNestedManyWithoutIncomingInspectionRecordInput
  }

  export type IncomingInspectionRecordUncheckedCreateWithoutReceiptInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    note: string
    result: IncomingInspectionResult
    incomingInspectionSpecId: number
    incomingInspectionRecordItems?: IncomingInspectionRecordItemUncheckedCreateNestedManyWithoutIncomingInspectionRecordInput
  }

  export type IncomingInspectionRecordCreateOrConnectWithoutReceiptInput = {
    where: IncomingInspectionRecordWhereUniqueInput
    create: XOR<IncomingInspectionRecordCreateWithoutReceiptInput, IncomingInspectionRecordUncheckedCreateWithoutReceiptInput>
  }

  export type PartVersionUpsertWithoutReceiptsInput = {
    update: XOR<PartVersionUpdateWithoutReceiptsInput, PartVersionUncheckedUpdateWithoutReceiptsInput>
    create: XOR<PartVersionCreateWithoutReceiptsInput, PartVersionUncheckedCreateWithoutReceiptsInput>
  }

  export type PartVersionUpdateWithoutReceiptsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    version?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    part?: PartUpdateOneRequiredWithoutPartVersionsNestedInput
    incomingInspectionSpec?: IncomingInspectionSpecUpdateOneWithoutPartVersionNestedInput
  }

  export type PartVersionUncheckedUpdateWithoutReceiptsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    version?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    partId?: IntFieldUpdateOperationsInput | number
    incomingInspectionSpec?: IncomingInspectionSpecUncheckedUpdateOneWithoutPartVersionNestedInput
  }

  export type IncomingInspectionRecordUpsertWithoutReceiptInput = {
    update: XOR<IncomingInspectionRecordUpdateWithoutReceiptInput, IncomingInspectionRecordUncheckedUpdateWithoutReceiptInput>
    create: XOR<IncomingInspectionRecordCreateWithoutReceiptInput, IncomingInspectionRecordUncheckedCreateWithoutReceiptInput>
  }

  export type IncomingInspectionRecordUpdateWithoutReceiptInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    note?: StringFieldUpdateOperationsInput | string
    result?: EnumIncomingInspectionResultFieldUpdateOperationsInput | IncomingInspectionResult
    incomingInspectionSpec?: IncomingInspectionSpecUpdateOneRequiredWithoutIncomingInspectionRecordsNestedInput
    incomingInspectionRecordItems?: IncomingInspectionRecordItemUpdateManyWithoutIncomingInspectionRecordNestedInput
  }

  export type IncomingInspectionRecordUncheckedUpdateWithoutReceiptInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    note?: StringFieldUpdateOperationsInput | string
    result?: EnumIncomingInspectionResultFieldUpdateOperationsInput | IncomingInspectionResult
    incomingInspectionSpecId?: IntFieldUpdateOperationsInput | number
    incomingInspectionRecordItems?: IncomingInspectionRecordItemUncheckedUpdateManyWithoutIncomingInspectionRecordNestedInput
  }

  export type ReceiptCreateWithoutIncomingInspectionRecordInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    lot: string
    partVersion: PartVersionCreateNestedOneWithoutReceiptsInput
  }

  export type ReceiptUncheckedCreateWithoutIncomingInspectionRecordInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    lot: string
    partVersionId: number
  }

  export type ReceiptCreateOrConnectWithoutIncomingInspectionRecordInput = {
    where: ReceiptWhereUniqueInput
    create: XOR<ReceiptCreateWithoutIncomingInspectionRecordInput, ReceiptUncheckedCreateWithoutIncomingInspectionRecordInput>
  }

  export type IncomingInspectionSpecCreateWithoutIncomingInspectionRecordsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    version: string
    attachment: string
    incomingInspectionSpecItems?: IncomingInspectionSpecItemCreateNestedManyWithoutIncomingInspectionSpecInput
    partVersion: PartVersionCreateNestedOneWithoutIncomingInspectionSpecInput
  }

  export type IncomingInspectionSpecUncheckedCreateWithoutIncomingInspectionRecordsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    version: string
    attachment: string
    partVersionId: number
    incomingInspectionSpecItems?: IncomingInspectionSpecItemUncheckedCreateNestedManyWithoutIncomingInspectionSpecInput
  }

  export type IncomingInspectionSpecCreateOrConnectWithoutIncomingInspectionRecordsInput = {
    where: IncomingInspectionSpecWhereUniqueInput
    create: XOR<IncomingInspectionSpecCreateWithoutIncomingInspectionRecordsInput, IncomingInspectionSpecUncheckedCreateWithoutIncomingInspectionRecordsInput>
  }

  export type IncomingInspectionRecordItemCreateWithoutIncomingInspectionRecordInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    result: boolean
    inspectionIteration: string
    incomingInspectionSpecItem: IncomingInspectionSpecItemCreateNestedOneWithoutIncomingInspectionRecordItemInput
  }

  export type IncomingInspectionRecordItemUncheckedCreateWithoutIncomingInspectionRecordInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    result: boolean
    inspectionIteration: string
    incomingInspectionSpecItemId: number
  }

  export type IncomingInspectionRecordItemCreateOrConnectWithoutIncomingInspectionRecordInput = {
    where: IncomingInspectionRecordItemWhereUniqueInput
    create: XOR<IncomingInspectionRecordItemCreateWithoutIncomingInspectionRecordInput, IncomingInspectionRecordItemUncheckedCreateWithoutIncomingInspectionRecordInput>
  }

  export type IncomingInspectionRecordItemCreateManyIncomingInspectionRecordInputEnvelope = {
    data: Enumerable<IncomingInspectionRecordItemCreateManyIncomingInspectionRecordInput>
    skipDuplicates?: boolean
  }

  export type ReceiptUpsertWithoutIncomingInspectionRecordInput = {
    update: XOR<ReceiptUpdateWithoutIncomingInspectionRecordInput, ReceiptUncheckedUpdateWithoutIncomingInspectionRecordInput>
    create: XOR<ReceiptCreateWithoutIncomingInspectionRecordInput, ReceiptUncheckedCreateWithoutIncomingInspectionRecordInput>
  }

  export type ReceiptUpdateWithoutIncomingInspectionRecordInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    lot?: StringFieldUpdateOperationsInput | string
    partVersion?: PartVersionUpdateOneRequiredWithoutReceiptsNestedInput
  }

  export type ReceiptUncheckedUpdateWithoutIncomingInspectionRecordInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    lot?: StringFieldUpdateOperationsInput | string
    partVersionId?: IntFieldUpdateOperationsInput | number
  }

  export type IncomingInspectionSpecUpsertWithoutIncomingInspectionRecordsInput = {
    update: XOR<IncomingInspectionSpecUpdateWithoutIncomingInspectionRecordsInput, IncomingInspectionSpecUncheckedUpdateWithoutIncomingInspectionRecordsInput>
    create: XOR<IncomingInspectionSpecCreateWithoutIncomingInspectionRecordsInput, IncomingInspectionSpecUncheckedCreateWithoutIncomingInspectionRecordsInput>
  }

  export type IncomingInspectionSpecUpdateWithoutIncomingInspectionRecordsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    version?: StringFieldUpdateOperationsInput | string
    attachment?: StringFieldUpdateOperationsInput | string
    incomingInspectionSpecItems?: IncomingInspectionSpecItemUpdateManyWithoutIncomingInspectionSpecNestedInput
    partVersion?: PartVersionUpdateOneRequiredWithoutIncomingInspectionSpecNestedInput
  }

  export type IncomingInspectionSpecUncheckedUpdateWithoutIncomingInspectionRecordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    version?: StringFieldUpdateOperationsInput | string
    attachment?: StringFieldUpdateOperationsInput | string
    partVersionId?: IntFieldUpdateOperationsInput | number
    incomingInspectionSpecItems?: IncomingInspectionSpecItemUncheckedUpdateManyWithoutIncomingInspectionSpecNestedInput
  }

  export type IncomingInspectionRecordItemUpsertWithWhereUniqueWithoutIncomingInspectionRecordInput = {
    where: IncomingInspectionRecordItemWhereUniqueInput
    update: XOR<IncomingInspectionRecordItemUpdateWithoutIncomingInspectionRecordInput, IncomingInspectionRecordItemUncheckedUpdateWithoutIncomingInspectionRecordInput>
    create: XOR<IncomingInspectionRecordItemCreateWithoutIncomingInspectionRecordInput, IncomingInspectionRecordItemUncheckedCreateWithoutIncomingInspectionRecordInput>
  }

  export type IncomingInspectionRecordItemUpdateWithWhereUniqueWithoutIncomingInspectionRecordInput = {
    where: IncomingInspectionRecordItemWhereUniqueInput
    data: XOR<IncomingInspectionRecordItemUpdateWithoutIncomingInspectionRecordInput, IncomingInspectionRecordItemUncheckedUpdateWithoutIncomingInspectionRecordInput>
  }

  export type IncomingInspectionRecordItemUpdateManyWithWhereWithoutIncomingInspectionRecordInput = {
    where: IncomingInspectionRecordItemScalarWhereInput
    data: XOR<IncomingInspectionRecordItemUpdateManyMutationInput, IncomingInspectionRecordItemUncheckedUpdateManyWithoutIncomingInspectionRecordItemsInput>
  }

  export type IncomingInspectionRecordCreateWithoutIncomingInspectionRecordItemsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    note: string
    result: IncomingInspectionResult
    receipt: ReceiptCreateNestedOneWithoutIncomingInspectionRecordInput
    incomingInspectionSpec: IncomingInspectionSpecCreateNestedOneWithoutIncomingInspectionRecordsInput
  }

  export type IncomingInspectionRecordUncheckedCreateWithoutIncomingInspectionRecordItemsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    note: string
    result: IncomingInspectionResult
    receiptId: number
    incomingInspectionSpecId: number
  }

  export type IncomingInspectionRecordCreateOrConnectWithoutIncomingInspectionRecordItemsInput = {
    where: IncomingInspectionRecordWhereUniqueInput
    create: XOR<IncomingInspectionRecordCreateWithoutIncomingInspectionRecordItemsInput, IncomingInspectionRecordUncheckedCreateWithoutIncomingInspectionRecordItemsInput>
  }

  export type IncomingInspectionSpecItemCreateWithoutIncomingInspectionRecordItemInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    no: number
    name: string
    spec: string
    incomingInspectionSpec: IncomingInspectionSpecCreateNestedOneWithoutIncomingInspectionSpecItemsInput
  }

  export type IncomingInspectionSpecItemUncheckedCreateWithoutIncomingInspectionRecordItemInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    no: number
    name: string
    spec: string
    incomingInspectionSpecId: number
  }

  export type IncomingInspectionSpecItemCreateOrConnectWithoutIncomingInspectionRecordItemInput = {
    where: IncomingInspectionSpecItemWhereUniqueInput
    create: XOR<IncomingInspectionSpecItemCreateWithoutIncomingInspectionRecordItemInput, IncomingInspectionSpecItemUncheckedCreateWithoutIncomingInspectionRecordItemInput>
  }

  export type IncomingInspectionRecordUpsertWithoutIncomingInspectionRecordItemsInput = {
    update: XOR<IncomingInspectionRecordUpdateWithoutIncomingInspectionRecordItemsInput, IncomingInspectionRecordUncheckedUpdateWithoutIncomingInspectionRecordItemsInput>
    create: XOR<IncomingInspectionRecordCreateWithoutIncomingInspectionRecordItemsInput, IncomingInspectionRecordUncheckedCreateWithoutIncomingInspectionRecordItemsInput>
  }

  export type IncomingInspectionRecordUpdateWithoutIncomingInspectionRecordItemsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    note?: StringFieldUpdateOperationsInput | string
    result?: EnumIncomingInspectionResultFieldUpdateOperationsInput | IncomingInspectionResult
    receipt?: ReceiptUpdateOneRequiredWithoutIncomingInspectionRecordNestedInput
    incomingInspectionSpec?: IncomingInspectionSpecUpdateOneRequiredWithoutIncomingInspectionRecordsNestedInput
  }

  export type IncomingInspectionRecordUncheckedUpdateWithoutIncomingInspectionRecordItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    note?: StringFieldUpdateOperationsInput | string
    result?: EnumIncomingInspectionResultFieldUpdateOperationsInput | IncomingInspectionResult
    receiptId?: IntFieldUpdateOperationsInput | number
    incomingInspectionSpecId?: IntFieldUpdateOperationsInput | number
  }

  export type IncomingInspectionSpecItemUpsertWithoutIncomingInspectionRecordItemInput = {
    update: XOR<IncomingInspectionSpecItemUpdateWithoutIncomingInspectionRecordItemInput, IncomingInspectionSpecItemUncheckedUpdateWithoutIncomingInspectionRecordItemInput>
    create: XOR<IncomingInspectionSpecItemCreateWithoutIncomingInspectionRecordItemInput, IncomingInspectionSpecItemUncheckedCreateWithoutIncomingInspectionRecordItemInput>
  }

  export type IncomingInspectionSpecItemUpdateWithoutIncomingInspectionRecordItemInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    no?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    spec?: StringFieldUpdateOperationsInput | string
    incomingInspectionSpec?: IncomingInspectionSpecUpdateOneRequiredWithoutIncomingInspectionSpecItemsNestedInput
  }

  export type IncomingInspectionSpecItemUncheckedUpdateWithoutIncomingInspectionRecordItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    no?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    spec?: StringFieldUpdateOperationsInput | string
    incomingInspectionSpecId?: IntFieldUpdateOperationsInput | number
  }

  export type PartCreateWithoutWorkerOrdersInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    no: string
    name: string
    partVersions?: PartVersionCreateNestedManyWithoutPartInput
    partOperation?: PartOperationCreateNestedManyWithoutPartInput
    nonconformItems?: NonconformItemCreateNestedManyWithoutPartInput
  }

  export type PartUncheckedCreateWithoutWorkerOrdersInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    no: string
    name: string
    partVersions?: PartVersionUncheckedCreateNestedManyWithoutPartInput
    partOperation?: PartOperationUncheckedCreateNestedManyWithoutPartInput
    nonconformItems?: NonconformItemUncheckedCreateNestedManyWithoutPartInput
  }

  export type PartCreateOrConnectWithoutWorkerOrdersInput = {
    where: PartWhereUniqueInput
    create: XOR<PartCreateWithoutWorkerOrdersInput, PartUncheckedCreateWithoutWorkerOrdersInput>
  }

  export type OperationInspectionRecordCreateWithoutWorkerOrderInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    note?: string | null
    inspector: UserCreateNestedOneWithoutReviewedOperationInspectionRecordsInput
    reviewer: UserCreateNestedOneWithoutInspectedOperationInspectionRecordsInput
    operationInspectionRecordItems?: OperationInspectionRecordItemCreateNestedManyWithoutOperationInspectionRecordInput
  }

  export type OperationInspectionRecordUncheckedCreateWithoutWorkerOrderInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    note?: string | null
    inspectorId: number
    reviewerId: number
    operationInspectionRecordItems?: OperationInspectionRecordItemUncheckedCreateNestedManyWithoutOperationInspectionRecordInput
  }

  export type OperationInspectionRecordCreateOrConnectWithoutWorkerOrderInput = {
    where: OperationInspectionRecordWhereUniqueInput
    create: XOR<OperationInspectionRecordCreateWithoutWorkerOrderInput, OperationInspectionRecordUncheckedCreateWithoutWorkerOrderInput>
  }

  export type OperationInspectionRecordCreateManyWorkerOrderInputEnvelope = {
    data: Enumerable<OperationInspectionRecordCreateManyWorkerOrderInput>
    skipDuplicates?: boolean
  }

  export type PartUpsertWithoutWorkerOrdersInput = {
    update: XOR<PartUpdateWithoutWorkerOrdersInput, PartUncheckedUpdateWithoutWorkerOrdersInput>
    create: XOR<PartCreateWithoutWorkerOrdersInput, PartUncheckedCreateWithoutWorkerOrdersInput>
  }

  export type PartUpdateWithoutWorkerOrdersInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    no?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    partVersions?: PartVersionUpdateManyWithoutPartNestedInput
    partOperation?: PartOperationUpdateManyWithoutPartNestedInput
    nonconformItems?: NonconformItemUpdateManyWithoutPartNestedInput
  }

  export type PartUncheckedUpdateWithoutWorkerOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    no?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    partVersions?: PartVersionUncheckedUpdateManyWithoutPartNestedInput
    partOperation?: PartOperationUncheckedUpdateManyWithoutPartNestedInput
    nonconformItems?: NonconformItemUncheckedUpdateManyWithoutPartNestedInput
  }

  export type OperationInspectionRecordUpsertWithWhereUniqueWithoutWorkerOrderInput = {
    where: OperationInspectionRecordWhereUniqueInput
    update: XOR<OperationInspectionRecordUpdateWithoutWorkerOrderInput, OperationInspectionRecordUncheckedUpdateWithoutWorkerOrderInput>
    create: XOR<OperationInspectionRecordCreateWithoutWorkerOrderInput, OperationInspectionRecordUncheckedCreateWithoutWorkerOrderInput>
  }

  export type OperationInspectionRecordUpdateWithWhereUniqueWithoutWorkerOrderInput = {
    where: OperationInspectionRecordWhereUniqueInput
    data: XOR<OperationInspectionRecordUpdateWithoutWorkerOrderInput, OperationInspectionRecordUncheckedUpdateWithoutWorkerOrderInput>
  }

  export type OperationInspectionRecordUpdateManyWithWhereWithoutWorkerOrderInput = {
    where: OperationInspectionRecordScalarWhereInput
    data: XOR<OperationInspectionRecordUpdateManyMutationInput, OperationInspectionRecordUncheckedUpdateManyWithoutOperationInspectionRecordsInput>
  }

  export type WorkerOrderCreateWithoutOperationInspectionRecordsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    no: string
    part: PartCreateNestedOneWithoutWorkerOrdersInput
  }

  export type WorkerOrderUncheckedCreateWithoutOperationInspectionRecordsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    no: string
    partId: number
  }

  export type WorkerOrderCreateOrConnectWithoutOperationInspectionRecordsInput = {
    where: WorkerOrderWhereUniqueInput
    create: XOR<WorkerOrderCreateWithoutOperationInspectionRecordsInput, WorkerOrderUncheckedCreateWithoutOperationInspectionRecordsInput>
  }

  export type UserCreateWithoutReviewedOperationInspectionRecordsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    username: string
    hashedPassword?: string | null
    hashedRefreshToken?: string | null
    status: UserStatus
    role?: UserGroup
    profile?: UserProfileCreateNestedOneWithoutUserInput
    inspectedOperationInspectionRecords?: OperationInspectionRecordCreateNestedManyWithoutReviewerInput
  }

  export type UserUncheckedCreateWithoutReviewedOperationInspectionRecordsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    username: string
    hashedPassword?: string | null
    hashedRefreshToken?: string | null
    status: UserStatus
    role?: UserGroup
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    inspectedOperationInspectionRecords?: OperationInspectionRecordUncheckedCreateNestedManyWithoutReviewerInput
  }

  export type UserCreateOrConnectWithoutReviewedOperationInspectionRecordsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewedOperationInspectionRecordsInput, UserUncheckedCreateWithoutReviewedOperationInspectionRecordsInput>
  }

  export type UserCreateWithoutInspectedOperationInspectionRecordsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    username: string
    hashedPassword?: string | null
    hashedRefreshToken?: string | null
    status: UserStatus
    role?: UserGroup
    profile?: UserProfileCreateNestedOneWithoutUserInput
    reviewedOperationInspectionRecords?: OperationInspectionRecordCreateNestedManyWithoutInspectorInput
  }

  export type UserUncheckedCreateWithoutInspectedOperationInspectionRecordsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    username: string
    hashedPassword?: string | null
    hashedRefreshToken?: string | null
    status: UserStatus
    role?: UserGroup
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    reviewedOperationInspectionRecords?: OperationInspectionRecordUncheckedCreateNestedManyWithoutInspectorInput
  }

  export type UserCreateOrConnectWithoutInspectedOperationInspectionRecordsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInspectedOperationInspectionRecordsInput, UserUncheckedCreateWithoutInspectedOperationInspectionRecordsInput>
  }

  export type OperationInspectionRecordItemCreateWithoutOperationInspectionRecordInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    inspectionIteration: string
    partOperationInspectionItem: PartOperationInspectionItemCreateNestedOneWithoutOperationInspectionRecordItemsInput
  }

  export type OperationInspectionRecordItemUncheckedCreateWithoutOperationInspectionRecordInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    inspectionIteration: string
    partOperationInspectionItemId: number
  }

  export type OperationInspectionRecordItemCreateOrConnectWithoutOperationInspectionRecordInput = {
    where: OperationInspectionRecordItemWhereUniqueInput
    create: XOR<OperationInspectionRecordItemCreateWithoutOperationInspectionRecordInput, OperationInspectionRecordItemUncheckedCreateWithoutOperationInspectionRecordInput>
  }

  export type OperationInspectionRecordItemCreateManyOperationInspectionRecordInputEnvelope = {
    data: Enumerable<OperationInspectionRecordItemCreateManyOperationInspectionRecordInput>
    skipDuplicates?: boolean
  }

  export type WorkerOrderUpsertWithoutOperationInspectionRecordsInput = {
    update: XOR<WorkerOrderUpdateWithoutOperationInspectionRecordsInput, WorkerOrderUncheckedUpdateWithoutOperationInspectionRecordsInput>
    create: XOR<WorkerOrderCreateWithoutOperationInspectionRecordsInput, WorkerOrderUncheckedCreateWithoutOperationInspectionRecordsInput>
  }

  export type WorkerOrderUpdateWithoutOperationInspectionRecordsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    no?: StringFieldUpdateOperationsInput | string
    part?: PartUpdateOneRequiredWithoutWorkerOrdersNestedInput
  }

  export type WorkerOrderUncheckedUpdateWithoutOperationInspectionRecordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    no?: StringFieldUpdateOperationsInput | string
    partId?: IntFieldUpdateOperationsInput | number
  }

  export type UserUpsertWithoutReviewedOperationInspectionRecordsInput = {
    update: XOR<UserUpdateWithoutReviewedOperationInspectionRecordsInput, UserUncheckedUpdateWithoutReviewedOperationInspectionRecordsInput>
    create: XOR<UserCreateWithoutReviewedOperationInspectionRecordsInput, UserUncheckedCreateWithoutReviewedOperationInspectionRecordsInput>
  }

  export type UserUpdateWithoutReviewedOperationInspectionRecordsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    username?: StringFieldUpdateOperationsInput | string
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    hashedRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | UserStatus
    role?: EnumUserGroupFieldUpdateOperationsInput | UserGroup
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    inspectedOperationInspectionRecords?: OperationInspectionRecordUpdateManyWithoutReviewerNestedInput
  }

  export type UserUncheckedUpdateWithoutReviewedOperationInspectionRecordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    username?: StringFieldUpdateOperationsInput | string
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    hashedRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | UserStatus
    role?: EnumUserGroupFieldUpdateOperationsInput | UserGroup
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    inspectedOperationInspectionRecords?: OperationInspectionRecordUncheckedUpdateManyWithoutReviewerNestedInput
  }

  export type UserUpsertWithoutInspectedOperationInspectionRecordsInput = {
    update: XOR<UserUpdateWithoutInspectedOperationInspectionRecordsInput, UserUncheckedUpdateWithoutInspectedOperationInspectionRecordsInput>
    create: XOR<UserCreateWithoutInspectedOperationInspectionRecordsInput, UserUncheckedCreateWithoutInspectedOperationInspectionRecordsInput>
  }

  export type UserUpdateWithoutInspectedOperationInspectionRecordsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    username?: StringFieldUpdateOperationsInput | string
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    hashedRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | UserStatus
    role?: EnumUserGroupFieldUpdateOperationsInput | UserGroup
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    reviewedOperationInspectionRecords?: OperationInspectionRecordUpdateManyWithoutInspectorNestedInput
  }

  export type UserUncheckedUpdateWithoutInspectedOperationInspectionRecordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    username?: StringFieldUpdateOperationsInput | string
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    hashedRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | UserStatus
    role?: EnumUserGroupFieldUpdateOperationsInput | UserGroup
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    reviewedOperationInspectionRecords?: OperationInspectionRecordUncheckedUpdateManyWithoutInspectorNestedInput
  }

  export type OperationInspectionRecordItemUpsertWithWhereUniqueWithoutOperationInspectionRecordInput = {
    where: OperationInspectionRecordItemWhereUniqueInput
    update: XOR<OperationInspectionRecordItemUpdateWithoutOperationInspectionRecordInput, OperationInspectionRecordItemUncheckedUpdateWithoutOperationInspectionRecordInput>
    create: XOR<OperationInspectionRecordItemCreateWithoutOperationInspectionRecordInput, OperationInspectionRecordItemUncheckedCreateWithoutOperationInspectionRecordInput>
  }

  export type OperationInspectionRecordItemUpdateWithWhereUniqueWithoutOperationInspectionRecordInput = {
    where: OperationInspectionRecordItemWhereUniqueInput
    data: XOR<OperationInspectionRecordItemUpdateWithoutOperationInspectionRecordInput, OperationInspectionRecordItemUncheckedUpdateWithoutOperationInspectionRecordInput>
  }

  export type OperationInspectionRecordItemUpdateManyWithWhereWithoutOperationInspectionRecordInput = {
    where: OperationInspectionRecordItemScalarWhereInput
    data: XOR<OperationInspectionRecordItemUpdateManyMutationInput, OperationInspectionRecordItemUncheckedUpdateManyWithoutOperationInspectionRecordItemsInput>
  }

  export type PartOperationInspectionItemCreateWithoutOperationInspectionRecordItemsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    partOperation: PartOperationCreateNestedOneWithoutPartOperationInspectionItemsInput
  }

  export type PartOperationInspectionItemUncheckedCreateWithoutOperationInspectionRecordItemsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    partOperationId: number
  }

  export type PartOperationInspectionItemCreateOrConnectWithoutOperationInspectionRecordItemsInput = {
    where: PartOperationInspectionItemWhereUniqueInput
    create: XOR<PartOperationInspectionItemCreateWithoutOperationInspectionRecordItemsInput, PartOperationInspectionItemUncheckedCreateWithoutOperationInspectionRecordItemsInput>
  }

  export type OperationInspectionRecordCreateWithoutOperationInspectionRecordItemsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    note?: string | null
    workerOrder: WorkerOrderCreateNestedOneWithoutOperationInspectionRecordsInput
    inspector: UserCreateNestedOneWithoutReviewedOperationInspectionRecordsInput
    reviewer: UserCreateNestedOneWithoutInspectedOperationInspectionRecordsInput
  }

  export type OperationInspectionRecordUncheckedCreateWithoutOperationInspectionRecordItemsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    note?: string | null
    workerOrderId: number
    inspectorId: number
    reviewerId: number
  }

  export type OperationInspectionRecordCreateOrConnectWithoutOperationInspectionRecordItemsInput = {
    where: OperationInspectionRecordWhereUniqueInput
    create: XOR<OperationInspectionRecordCreateWithoutOperationInspectionRecordItemsInput, OperationInspectionRecordUncheckedCreateWithoutOperationInspectionRecordItemsInput>
  }

  export type PartOperationInspectionItemUpsertWithoutOperationInspectionRecordItemsInput = {
    update: XOR<PartOperationInspectionItemUpdateWithoutOperationInspectionRecordItemsInput, PartOperationInspectionItemUncheckedUpdateWithoutOperationInspectionRecordItemsInput>
    create: XOR<PartOperationInspectionItemCreateWithoutOperationInspectionRecordItemsInput, PartOperationInspectionItemUncheckedCreateWithoutOperationInspectionRecordItemsInput>
  }

  export type PartOperationInspectionItemUpdateWithoutOperationInspectionRecordItemsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    partOperation?: PartOperationUpdateOneRequiredWithoutPartOperationInspectionItemsNestedInput
  }

  export type PartOperationInspectionItemUncheckedUpdateWithoutOperationInspectionRecordItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    partOperationId?: IntFieldUpdateOperationsInput | number
  }

  export type OperationInspectionRecordUpsertWithoutOperationInspectionRecordItemsInput = {
    update: XOR<OperationInspectionRecordUpdateWithoutOperationInspectionRecordItemsInput, OperationInspectionRecordUncheckedUpdateWithoutOperationInspectionRecordItemsInput>
    create: XOR<OperationInspectionRecordCreateWithoutOperationInspectionRecordItemsInput, OperationInspectionRecordUncheckedCreateWithoutOperationInspectionRecordItemsInput>
  }

  export type OperationInspectionRecordUpdateWithoutOperationInspectionRecordItemsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    note?: NullableStringFieldUpdateOperationsInput | string | null
    workerOrder?: WorkerOrderUpdateOneRequiredWithoutOperationInspectionRecordsNestedInput
    inspector?: UserUpdateOneRequiredWithoutReviewedOperationInspectionRecordsNestedInput
    reviewer?: UserUpdateOneRequiredWithoutInspectedOperationInspectionRecordsNestedInput
  }

  export type OperationInspectionRecordUncheckedUpdateWithoutOperationInspectionRecordItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    note?: NullableStringFieldUpdateOperationsInput | string | null
    workerOrderId?: IntFieldUpdateOperationsInput | number
    inspectorId?: IntFieldUpdateOperationsInput | number
    reviewerId?: IntFieldUpdateOperationsInput | number
  }

  export type OperationInspectionRecordCreateManyInspectorInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    note?: string | null
    workerOrderId: number
    reviewerId: number
  }

  export type OperationInspectionRecordCreateManyReviewerInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    note?: string | null
    workerOrderId: number
    inspectorId: number
  }

  export type OperationInspectionRecordUpdateWithoutInspectorInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    note?: NullableStringFieldUpdateOperationsInput | string | null
    workerOrder?: WorkerOrderUpdateOneRequiredWithoutOperationInspectionRecordsNestedInput
    reviewer?: UserUpdateOneRequiredWithoutInspectedOperationInspectionRecordsNestedInput
    operationInspectionRecordItems?: OperationInspectionRecordItemUpdateManyWithoutOperationInspectionRecordNestedInput
  }

  export type OperationInspectionRecordUncheckedUpdateWithoutInspectorInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    note?: NullableStringFieldUpdateOperationsInput | string | null
    workerOrderId?: IntFieldUpdateOperationsInput | number
    reviewerId?: IntFieldUpdateOperationsInput | number
    operationInspectionRecordItems?: OperationInspectionRecordItemUncheckedUpdateManyWithoutOperationInspectionRecordNestedInput
  }

  export type OperationInspectionRecordUncheckedUpdateManyWithoutReviewedOperationInspectionRecordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    note?: NullableStringFieldUpdateOperationsInput | string | null
    workerOrderId?: IntFieldUpdateOperationsInput | number
    reviewerId?: IntFieldUpdateOperationsInput | number
  }

  export type OperationInspectionRecordUpdateWithoutReviewerInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    note?: NullableStringFieldUpdateOperationsInput | string | null
    workerOrder?: WorkerOrderUpdateOneRequiredWithoutOperationInspectionRecordsNestedInput
    inspector?: UserUpdateOneRequiredWithoutReviewedOperationInspectionRecordsNestedInput
    operationInspectionRecordItems?: OperationInspectionRecordItemUpdateManyWithoutOperationInspectionRecordNestedInput
  }

  export type OperationInspectionRecordUncheckedUpdateWithoutReviewerInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    note?: NullableStringFieldUpdateOperationsInput | string | null
    workerOrderId?: IntFieldUpdateOperationsInput | number
    inspectorId?: IntFieldUpdateOperationsInput | number
    operationInspectionRecordItems?: OperationInspectionRecordItemUncheckedUpdateManyWithoutOperationInspectionRecordNestedInput
  }

  export type OperationInspectionRecordUncheckedUpdateManyWithoutInspectedOperationInspectionRecordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    note?: NullableStringFieldUpdateOperationsInput | string | null
    workerOrderId?: IntFieldUpdateOperationsInput | number
    inspectorId?: IntFieldUpdateOperationsInput | number
  }

  export type EquipmentCreateManyProductLineInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    description: string
    repairPlan: string
    workStation: string
  }

  export type EquipmentUpdateWithoutProductLineInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    repairPlan?: StringFieldUpdateOperationsInput | string
    workStation?: StringFieldUpdateOperationsInput | string
    repairMaterialInventories?: RepairMaterialInventoryUpdateManyWithoutEquipmentNestedInput
    repairRecords?: RepairRecordUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentUncheckedUpdateWithoutProductLineInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    repairPlan?: StringFieldUpdateOperationsInput | string
    workStation?: StringFieldUpdateOperationsInput | string
    repairMaterialInventories?: RepairMaterialInventoryUncheckedUpdateManyWithoutEquipmentNestedInput
    repairRecords?: RepairRecordUncheckedUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentUncheckedUpdateManyWithoutEquipmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    repairPlan?: StringFieldUpdateOperationsInput | string
    workStation?: StringFieldUpdateOperationsInput | string
  }

  export type RepairMaterialInventoryCreateManyEquipmentInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    description: string
    quantity: number
    minimumQuantity: number
  }

  export type RepairRecordCreateManyEquipmentInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    type: RepairType
    status: RepairRecordStatus
    description: string
  }

  export type RepairMaterialInventoryUpdateWithoutEquipmentInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    minimumQuantity?: IntFieldUpdateOperationsInput | number
  }

  export type RepairMaterialInventoryUncheckedUpdateWithoutEquipmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    minimumQuantity?: IntFieldUpdateOperationsInput | number
  }

  export type RepairMaterialInventoryUncheckedUpdateManyWithoutRepairMaterialInventoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    minimumQuantity?: IntFieldUpdateOperationsInput | number
  }

  export type RepairRecordUpdateWithoutEquipmentInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumRepairTypeFieldUpdateOperationsInput | RepairType
    status?: EnumRepairRecordStatusFieldUpdateOperationsInput | RepairRecordStatus
    description?: StringFieldUpdateOperationsInput | string
  }

  export type RepairRecordUncheckedUpdateWithoutEquipmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumRepairTypeFieldUpdateOperationsInput | RepairType
    status?: EnumRepairRecordStatusFieldUpdateOperationsInput | RepairRecordStatus
    description?: StringFieldUpdateOperationsInput | string
  }

  export type RepairRecordUncheckedUpdateManyWithoutRepairRecordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumRepairTypeFieldUpdateOperationsInput | RepairType
    status?: EnumRepairRecordStatusFieldUpdateOperationsInput | RepairRecordStatus
    description?: StringFieldUpdateOperationsInput | string
  }

  export type PartVersionCreateManyPartInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    version: string
    note?: string | null
  }

  export type PartOperationCreateManyPartInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    version: string
    no: string
    name: string
  }

  export type WorkerOrderCreateManyPartInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    no: string
  }

  export type NonconformItemCreateManyPartInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    description: string
    note?: string | null
  }

  export type PartVersionUpdateWithoutPartInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    version?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    incomingInspectionSpec?: IncomingInspectionSpecUpdateOneWithoutPartVersionNestedInput
    receipts?: ReceiptUpdateManyWithoutPartVersionNestedInput
  }

  export type PartVersionUncheckedUpdateWithoutPartInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    version?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    incomingInspectionSpec?: IncomingInspectionSpecUncheckedUpdateOneWithoutPartVersionNestedInput
    receipts?: ReceiptUncheckedUpdateManyWithoutPartVersionNestedInput
  }

  export type PartVersionUncheckedUpdateManyWithoutPartVersionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    version?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PartOperationUpdateWithoutPartInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    version?: StringFieldUpdateOperationsInput | string
    no?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    partOperationInspectionItems?: PartOperationInspectionItemUpdateManyWithoutPartOperationNestedInput
  }

  export type PartOperationUncheckedUpdateWithoutPartInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    version?: StringFieldUpdateOperationsInput | string
    no?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    partOperationInspectionItems?: PartOperationInspectionItemUncheckedUpdateManyWithoutPartOperationNestedInput
  }

  export type PartOperationUncheckedUpdateManyWithoutPartOperationInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    version?: StringFieldUpdateOperationsInput | string
    no?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type WorkerOrderUpdateWithoutPartInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    no?: StringFieldUpdateOperationsInput | string
    operationInspectionRecords?: OperationInspectionRecordUpdateManyWithoutWorkerOrderNestedInput
  }

  export type WorkerOrderUncheckedUpdateWithoutPartInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    no?: StringFieldUpdateOperationsInput | string
    operationInspectionRecords?: OperationInspectionRecordUncheckedUpdateManyWithoutWorkerOrderNestedInput
  }

  export type WorkerOrderUncheckedUpdateManyWithoutWorkerOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    no?: StringFieldUpdateOperationsInput | string
  }

  export type NonconformItemUpdateWithoutPartInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    description?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NonconformItemUncheckedUpdateWithoutPartInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    description?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NonconformItemUncheckedUpdateManyWithoutNonconformItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    description?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReceiptCreateManyPartVersionInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    lot: string
  }

  export type ReceiptUpdateWithoutPartVersionInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    lot?: StringFieldUpdateOperationsInput | string
    incomingInspectionRecord?: IncomingInspectionRecordUpdateOneWithoutReceiptNestedInput
  }

  export type ReceiptUncheckedUpdateWithoutPartVersionInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    lot?: StringFieldUpdateOperationsInput | string
    incomingInspectionRecord?: IncomingInspectionRecordUncheckedUpdateOneWithoutReceiptNestedInput
  }

  export type ReceiptUncheckedUpdateManyWithoutReceiptsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    lot?: StringFieldUpdateOperationsInput | string
  }

  export type IncomingInspectionSpecItemCreateManyIncomingInspectionSpecInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    no: number
    name: string
    spec: string
  }

  export type IncomingInspectionRecordCreateManyIncomingInspectionSpecInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    note: string
    result: IncomingInspectionResult
    receiptId: number
  }

  export type IncomingInspectionSpecItemUpdateWithoutIncomingInspectionSpecInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    no?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    spec?: StringFieldUpdateOperationsInput | string
    incomingInspectionRecordItem?: IncomingInspectionRecordItemUpdateManyWithoutIncomingInspectionSpecItemNestedInput
  }

  export type IncomingInspectionSpecItemUncheckedUpdateWithoutIncomingInspectionSpecInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    no?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    spec?: StringFieldUpdateOperationsInput | string
    incomingInspectionRecordItem?: IncomingInspectionRecordItemUncheckedUpdateManyWithoutIncomingInspectionSpecItemNestedInput
  }

  export type IncomingInspectionSpecItemUncheckedUpdateManyWithoutIncomingInspectionSpecItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    no?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    spec?: StringFieldUpdateOperationsInput | string
  }

  export type IncomingInspectionRecordUpdateWithoutIncomingInspectionSpecInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    note?: StringFieldUpdateOperationsInput | string
    result?: EnumIncomingInspectionResultFieldUpdateOperationsInput | IncomingInspectionResult
    receipt?: ReceiptUpdateOneRequiredWithoutIncomingInspectionRecordNestedInput
    incomingInspectionRecordItems?: IncomingInspectionRecordItemUpdateManyWithoutIncomingInspectionRecordNestedInput
  }

  export type IncomingInspectionRecordUncheckedUpdateWithoutIncomingInspectionSpecInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    note?: StringFieldUpdateOperationsInput | string
    result?: EnumIncomingInspectionResultFieldUpdateOperationsInput | IncomingInspectionResult
    receiptId?: IntFieldUpdateOperationsInput | number
    incomingInspectionRecordItems?: IncomingInspectionRecordItemUncheckedUpdateManyWithoutIncomingInspectionRecordNestedInput
  }

  export type IncomingInspectionRecordUncheckedUpdateManyWithoutIncomingInspectionRecordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    note?: StringFieldUpdateOperationsInput | string
    result?: EnumIncomingInspectionResultFieldUpdateOperationsInput | IncomingInspectionResult
    receiptId?: IntFieldUpdateOperationsInput | number
  }

  export type IncomingInspectionRecordItemCreateManyIncomingInspectionSpecItemInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    result: boolean
    inspectionIteration: string
    incomingInspectionRecordId: number
  }

  export type IncomingInspectionRecordItemUpdateWithoutIncomingInspectionSpecItemInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    result?: BoolFieldUpdateOperationsInput | boolean
    inspectionIteration?: StringFieldUpdateOperationsInput | string
    incomingInspectionRecord?: IncomingInspectionRecordUpdateOneRequiredWithoutIncomingInspectionRecordItemsNestedInput
  }

  export type IncomingInspectionRecordItemUncheckedUpdateWithoutIncomingInspectionSpecItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    result?: BoolFieldUpdateOperationsInput | boolean
    inspectionIteration?: StringFieldUpdateOperationsInput | string
    incomingInspectionRecordId?: IntFieldUpdateOperationsInput | number
  }

  export type IncomingInspectionRecordItemUncheckedUpdateManyWithoutIncomingInspectionRecordItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    result?: BoolFieldUpdateOperationsInput | boolean
    inspectionIteration?: StringFieldUpdateOperationsInput | string
    incomingInspectionRecordId?: IntFieldUpdateOperationsInput | number
  }

  export type PartOperationInspectionItemCreateManyPartOperationInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
  }

  export type PartOperationInspectionItemUpdateWithoutPartOperationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    operationInspectionRecordItems?: OperationInspectionRecordItemUpdateManyWithoutPartOperationInspectionItemNestedInput
  }

  export type PartOperationInspectionItemUncheckedUpdateWithoutPartOperationInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    operationInspectionRecordItems?: OperationInspectionRecordItemUncheckedUpdateManyWithoutPartOperationInspectionItemNestedInput
  }

  export type PartOperationInspectionItemUncheckedUpdateManyWithoutPartOperationInspectionItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type OperationInspectionRecordItemCreateManyPartOperationInspectionItemInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    inspectionIteration: string
    operationInspectionRecordId: number
  }

  export type OperationInspectionRecordItemUpdateWithoutPartOperationInspectionItemInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    inspectionIteration?: StringFieldUpdateOperationsInput | string
    operationInspectionRecord?: OperationInspectionRecordUpdateOneRequiredWithoutOperationInspectionRecordItemsNestedInput
  }

  export type OperationInspectionRecordItemUncheckedUpdateWithoutPartOperationInspectionItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    inspectionIteration?: StringFieldUpdateOperationsInput | string
    operationInspectionRecordId?: IntFieldUpdateOperationsInput | number
  }

  export type OperationInspectionRecordItemUncheckedUpdateManyWithoutOperationInspectionRecordItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    inspectionIteration?: StringFieldUpdateOperationsInput | string
    operationInspectionRecordId?: IntFieldUpdateOperationsInput | number
  }

  export type IncomingInspectionRecordItemCreateManyIncomingInspectionRecordInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    result: boolean
    inspectionIteration: string
    incomingInspectionSpecItemId: number
  }

  export type IncomingInspectionRecordItemUpdateWithoutIncomingInspectionRecordInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    result?: BoolFieldUpdateOperationsInput | boolean
    inspectionIteration?: StringFieldUpdateOperationsInput | string
    incomingInspectionSpecItem?: IncomingInspectionSpecItemUpdateOneRequiredWithoutIncomingInspectionRecordItemNestedInput
  }

  export type IncomingInspectionRecordItemUncheckedUpdateWithoutIncomingInspectionRecordInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    result?: BoolFieldUpdateOperationsInput | boolean
    inspectionIteration?: StringFieldUpdateOperationsInput | string
    incomingInspectionSpecItemId?: IntFieldUpdateOperationsInput | number
  }

  export type IncomingInspectionRecordItemUncheckedUpdateManyWithoutIncomingInspectionRecordItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    result?: BoolFieldUpdateOperationsInput | boolean
    inspectionIteration?: StringFieldUpdateOperationsInput | string
    incomingInspectionSpecItemId?: IntFieldUpdateOperationsInput | number
  }

  export type OperationInspectionRecordCreateManyWorkerOrderInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    note?: string | null
    inspectorId: number
    reviewerId: number
  }

  export type OperationInspectionRecordUpdateWithoutWorkerOrderInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    note?: NullableStringFieldUpdateOperationsInput | string | null
    inspector?: UserUpdateOneRequiredWithoutReviewedOperationInspectionRecordsNestedInput
    reviewer?: UserUpdateOneRequiredWithoutInspectedOperationInspectionRecordsNestedInput
    operationInspectionRecordItems?: OperationInspectionRecordItemUpdateManyWithoutOperationInspectionRecordNestedInput
  }

  export type OperationInspectionRecordUncheckedUpdateWithoutWorkerOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    note?: NullableStringFieldUpdateOperationsInput | string | null
    inspectorId?: IntFieldUpdateOperationsInput | number
    reviewerId?: IntFieldUpdateOperationsInput | number
    operationInspectionRecordItems?: OperationInspectionRecordItemUncheckedUpdateManyWithoutOperationInspectionRecordNestedInput
  }

  export type OperationInspectionRecordUncheckedUpdateManyWithoutOperationInspectionRecordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    note?: NullableStringFieldUpdateOperationsInput | string | null
    inspectorId?: IntFieldUpdateOperationsInput | number
    reviewerId?: IntFieldUpdateOperationsInput | number
  }

  export type OperationInspectionRecordItemCreateManyOperationInspectionRecordInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    inspectionIteration: string
    partOperationInspectionItemId: number
  }

  export type OperationInspectionRecordItemUpdateWithoutOperationInspectionRecordInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    inspectionIteration?: StringFieldUpdateOperationsInput | string
    partOperationInspectionItem?: PartOperationInspectionItemUpdateOneRequiredWithoutOperationInspectionRecordItemsNestedInput
  }

  export type OperationInspectionRecordItemUncheckedUpdateWithoutOperationInspectionRecordInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    inspectionIteration?: StringFieldUpdateOperationsInput | string
    partOperationInspectionItemId?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}