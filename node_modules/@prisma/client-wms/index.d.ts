
/**
 * Client
**/

import * as runtime from './runtime/library';
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends Prisma.PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};

export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>


/**
 * Model TaskFormRelation
 * @schema.display_name 节点和表单关联关系
 */
export type TaskFormRelation = {
  id: number
  createdAt: Date
  updatedAt: Date
  isDeleted: boolean
  taskDefinitionKey: string
  formKey: string
}

/**
 * Model User
 * @schema.display_name 员工
 */
export type User = {
  id: number
  createdAt: Date
  updatedAt: Date
  isDeleted: boolean
  username: string
  hashedPassword: string | null
  hashedRefreshToken: string | null
  status: UserStatus
  role: UserGroup
}

/**
 * Model UserProfile
 * 
 */
export type UserProfile = {
  id: number
  createdAt: Date
  updatedAt: Date
  isDeleted: boolean
  userId: number
  fullName: string
}

/**
 * Model ProductLine
 * @schema.primary_key id
 * @schema.display_name 产线
 * @schema.display_column name
 */
export type ProductLine = {
  id: number
  createdAt: Date
  updatedAt: Date
  isDeleted: boolean
  /**
   * @schema.title 产线名
   */
  name: string
  /**
   * @schema.title 产线描述
   */
  description: string | null
}

/**
 * Model Equipment
 * @schema.primary_key id
 * @schema.display_name 设备
 * @schema.display_column name
 */
export type Equipment = {
  id: number
  createdAt: Date
  updatedAt: Date
  isDeleted: boolean
  /**
   * @schema.title 设备名
   */
  name: string
  /**
   * @schema.title 设备描述
   */
  description: string | null
  /**
   * @schema.title 购买日期
   */
  purchaseDate: Date
  /**
   * @schema.reference ProductLine
   */
  productLineId: number | null
}

/**
 * Model RepairMaterial
 * @schema.primary_key id
 * @schema.display_name 备品备料
 * @schema.display_column name
 */
export type RepairMaterial = {
  id: number
  createdAt: Date
  updatedAt: Date
  isDeleted: boolean
  /**
   * @schema.title 物料名
   */
  name: string
  /**
   * @schema.title 物料描述
   */
  description: string | null
}

/**
 * Model RepairPlan
 * @schema.primary_key id
 * @schema.display_name 保养计划
 */
export type RepairPlan = {
  id: number
  createdAt: Date
  updatedAt: Date
  isDeleted: boolean
  /**
   * @schema.title 计划描述
   */
  description: string | null
  /**
   * @schema.reference Equipment
   */
  equimentId: number
}

/**
 * Model RepairMaterialInventory
 * @schema.primary_key id
 * @schema.display_name 备品备料库存
 */
export type RepairMaterialInventory = {
  id: number
  createdAt: Date
  updatedAt: Date
  isDeleted: boolean
  /**
   * @schema.reference RepairMaterial
   */
  materialId: number
  /**
   * @schema.title 数量
   */
  quantity: number
}

/**
 * Model RepairRecord
 * @schema.primary_key id
 * @schema.display_name 维修记录
 */
export type RepairRecord = {
  id: number
  createdAt: Date
  updatedAt: Date
  isDeleted: boolean
  /**
   * @schema.reference Equipment
   */
  equimentId: number
  /**
   * @schema.title 备注
   */
  description: string | null
  /**
   * @schema.title 状态
   */
  status: RepairRecordStatus | null
  /**
   * @schema.title 类型
   */
  type: RepairType
}

/**
 * Model Material
 * @schema.primary_key id
 * @schema.display_name 物料
 * @schema.display_column name
 */
export type Material = {
  id: number
  createdAt: Date
  updatedAt: Date
  isDeleted: boolean
  /**
   * @schema.title 物料名
   */
  name: string
  /**
   * @schema.title 物料描述
   */
  description: string | null
}

/**
 * Model MaterialSpec
 * @schema.primary_key id
 * @schema.display_name 物料规格
 */
export type MaterialSpec = {
  id: number
  createdAt: Date
  updatedAt: Date
  isDeleted: boolean
  /**
   * @schema.title 规格名
   */
  name: string
  /**
   * @schema.title 规格描述
   */
  description: string | null
  /**
   * @schema.reference Material
   */
  materialId: number
}

/**
 * Model Operation
 * @schema.primary_key id
 * @schema.display_name 工序
 * @schema.display_column name
 */
export type Operation = {
  id: number
  createdAt: Date
  updatedAt: Date
  isDeleted: boolean
  /**
   * @schema.title 工序名
   */
  name: string
  /**
   * @schema.title 工序描述
   */
  description: string | null
  /**
   * @schema.reference Material
   */
  materialId: number
}

/**
 * Model OperationSpec
 * @schema.primary_key id
 * @schema.display_name 工序规格
 */
export type OperationSpec = {
  id: number
  createdAt: Date
  updatedAt: Date
  isDeleted: boolean
  /**
   * @schema.title 规格名
   */
  name: string
  /**
   * @schema.title 规格描述
   */
  description: string | null
  /**
   * @schema.reference Operation
   */
  operationId: number
}

/**
 * Model IncomingInspectRecord
 * @schema.primary_key id
 * @schema.display_name 进料检记录
 */
export type IncomingInspectRecord = {
  id: number
  createdAt: Date
  updatedAt: Date
  isDeleted: boolean
  /**
   * @schema.title 零件批号
   */
  lot: string
  /**
   * @schema.reference Material
   */
  materialId: number
  /**
   * @schema.title 备注
   */
  description: string | null
  inspectorId: number
  reviewerId: number
  /**
   * @schema.title 判定
   */
  result: IncomingInspectResult
}

/**
 * Model MaterialSpecInspect
 * @schema.primary_key id
 * @schema.display_name 进料检记录详情
 */
export type MaterialSpecInspect = {
  id: number
  createdAt: Date
  updatedAt: Date
  isDeleted: boolean
  recordId: number
  specId: number
  /**
   * @schema.title 备注
   */
  description: string | null
  /**
   * @schema.title 结果
   */
  result: boolean
}

/**
 * Model InProcessInspectRecord
 * @schema.primary_key id
 * @schema.display_name 过程检记录
 */
export type InProcessInspectRecord = {
  id: number
  createdAt: Date
  updatedAt: Date
  isDeleted: boolean
  /**
   * @schema.title 生产批号
   */
  lot: string
  /**
   * @schema.title 备注
   */
  description: string | null
  materialId: number
  inspectorId: number
  reviewerId: number
}

/**
 * Model OperationSpecInspect
 * @schema.primary_key id
 * @schema.display_name 过程检记录
 */
export type OperationSpecInspect = {
  id: number
  createdAt: Date
  updatedAt: Date
  isDeleted: boolean
  specId: number
  /**
   * @schema.title 首检
   */
  first: string
  /**
   * @schema.title 过程检
   */
  inProcess: string
  /**
   * @schema.title 末检
   */
  final: string
}


/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export const IncomingInspectResult: {
  ACCEPT: 'ACCEPT',
  RETURN: 'RETURN',
  DOWNGRADE: 'DOWNGRADE'
};

export type IncomingInspectResult = (typeof IncomingInspectResult)[keyof typeof IncomingInspectResult]


export const RepairRecordStatus: {
  TO_ASSIGN: 'TO_ASSIGN',
  DOING: 'DOING',
  TO_REVIEW: 'TO_REVIEW',
  DONE: 'DONE'
};

export type RepairRecordStatus = (typeof RepairRecordStatus)[keyof typeof RepairRecordStatus]


export const RepairType: {
  SCHEDULE: 'SCHEDULE',
  UNSCHEDULE: 'UNSCHEDULE'
};

export type RepairType = (typeof RepairType)[keyof typeof RepairType]


export const UserGroup: {
  ADMIN: 'ADMIN',
  USER: 'USER'
};

export type UserGroup = (typeof UserGroup)[keyof typeof UserGroup]


export const UserStatus: {
  ACTIVE: 'ACTIVE',
  FORBIDDEN: 'FORBIDDEN'
};

export type UserStatus = (typeof UserStatus)[keyof typeof UserStatus]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more TaskFormRelations
 * const taskFormRelations = await prisma.taskFormRelation.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more TaskFormRelations
   * const taskFormRelations = await prisma.taskFormRelation.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<this, "$connect" | "$disconnect" | "$on" | "$transaction" | "$use">) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>

      /**
   * `prisma.taskFormRelation`: Exposes CRUD operations for the **TaskFormRelation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskFormRelations
    * const taskFormRelations = await prisma.taskFormRelation.findMany()
    * ```
    */
  get taskFormRelation(): Prisma.TaskFormRelationDelegate<GlobalReject>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject>;

  /**
   * `prisma.userProfile`: Exposes CRUD operations for the **UserProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserProfiles
    * const userProfiles = await prisma.userProfile.findMany()
    * ```
    */
  get userProfile(): Prisma.UserProfileDelegate<GlobalReject>;

  /**
   * `prisma.productLine`: Exposes CRUD operations for the **ProductLine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductLines
    * const productLines = await prisma.productLine.findMany()
    * ```
    */
  get productLine(): Prisma.ProductLineDelegate<GlobalReject>;

  /**
   * `prisma.equipment`: Exposes CRUD operations for the **Equipment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Equipment
    * const equipment = await prisma.equipment.findMany()
    * ```
    */
  get equipment(): Prisma.EquipmentDelegate<GlobalReject>;

  /**
   * `prisma.repairMaterial`: Exposes CRUD operations for the **RepairMaterial** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RepairMaterials
    * const repairMaterials = await prisma.repairMaterial.findMany()
    * ```
    */
  get repairMaterial(): Prisma.RepairMaterialDelegate<GlobalReject>;

  /**
   * `prisma.repairPlan`: Exposes CRUD operations for the **RepairPlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RepairPlans
    * const repairPlans = await prisma.repairPlan.findMany()
    * ```
    */
  get repairPlan(): Prisma.RepairPlanDelegate<GlobalReject>;

  /**
   * `prisma.repairMaterialInventory`: Exposes CRUD operations for the **RepairMaterialInventory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RepairMaterialInventories
    * const repairMaterialInventories = await prisma.repairMaterialInventory.findMany()
    * ```
    */
  get repairMaterialInventory(): Prisma.RepairMaterialInventoryDelegate<GlobalReject>;

  /**
   * `prisma.repairRecord`: Exposes CRUD operations for the **RepairRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RepairRecords
    * const repairRecords = await prisma.repairRecord.findMany()
    * ```
    */
  get repairRecord(): Prisma.RepairRecordDelegate<GlobalReject>;

  /**
   * `prisma.material`: Exposes CRUD operations for the **Material** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Materials
    * const materials = await prisma.material.findMany()
    * ```
    */
  get material(): Prisma.MaterialDelegate<GlobalReject>;

  /**
   * `prisma.materialSpec`: Exposes CRUD operations for the **MaterialSpec** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MaterialSpecs
    * const materialSpecs = await prisma.materialSpec.findMany()
    * ```
    */
  get materialSpec(): Prisma.MaterialSpecDelegate<GlobalReject>;

  /**
   * `prisma.operation`: Exposes CRUD operations for the **Operation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Operations
    * const operations = await prisma.operation.findMany()
    * ```
    */
  get operation(): Prisma.OperationDelegate<GlobalReject>;

  /**
   * `prisma.operationSpec`: Exposes CRUD operations for the **OperationSpec** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OperationSpecs
    * const operationSpecs = await prisma.operationSpec.findMany()
    * ```
    */
  get operationSpec(): Prisma.OperationSpecDelegate<GlobalReject>;

  /**
   * `prisma.incomingInspectRecord`: Exposes CRUD operations for the **IncomingInspectRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IncomingInspectRecords
    * const incomingInspectRecords = await prisma.incomingInspectRecord.findMany()
    * ```
    */
  get incomingInspectRecord(): Prisma.IncomingInspectRecordDelegate<GlobalReject>;

  /**
   * `prisma.materialSpecInspect`: Exposes CRUD operations for the **MaterialSpecInspect** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MaterialSpecInspects
    * const materialSpecInspects = await prisma.materialSpecInspect.findMany()
    * ```
    */
  get materialSpecInspect(): Prisma.MaterialSpecInspectDelegate<GlobalReject>;

  /**
   * `prisma.inProcessInspectRecord`: Exposes CRUD operations for the **InProcessInspectRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InProcessInspectRecords
    * const inProcessInspectRecords = await prisma.inProcessInspectRecord.findMany()
    * ```
    */
  get inProcessInspectRecord(): Prisma.InProcessInspectRecordDelegate<GlobalReject>;

  /**
   * `prisma.operationSpecInspect`: Exposes CRUD operations for the **OperationSpecInspect** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OperationSpecInspects
    * const operationSpecInspects = await prisma.operationSpecInspect.findMany()
    * ```
    */
  get operationSpecInspect(): Prisma.OperationSpecInspectDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket


  /**
   * Prisma Client JS version: 4.14.0
   * Query Engine version: d9a4c5988f480fa576d43970d5a23641aa77bc9c
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: runtime.Types.Utils.LegacyExact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    TaskFormRelation: 'TaskFormRelation',
    User: 'User',
    UserProfile: 'UserProfile',
    ProductLine: 'ProductLine',
    Equipment: 'Equipment',
    RepairMaterial: 'RepairMaterial',
    RepairPlan: 'RepairPlan',
    RepairMaterialInventory: 'RepairMaterialInventory',
    RepairRecord: 'RepairRecord',
    Material: 'Material',
    MaterialSpec: 'MaterialSpec',
    Operation: 'Operation',
    OperationSpec: 'OperationSpec',
    IncomingInspectRecord: 'IncomingInspectRecord',
    MaterialSpecInspect: 'MaterialSpecInspect',
    InProcessInspectRecord: 'InProcessInspectRecord',
    OperationSpecInspect: 'OperationSpecInspect'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, '$connect' | '$disconnect' | '$on' | '$transaction' | '$use'>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */


  export type UserCountOutputType = {
    incomingInspectedRecords: number
    incomingReviewedRecords: number
    inProcessInspectedRecord: number
    inProcessReviewedRecord: number
  }

  export type UserCountOutputTypeSelect = {
    incomingInspectedRecords?: boolean
    incomingReviewedRecords?: boolean
    inProcessInspectedRecord?: boolean
    inProcessReviewedRecord?: boolean
  }

  export type UserCountOutputTypeGetPayload<S extends boolean | null | undefined | UserCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? UserCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (UserCountOutputTypeArgs)
    ? UserCountOutputType 
    : S extends { select: any } & (UserCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof UserCountOutputType ? UserCountOutputType[P] : never
  } 
      : UserCountOutputType




  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect | null
  }



  /**
   * Count Type ProductLineCountOutputType
   */


  export type ProductLineCountOutputType = {
    equipment: number
  }

  export type ProductLineCountOutputTypeSelect = {
    equipment?: boolean
  }

  export type ProductLineCountOutputTypeGetPayload<S extends boolean | null | undefined | ProductLineCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ProductLineCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ProductLineCountOutputTypeArgs)
    ? ProductLineCountOutputType 
    : S extends { select: any } & (ProductLineCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ProductLineCountOutputType ? ProductLineCountOutputType[P] : never
  } 
      : ProductLineCountOutputType




  // Custom InputTypes

  /**
   * ProductLineCountOutputType without action
   */
  export type ProductLineCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ProductLineCountOutputType
     */
    select?: ProductLineCountOutputTypeSelect | null
  }



  /**
   * Count Type EquipmentCountOutputType
   */


  export type EquipmentCountOutputType = {
    records: number
  }

  export type EquipmentCountOutputTypeSelect = {
    records?: boolean
  }

  export type EquipmentCountOutputTypeGetPayload<S extends boolean | null | undefined | EquipmentCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? EquipmentCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (EquipmentCountOutputTypeArgs)
    ? EquipmentCountOutputType 
    : S extends { select: any } & (EquipmentCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof EquipmentCountOutputType ? EquipmentCountOutputType[P] : never
  } 
      : EquipmentCountOutputType




  // Custom InputTypes

  /**
   * EquipmentCountOutputType without action
   */
  export type EquipmentCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the EquipmentCountOutputType
     */
    select?: EquipmentCountOutputTypeSelect | null
  }



  /**
   * Count Type MaterialCountOutputType
   */


  export type MaterialCountOutputType = {
    specs: number
    operations: number
    incomingInspectRecord: number
    inProcessInspectRecord: number
  }

  export type MaterialCountOutputTypeSelect = {
    specs?: boolean
    operations?: boolean
    incomingInspectRecord?: boolean
    inProcessInspectRecord?: boolean
  }

  export type MaterialCountOutputTypeGetPayload<S extends boolean | null | undefined | MaterialCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? MaterialCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (MaterialCountOutputTypeArgs)
    ? MaterialCountOutputType 
    : S extends { select: any } & (MaterialCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof MaterialCountOutputType ? MaterialCountOutputType[P] : never
  } 
      : MaterialCountOutputType




  // Custom InputTypes

  /**
   * MaterialCountOutputType without action
   */
  export type MaterialCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the MaterialCountOutputType
     */
    select?: MaterialCountOutputTypeSelect | null
  }



  /**
   * Count Type MaterialSpecCountOutputType
   */


  export type MaterialSpecCountOutputType = {
    inspects: number
  }

  export type MaterialSpecCountOutputTypeSelect = {
    inspects?: boolean
  }

  export type MaterialSpecCountOutputTypeGetPayload<S extends boolean | null | undefined | MaterialSpecCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? MaterialSpecCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (MaterialSpecCountOutputTypeArgs)
    ? MaterialSpecCountOutputType 
    : S extends { select: any } & (MaterialSpecCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof MaterialSpecCountOutputType ? MaterialSpecCountOutputType[P] : never
  } 
      : MaterialSpecCountOutputType




  // Custom InputTypes

  /**
   * MaterialSpecCountOutputType without action
   */
  export type MaterialSpecCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the MaterialSpecCountOutputType
     */
    select?: MaterialSpecCountOutputTypeSelect | null
  }



  /**
   * Count Type OperationCountOutputType
   */


  export type OperationCountOutputType = {
    specs: number
  }

  export type OperationCountOutputTypeSelect = {
    specs?: boolean
  }

  export type OperationCountOutputTypeGetPayload<S extends boolean | null | undefined | OperationCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? OperationCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (OperationCountOutputTypeArgs)
    ? OperationCountOutputType 
    : S extends { select: any } & (OperationCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof OperationCountOutputType ? OperationCountOutputType[P] : never
  } 
      : OperationCountOutputType




  // Custom InputTypes

  /**
   * OperationCountOutputType without action
   */
  export type OperationCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the OperationCountOutputType
     */
    select?: OperationCountOutputTypeSelect | null
  }



  /**
   * Count Type OperationSpecCountOutputType
   */


  export type OperationSpecCountOutputType = {
    inspect: number
  }

  export type OperationSpecCountOutputTypeSelect = {
    inspect?: boolean
  }

  export type OperationSpecCountOutputTypeGetPayload<S extends boolean | null | undefined | OperationSpecCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? OperationSpecCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (OperationSpecCountOutputTypeArgs)
    ? OperationSpecCountOutputType 
    : S extends { select: any } & (OperationSpecCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof OperationSpecCountOutputType ? OperationSpecCountOutputType[P] : never
  } 
      : OperationSpecCountOutputType




  // Custom InputTypes

  /**
   * OperationSpecCountOutputType without action
   */
  export type OperationSpecCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the OperationSpecCountOutputType
     */
    select?: OperationSpecCountOutputTypeSelect | null
  }



  /**
   * Count Type IncomingInspectRecordCountOutputType
   */


  export type IncomingInspectRecordCountOutputType = {
    details: number
  }

  export type IncomingInspectRecordCountOutputTypeSelect = {
    details?: boolean
  }

  export type IncomingInspectRecordCountOutputTypeGetPayload<S extends boolean | null | undefined | IncomingInspectRecordCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? IncomingInspectRecordCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (IncomingInspectRecordCountOutputTypeArgs)
    ? IncomingInspectRecordCountOutputType 
    : S extends { select: any } & (IncomingInspectRecordCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof IncomingInspectRecordCountOutputType ? IncomingInspectRecordCountOutputType[P] : never
  } 
      : IncomingInspectRecordCountOutputType




  // Custom InputTypes

  /**
   * IncomingInspectRecordCountOutputType without action
   */
  export type IncomingInspectRecordCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the IncomingInspectRecordCountOutputType
     */
    select?: IncomingInspectRecordCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model TaskFormRelation
   */


  export type AggregateTaskFormRelation = {
    _count: TaskFormRelationCountAggregateOutputType | null
    _avg: TaskFormRelationAvgAggregateOutputType | null
    _sum: TaskFormRelationSumAggregateOutputType | null
    _min: TaskFormRelationMinAggregateOutputType | null
    _max: TaskFormRelationMaxAggregateOutputType | null
  }

  export type TaskFormRelationAvgAggregateOutputType = {
    id: number | null
  }

  export type TaskFormRelationSumAggregateOutputType = {
    id: number | null
  }

  export type TaskFormRelationMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    taskDefinitionKey: string | null
    formKey: string | null
  }

  export type TaskFormRelationMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    taskDefinitionKey: string | null
    formKey: string | null
  }

  export type TaskFormRelationCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    isDeleted: number
    taskDefinitionKey: number
    formKey: number
    _all: number
  }


  export type TaskFormRelationAvgAggregateInputType = {
    id?: true
  }

  export type TaskFormRelationSumAggregateInputType = {
    id?: true
  }

  export type TaskFormRelationMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    taskDefinitionKey?: true
    formKey?: true
  }

  export type TaskFormRelationMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    taskDefinitionKey?: true
    formKey?: true
  }

  export type TaskFormRelationCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    taskDefinitionKey?: true
    formKey?: true
    _all?: true
  }

  export type TaskFormRelationAggregateArgs = {
    /**
     * Filter which TaskFormRelation to aggregate.
     */
    where?: TaskFormRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskFormRelations to fetch.
     */
    orderBy?: Enumerable<TaskFormRelationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskFormRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskFormRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskFormRelations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskFormRelations
    **/
    _count?: true | TaskFormRelationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaskFormRelationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaskFormRelationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskFormRelationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskFormRelationMaxAggregateInputType
  }

  export type GetTaskFormRelationAggregateType<T extends TaskFormRelationAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskFormRelation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskFormRelation[P]>
      : GetScalarType<T[P], AggregateTaskFormRelation[P]>
  }




  export type TaskFormRelationGroupByArgs = {
    where?: TaskFormRelationWhereInput
    orderBy?: Enumerable<TaskFormRelationOrderByWithAggregationInput>
    by: TaskFormRelationScalarFieldEnum[]
    having?: TaskFormRelationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskFormRelationCountAggregateInputType | true
    _avg?: TaskFormRelationAvgAggregateInputType
    _sum?: TaskFormRelationSumAggregateInputType
    _min?: TaskFormRelationMinAggregateInputType
    _max?: TaskFormRelationMaxAggregateInputType
  }


  export type TaskFormRelationGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    isDeleted: boolean
    taskDefinitionKey: string
    formKey: string
    _count: TaskFormRelationCountAggregateOutputType | null
    _avg: TaskFormRelationAvgAggregateOutputType | null
    _sum: TaskFormRelationSumAggregateOutputType | null
    _min: TaskFormRelationMinAggregateOutputType | null
    _max: TaskFormRelationMaxAggregateOutputType | null
  }

  type GetTaskFormRelationGroupByPayload<T extends TaskFormRelationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TaskFormRelationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskFormRelationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskFormRelationGroupByOutputType[P]>
            : GetScalarType<T[P], TaskFormRelationGroupByOutputType[P]>
        }
      >
    >


  export type TaskFormRelationSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    taskDefinitionKey?: boolean
    formKey?: boolean
  }


  export type TaskFormRelationGetPayload<S extends boolean | null | undefined | TaskFormRelationArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TaskFormRelation :
    S extends undefined ? never :
    S extends { include: any } & (TaskFormRelationArgs | TaskFormRelationFindManyArgs)
    ? TaskFormRelation 
    : S extends { select: any } & (TaskFormRelationArgs | TaskFormRelationFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TaskFormRelation ? TaskFormRelation[P] : never
  } 
      : TaskFormRelation


  type TaskFormRelationCountArgs = 
    Omit<TaskFormRelationFindManyArgs, 'select' | 'include'> & {
      select?: TaskFormRelationCountAggregateInputType | true
    }

  export interface TaskFormRelationDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one TaskFormRelation that matches the filter.
     * @param {TaskFormRelationFindUniqueArgs} args - Arguments to find a TaskFormRelation
     * @example
     * // Get one TaskFormRelation
     * const taskFormRelation = await prisma.taskFormRelation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TaskFormRelationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TaskFormRelationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TaskFormRelation'> extends True ? Prisma__TaskFormRelationClient<TaskFormRelationGetPayload<T>> : Prisma__TaskFormRelationClient<TaskFormRelationGetPayload<T> | null, null>

    /**
     * Find one TaskFormRelation that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TaskFormRelationFindUniqueOrThrowArgs} args - Arguments to find a TaskFormRelation
     * @example
     * // Get one TaskFormRelation
     * const taskFormRelation = await prisma.taskFormRelation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TaskFormRelationFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TaskFormRelationFindUniqueOrThrowArgs>
    ): Prisma__TaskFormRelationClient<TaskFormRelationGetPayload<T>>

    /**
     * Find the first TaskFormRelation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFormRelationFindFirstArgs} args - Arguments to find a TaskFormRelation
     * @example
     * // Get one TaskFormRelation
     * const taskFormRelation = await prisma.taskFormRelation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TaskFormRelationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TaskFormRelationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TaskFormRelation'> extends True ? Prisma__TaskFormRelationClient<TaskFormRelationGetPayload<T>> : Prisma__TaskFormRelationClient<TaskFormRelationGetPayload<T> | null, null>

    /**
     * Find the first TaskFormRelation that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFormRelationFindFirstOrThrowArgs} args - Arguments to find a TaskFormRelation
     * @example
     * // Get one TaskFormRelation
     * const taskFormRelation = await prisma.taskFormRelation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TaskFormRelationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TaskFormRelationFindFirstOrThrowArgs>
    ): Prisma__TaskFormRelationClient<TaskFormRelationGetPayload<T>>

    /**
     * Find zero or more TaskFormRelations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFormRelationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskFormRelations
     * const taskFormRelations = await prisma.taskFormRelation.findMany()
     * 
     * // Get first 10 TaskFormRelations
     * const taskFormRelations = await prisma.taskFormRelation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskFormRelationWithIdOnly = await prisma.taskFormRelation.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TaskFormRelationFindManyArgs>(
      args?: SelectSubset<T, TaskFormRelationFindManyArgs>
    ): Prisma.PrismaPromise<Array<TaskFormRelationGetPayload<T>>>

    /**
     * Create a TaskFormRelation.
     * @param {TaskFormRelationCreateArgs} args - Arguments to create a TaskFormRelation.
     * @example
     * // Create one TaskFormRelation
     * const TaskFormRelation = await prisma.taskFormRelation.create({
     *   data: {
     *     // ... data to create a TaskFormRelation
     *   }
     * })
     * 
    **/
    create<T extends TaskFormRelationCreateArgs>(
      args: SelectSubset<T, TaskFormRelationCreateArgs>
    ): Prisma__TaskFormRelationClient<TaskFormRelationGetPayload<T>>

    /**
     * Create many TaskFormRelations.
     *     @param {TaskFormRelationCreateManyArgs} args - Arguments to create many TaskFormRelations.
     *     @example
     *     // Create many TaskFormRelations
     *     const taskFormRelation = await prisma.taskFormRelation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TaskFormRelationCreateManyArgs>(
      args?: SelectSubset<T, TaskFormRelationCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TaskFormRelation.
     * @param {TaskFormRelationDeleteArgs} args - Arguments to delete one TaskFormRelation.
     * @example
     * // Delete one TaskFormRelation
     * const TaskFormRelation = await prisma.taskFormRelation.delete({
     *   where: {
     *     // ... filter to delete one TaskFormRelation
     *   }
     * })
     * 
    **/
    delete<T extends TaskFormRelationDeleteArgs>(
      args: SelectSubset<T, TaskFormRelationDeleteArgs>
    ): Prisma__TaskFormRelationClient<TaskFormRelationGetPayload<T>>

    /**
     * Update one TaskFormRelation.
     * @param {TaskFormRelationUpdateArgs} args - Arguments to update one TaskFormRelation.
     * @example
     * // Update one TaskFormRelation
     * const taskFormRelation = await prisma.taskFormRelation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TaskFormRelationUpdateArgs>(
      args: SelectSubset<T, TaskFormRelationUpdateArgs>
    ): Prisma__TaskFormRelationClient<TaskFormRelationGetPayload<T>>

    /**
     * Delete zero or more TaskFormRelations.
     * @param {TaskFormRelationDeleteManyArgs} args - Arguments to filter TaskFormRelations to delete.
     * @example
     * // Delete a few TaskFormRelations
     * const { count } = await prisma.taskFormRelation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TaskFormRelationDeleteManyArgs>(
      args?: SelectSubset<T, TaskFormRelationDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskFormRelations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFormRelationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskFormRelations
     * const taskFormRelation = await prisma.taskFormRelation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TaskFormRelationUpdateManyArgs>(
      args: SelectSubset<T, TaskFormRelationUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TaskFormRelation.
     * @param {TaskFormRelationUpsertArgs} args - Arguments to update or create a TaskFormRelation.
     * @example
     * // Update or create a TaskFormRelation
     * const taskFormRelation = await prisma.taskFormRelation.upsert({
     *   create: {
     *     // ... data to create a TaskFormRelation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskFormRelation we want to update
     *   }
     * })
    **/
    upsert<T extends TaskFormRelationUpsertArgs>(
      args: SelectSubset<T, TaskFormRelationUpsertArgs>
    ): Prisma__TaskFormRelationClient<TaskFormRelationGetPayload<T>>

    /**
     * Count the number of TaskFormRelations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFormRelationCountArgs} args - Arguments to filter TaskFormRelations to count.
     * @example
     * // Count the number of TaskFormRelations
     * const count = await prisma.taskFormRelation.count({
     *   where: {
     *     // ... the filter for the TaskFormRelations we want to count
     *   }
     * })
    **/
    count<T extends TaskFormRelationCountArgs>(
      args?: Subset<T, TaskFormRelationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskFormRelationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskFormRelation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFormRelationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskFormRelationAggregateArgs>(args: Subset<T, TaskFormRelationAggregateArgs>): Prisma.PrismaPromise<GetTaskFormRelationAggregateType<T>>

    /**
     * Group by TaskFormRelation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFormRelationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskFormRelationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskFormRelationGroupByArgs['orderBy'] }
        : { orderBy?: TaskFormRelationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskFormRelationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskFormRelationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskFormRelation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TaskFormRelationClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TaskFormRelation base type for findUnique actions
   */
  export type TaskFormRelationFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TaskFormRelation
     */
    select?: TaskFormRelationSelect | null
    /**
     * Filter, which TaskFormRelation to fetch.
     */
    where: TaskFormRelationWhereUniqueInput
  }

  /**
   * TaskFormRelation findUnique
   */
  export interface TaskFormRelationFindUniqueArgs extends TaskFormRelationFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TaskFormRelation findUniqueOrThrow
   */
  export type TaskFormRelationFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TaskFormRelation
     */
    select?: TaskFormRelationSelect | null
    /**
     * Filter, which TaskFormRelation to fetch.
     */
    where: TaskFormRelationWhereUniqueInput
  }


  /**
   * TaskFormRelation base type for findFirst actions
   */
  export type TaskFormRelationFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TaskFormRelation
     */
    select?: TaskFormRelationSelect | null
    /**
     * Filter, which TaskFormRelation to fetch.
     */
    where?: TaskFormRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskFormRelations to fetch.
     */
    orderBy?: Enumerable<TaskFormRelationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskFormRelations.
     */
    cursor?: TaskFormRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskFormRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskFormRelations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskFormRelations.
     */
    distinct?: Enumerable<TaskFormRelationScalarFieldEnum>
  }

  /**
   * TaskFormRelation findFirst
   */
  export interface TaskFormRelationFindFirstArgs extends TaskFormRelationFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TaskFormRelation findFirstOrThrow
   */
  export type TaskFormRelationFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TaskFormRelation
     */
    select?: TaskFormRelationSelect | null
    /**
     * Filter, which TaskFormRelation to fetch.
     */
    where?: TaskFormRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskFormRelations to fetch.
     */
    orderBy?: Enumerable<TaskFormRelationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskFormRelations.
     */
    cursor?: TaskFormRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskFormRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskFormRelations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskFormRelations.
     */
    distinct?: Enumerable<TaskFormRelationScalarFieldEnum>
  }


  /**
   * TaskFormRelation findMany
   */
  export type TaskFormRelationFindManyArgs = {
    /**
     * Select specific fields to fetch from the TaskFormRelation
     */
    select?: TaskFormRelationSelect | null
    /**
     * Filter, which TaskFormRelations to fetch.
     */
    where?: TaskFormRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskFormRelations to fetch.
     */
    orderBy?: Enumerable<TaskFormRelationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskFormRelations.
     */
    cursor?: TaskFormRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskFormRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskFormRelations.
     */
    skip?: number
    distinct?: Enumerable<TaskFormRelationScalarFieldEnum>
  }


  /**
   * TaskFormRelation create
   */
  export type TaskFormRelationCreateArgs = {
    /**
     * Select specific fields to fetch from the TaskFormRelation
     */
    select?: TaskFormRelationSelect | null
    /**
     * The data needed to create a TaskFormRelation.
     */
    data: XOR<TaskFormRelationCreateInput, TaskFormRelationUncheckedCreateInput>
  }


  /**
   * TaskFormRelation createMany
   */
  export type TaskFormRelationCreateManyArgs = {
    /**
     * The data used to create many TaskFormRelations.
     */
    data: Enumerable<TaskFormRelationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TaskFormRelation update
   */
  export type TaskFormRelationUpdateArgs = {
    /**
     * Select specific fields to fetch from the TaskFormRelation
     */
    select?: TaskFormRelationSelect | null
    /**
     * The data needed to update a TaskFormRelation.
     */
    data: XOR<TaskFormRelationUpdateInput, TaskFormRelationUncheckedUpdateInput>
    /**
     * Choose, which TaskFormRelation to update.
     */
    where: TaskFormRelationWhereUniqueInput
  }


  /**
   * TaskFormRelation updateMany
   */
  export type TaskFormRelationUpdateManyArgs = {
    /**
     * The data used to update TaskFormRelations.
     */
    data: XOR<TaskFormRelationUpdateManyMutationInput, TaskFormRelationUncheckedUpdateManyInput>
    /**
     * Filter which TaskFormRelations to update
     */
    where?: TaskFormRelationWhereInput
  }


  /**
   * TaskFormRelation upsert
   */
  export type TaskFormRelationUpsertArgs = {
    /**
     * Select specific fields to fetch from the TaskFormRelation
     */
    select?: TaskFormRelationSelect | null
    /**
     * The filter to search for the TaskFormRelation to update in case it exists.
     */
    where: TaskFormRelationWhereUniqueInput
    /**
     * In case the TaskFormRelation found by the `where` argument doesn't exist, create a new TaskFormRelation with this data.
     */
    create: XOR<TaskFormRelationCreateInput, TaskFormRelationUncheckedCreateInput>
    /**
     * In case the TaskFormRelation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskFormRelationUpdateInput, TaskFormRelationUncheckedUpdateInput>
  }


  /**
   * TaskFormRelation delete
   */
  export type TaskFormRelationDeleteArgs = {
    /**
     * Select specific fields to fetch from the TaskFormRelation
     */
    select?: TaskFormRelationSelect | null
    /**
     * Filter which TaskFormRelation to delete.
     */
    where: TaskFormRelationWhereUniqueInput
  }


  /**
   * TaskFormRelation deleteMany
   */
  export type TaskFormRelationDeleteManyArgs = {
    /**
     * Filter which TaskFormRelations to delete
     */
    where?: TaskFormRelationWhereInput
  }


  /**
   * TaskFormRelation without action
   */
  export type TaskFormRelationArgs = {
    /**
     * Select specific fields to fetch from the TaskFormRelation
     */
    select?: TaskFormRelationSelect | null
  }



  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    username: string | null
    hashedPassword: string | null
    hashedRefreshToken: string | null
    status: UserStatus | null
    role: UserGroup | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    username: string | null
    hashedPassword: string | null
    hashedRefreshToken: string | null
    status: UserStatus | null
    role: UserGroup | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    isDeleted: number
    username: number
    hashedPassword: number
    hashedRefreshToken: number
    status: number
    role: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    username?: true
    hashedPassword?: true
    hashedRefreshToken?: true
    status?: true
    role?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    username?: true
    hashedPassword?: true
    hashedRefreshToken?: true
    status?: true
    role?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    username?: true
    hashedPassword?: true
    hashedRefreshToken?: true
    status?: true
    role?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithAggregationInput>
    by: UserScalarFieldEnum[]
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    isDeleted: boolean
    username: string
    hashedPassword: string | null
    hashedRefreshToken: string | null
    status: UserStatus
    role: UserGroup
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    username?: boolean
    hashedPassword?: boolean
    hashedRefreshToken?: boolean
    status?: boolean
    role?: boolean
    profile?: boolean | UserProfileArgs
    incomingInspectedRecords?: boolean | User$incomingInspectedRecordsArgs
    incomingReviewedRecords?: boolean | User$incomingReviewedRecordsArgs
    inProcessInspectedRecord?: boolean | User$inProcessInspectedRecordArgs
    inProcessReviewedRecord?: boolean | User$inProcessReviewedRecordArgs
    _count?: boolean | UserCountOutputTypeArgs
  }


  export type UserInclude = {
    profile?: boolean | UserProfileArgs
    incomingInspectedRecords?: boolean | User$incomingInspectedRecordsArgs
    incomingReviewedRecords?: boolean | User$incomingReviewedRecordsArgs
    inProcessInspectedRecord?: boolean | User$inProcessInspectedRecordArgs
    inProcessReviewedRecord?: boolean | User$inProcessReviewedRecordArgs
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type UserGetPayload<S extends boolean | null | undefined | UserArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? User :
    S extends undefined ? never :
    S extends { include: any } & (UserArgs | UserFindManyArgs)
    ? User  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'profile' ? UserProfileGetPayload<S['include'][P]> | null :
        P extends 'incomingInspectedRecords' ? Array < IncomingInspectRecordGetPayload<S['include'][P]>>  :
        P extends 'incomingReviewedRecords' ? Array < IncomingInspectRecordGetPayload<S['include'][P]>>  :
        P extends 'inProcessInspectedRecord' ? Array < InProcessInspectRecordGetPayload<S['include'][P]>>  :
        P extends 'inProcessReviewedRecord' ? Array < InProcessInspectRecordGetPayload<S['include'][P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (UserArgs | UserFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'profile' ? UserProfileGetPayload<S['select'][P]> | null :
        P extends 'incomingInspectedRecords' ? Array < IncomingInspectRecordGetPayload<S['select'][P]>>  :
        P extends 'incomingReviewedRecords' ? Array < IncomingInspectRecordGetPayload<S['select'][P]>>  :
        P extends 'inProcessInspectedRecord' ? Array < InProcessInspectRecordGetPayload<S['select'][P]>>  :
        P extends 'inProcessReviewedRecord' ? Array < InProcessInspectRecordGetPayload<S['select'][P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof User ? User[P] : never
  } 
      : User


  type UserCountArgs = 
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? Prisma__UserClient<UserGetPayload<T>> : Prisma__UserClient<UserGetPayload<T> | null, null>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? Prisma__UserClient<UserGetPayload<T>> : Prisma__UserClient<UserGetPayload<T> | null, null>

    /**
     * Find the first User that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs>
    ): Prisma.PrismaPromise<Array<UserGetPayload<T>>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    profile<T extends UserProfileArgs= {}>(args?: Subset<T, UserProfileArgs>): Prisma__UserProfileClient<UserProfileGetPayload<T> | Null>;

    incomingInspectedRecords<T extends User$incomingInspectedRecordsArgs= {}>(args?: Subset<T, User$incomingInspectedRecordsArgs>): Prisma.PrismaPromise<Array<IncomingInspectRecordGetPayload<T>>| Null>;

    incomingReviewedRecords<T extends User$incomingReviewedRecordsArgs= {}>(args?: Subset<T, User$incomingReviewedRecordsArgs>): Prisma.PrismaPromise<Array<IncomingInspectRecordGetPayload<T>>| Null>;

    inProcessInspectedRecord<T extends User$inProcessInspectedRecordArgs= {}>(args?: Subset<T, User$inProcessInspectedRecordArgs>): Prisma.PrismaPromise<Array<InProcessInspectRecordGetPayload<T>>| Null>;

    inProcessReviewedRecord<T extends User$inProcessReviewedRecordArgs= {}>(args?: Subset<T, User$inProcessReviewedRecordArgs>): Prisma.PrismaPromise<Array<InProcessInspectRecordGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * User base type for findUnique actions
   */
  export type UserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUnique
   */
  export interface UserFindUniqueArgs extends UserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User base type for findFirst actions
   */
  export type UserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }

  /**
   * User findFirst
   */
  export interface UserFindFirstArgs extends UserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs = {
    /**
     * The data used to create many Users.
     */
    data: Enumerable<UserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User.incomingInspectedRecords
   */
  export type User$incomingInspectedRecordsArgs = {
    /**
     * Select specific fields to fetch from the IncomingInspectRecord
     */
    select?: IncomingInspectRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IncomingInspectRecordInclude | null
    where?: IncomingInspectRecordWhereInput
    orderBy?: Enumerable<IncomingInspectRecordOrderByWithRelationInput>
    cursor?: IncomingInspectRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<IncomingInspectRecordScalarFieldEnum>
  }


  /**
   * User.incomingReviewedRecords
   */
  export type User$incomingReviewedRecordsArgs = {
    /**
     * Select specific fields to fetch from the IncomingInspectRecord
     */
    select?: IncomingInspectRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IncomingInspectRecordInclude | null
    where?: IncomingInspectRecordWhereInput
    orderBy?: Enumerable<IncomingInspectRecordOrderByWithRelationInput>
    cursor?: IncomingInspectRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<IncomingInspectRecordScalarFieldEnum>
  }


  /**
   * User.inProcessInspectedRecord
   */
  export type User$inProcessInspectedRecordArgs = {
    /**
     * Select specific fields to fetch from the InProcessInspectRecord
     */
    select?: InProcessInspectRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InProcessInspectRecordInclude | null
    where?: InProcessInspectRecordWhereInput
    orderBy?: Enumerable<InProcessInspectRecordOrderByWithRelationInput>
    cursor?: InProcessInspectRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<InProcessInspectRecordScalarFieldEnum>
  }


  /**
   * User.inProcessReviewedRecord
   */
  export type User$inProcessReviewedRecordArgs = {
    /**
     * Select specific fields to fetch from the InProcessInspectRecord
     */
    select?: InProcessInspectRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InProcessInspectRecordInclude | null
    where?: InProcessInspectRecordWhereInput
    orderBy?: Enumerable<InProcessInspectRecordOrderByWithRelationInput>
    cursor?: InProcessInspectRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<InProcessInspectRecordScalarFieldEnum>
  }


  /**
   * User without action
   */
  export type UserArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
  }



  /**
   * Model UserProfile
   */


  export type AggregateUserProfile = {
    _count: UserProfileCountAggregateOutputType | null
    _avg: UserProfileAvgAggregateOutputType | null
    _sum: UserProfileSumAggregateOutputType | null
    _min: UserProfileMinAggregateOutputType | null
    _max: UserProfileMaxAggregateOutputType | null
  }

  export type UserProfileAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type UserProfileSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type UserProfileMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    userId: number | null
    fullName: string | null
  }

  export type UserProfileMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    userId: number | null
    fullName: string | null
  }

  export type UserProfileCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    isDeleted: number
    userId: number
    fullName: number
    _all: number
  }


  export type UserProfileAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type UserProfileSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type UserProfileMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    userId?: true
    fullName?: true
  }

  export type UserProfileMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    userId?: true
    fullName?: true
  }

  export type UserProfileCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    userId?: true
    fullName?: true
    _all?: true
  }

  export type UserProfileAggregateArgs = {
    /**
     * Filter which UserProfile to aggregate.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: Enumerable<UserProfileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserProfiles
    **/
    _count?: true | UserProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserProfileMaxAggregateInputType
  }

  export type GetUserProfileAggregateType<T extends UserProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateUserProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserProfile[P]>
      : GetScalarType<T[P], AggregateUserProfile[P]>
  }




  export type UserProfileGroupByArgs = {
    where?: UserProfileWhereInput
    orderBy?: Enumerable<UserProfileOrderByWithAggregationInput>
    by: UserProfileScalarFieldEnum[]
    having?: UserProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserProfileCountAggregateInputType | true
    _avg?: UserProfileAvgAggregateInputType
    _sum?: UserProfileSumAggregateInputType
    _min?: UserProfileMinAggregateInputType
    _max?: UserProfileMaxAggregateInputType
  }


  export type UserProfileGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    isDeleted: boolean
    userId: number
    fullName: string
    _count: UserProfileCountAggregateOutputType | null
    _avg: UserProfileAvgAggregateOutputType | null
    _sum: UserProfileSumAggregateOutputType | null
    _min: UserProfileMinAggregateOutputType | null
    _max: UserProfileMaxAggregateOutputType | null
  }

  type GetUserProfileGroupByPayload<T extends UserProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserProfileGroupByOutputType[P]>
            : GetScalarType<T[P], UserProfileGroupByOutputType[P]>
        }
      >
    >


  export type UserProfileSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    userId?: boolean
    fullName?: boolean
    user?: boolean | UserArgs
  }


  export type UserProfileInclude = {
    user?: boolean | UserArgs
  }

  export type UserProfileGetPayload<S extends boolean | null | undefined | UserProfileArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? UserProfile :
    S extends undefined ? never :
    S extends { include: any } & (UserProfileArgs | UserProfileFindManyArgs)
    ? UserProfile  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (UserProfileArgs | UserProfileFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :  P extends keyof UserProfile ? UserProfile[P] : never
  } 
      : UserProfile


  type UserProfileCountArgs = 
    Omit<UserProfileFindManyArgs, 'select' | 'include'> & {
      select?: UserProfileCountAggregateInputType | true
    }

  export interface UserProfileDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one UserProfile that matches the filter.
     * @param {UserProfileFindUniqueArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserProfileFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserProfileFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserProfile'> extends True ? Prisma__UserProfileClient<UserProfileGetPayload<T>> : Prisma__UserProfileClient<UserProfileGetPayload<T> | null, null>

    /**
     * Find one UserProfile that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserProfileFindUniqueOrThrowArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserProfileFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserProfileFindUniqueOrThrowArgs>
    ): Prisma__UserProfileClient<UserProfileGetPayload<T>>

    /**
     * Find the first UserProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFindFirstArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserProfileFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserProfileFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserProfile'> extends True ? Prisma__UserProfileClient<UserProfileGetPayload<T>> : Prisma__UserProfileClient<UserProfileGetPayload<T> | null, null>

    /**
     * Find the first UserProfile that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFindFirstOrThrowArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserProfileFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserProfileFindFirstOrThrowArgs>
    ): Prisma__UserProfileClient<UserProfileGetPayload<T>>

    /**
     * Find zero or more UserProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserProfiles
     * const userProfiles = await prisma.userProfile.findMany()
     * 
     * // Get first 10 UserProfiles
     * const userProfiles = await prisma.userProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userProfileWithIdOnly = await prisma.userProfile.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserProfileFindManyArgs>(
      args?: SelectSubset<T, UserProfileFindManyArgs>
    ): Prisma.PrismaPromise<Array<UserProfileGetPayload<T>>>

    /**
     * Create a UserProfile.
     * @param {UserProfileCreateArgs} args - Arguments to create a UserProfile.
     * @example
     * // Create one UserProfile
     * const UserProfile = await prisma.userProfile.create({
     *   data: {
     *     // ... data to create a UserProfile
     *   }
     * })
     * 
    **/
    create<T extends UserProfileCreateArgs>(
      args: SelectSubset<T, UserProfileCreateArgs>
    ): Prisma__UserProfileClient<UserProfileGetPayload<T>>

    /**
     * Create many UserProfiles.
     *     @param {UserProfileCreateManyArgs} args - Arguments to create many UserProfiles.
     *     @example
     *     // Create many UserProfiles
     *     const userProfile = await prisma.userProfile.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserProfileCreateManyArgs>(
      args?: SelectSubset<T, UserProfileCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserProfile.
     * @param {UserProfileDeleteArgs} args - Arguments to delete one UserProfile.
     * @example
     * // Delete one UserProfile
     * const UserProfile = await prisma.userProfile.delete({
     *   where: {
     *     // ... filter to delete one UserProfile
     *   }
     * })
     * 
    **/
    delete<T extends UserProfileDeleteArgs>(
      args: SelectSubset<T, UserProfileDeleteArgs>
    ): Prisma__UserProfileClient<UserProfileGetPayload<T>>

    /**
     * Update one UserProfile.
     * @param {UserProfileUpdateArgs} args - Arguments to update one UserProfile.
     * @example
     * // Update one UserProfile
     * const userProfile = await prisma.userProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserProfileUpdateArgs>(
      args: SelectSubset<T, UserProfileUpdateArgs>
    ): Prisma__UserProfileClient<UserProfileGetPayload<T>>

    /**
     * Delete zero or more UserProfiles.
     * @param {UserProfileDeleteManyArgs} args - Arguments to filter UserProfiles to delete.
     * @example
     * // Delete a few UserProfiles
     * const { count } = await prisma.userProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserProfileDeleteManyArgs>(
      args?: SelectSubset<T, UserProfileDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserProfiles
     * const userProfile = await prisma.userProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserProfileUpdateManyArgs>(
      args: SelectSubset<T, UserProfileUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserProfile.
     * @param {UserProfileUpsertArgs} args - Arguments to update or create a UserProfile.
     * @example
     * // Update or create a UserProfile
     * const userProfile = await prisma.userProfile.upsert({
     *   create: {
     *     // ... data to create a UserProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserProfile we want to update
     *   }
     * })
    **/
    upsert<T extends UserProfileUpsertArgs>(
      args: SelectSubset<T, UserProfileUpsertArgs>
    ): Prisma__UserProfileClient<UserProfileGetPayload<T>>

    /**
     * Count the number of UserProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileCountArgs} args - Arguments to filter UserProfiles to count.
     * @example
     * // Count the number of UserProfiles
     * const count = await prisma.userProfile.count({
     *   where: {
     *     // ... the filter for the UserProfiles we want to count
     *   }
     * })
    **/
    count<T extends UserProfileCountArgs>(
      args?: Subset<T, UserProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserProfileAggregateArgs>(args: Subset<T, UserProfileAggregateArgs>): Prisma.PrismaPromise<GetUserProfileAggregateType<T>>

    /**
     * Group by UserProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserProfileGroupByArgs['orderBy'] }
        : { orderBy?: UserProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for UserProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserProfileClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * UserProfile base type for findUnique actions
   */
  export type UserProfileFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserProfileInclude | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile findUnique
   */
  export interface UserProfileFindUniqueArgs extends UserProfileFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserProfile findUniqueOrThrow
   */
  export type UserProfileFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserProfileInclude | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where: UserProfileWhereUniqueInput
  }


  /**
   * UserProfile base type for findFirst actions
   */
  export type UserProfileFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserProfileInclude | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: Enumerable<UserProfileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProfiles.
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProfiles.
     */
    distinct?: Enumerable<UserProfileScalarFieldEnum>
  }

  /**
   * UserProfile findFirst
   */
  export interface UserProfileFindFirstArgs extends UserProfileFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserProfile findFirstOrThrow
   */
  export type UserProfileFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserProfileInclude | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: Enumerable<UserProfileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProfiles.
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProfiles.
     */
    distinct?: Enumerable<UserProfileScalarFieldEnum>
  }


  /**
   * UserProfile findMany
   */
  export type UserProfileFindManyArgs = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserProfileInclude | null
    /**
     * Filter, which UserProfiles to fetch.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: Enumerable<UserProfileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserProfiles.
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    distinct?: Enumerable<UserProfileScalarFieldEnum>
  }


  /**
   * UserProfile create
   */
  export type UserProfileCreateArgs = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserProfileInclude | null
    /**
     * The data needed to create a UserProfile.
     */
    data: XOR<UserProfileCreateInput, UserProfileUncheckedCreateInput>
  }


  /**
   * UserProfile createMany
   */
  export type UserProfileCreateManyArgs = {
    /**
     * The data used to create many UserProfiles.
     */
    data: Enumerable<UserProfileCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UserProfile update
   */
  export type UserProfileUpdateArgs = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserProfileInclude | null
    /**
     * The data needed to update a UserProfile.
     */
    data: XOR<UserProfileUpdateInput, UserProfileUncheckedUpdateInput>
    /**
     * Choose, which UserProfile to update.
     */
    where: UserProfileWhereUniqueInput
  }


  /**
   * UserProfile updateMany
   */
  export type UserProfileUpdateManyArgs = {
    /**
     * The data used to update UserProfiles.
     */
    data: XOR<UserProfileUpdateManyMutationInput, UserProfileUncheckedUpdateManyInput>
    /**
     * Filter which UserProfiles to update
     */
    where?: UserProfileWhereInput
  }


  /**
   * UserProfile upsert
   */
  export type UserProfileUpsertArgs = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserProfileInclude | null
    /**
     * The filter to search for the UserProfile to update in case it exists.
     */
    where: UserProfileWhereUniqueInput
    /**
     * In case the UserProfile found by the `where` argument doesn't exist, create a new UserProfile with this data.
     */
    create: XOR<UserProfileCreateInput, UserProfileUncheckedCreateInput>
    /**
     * In case the UserProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserProfileUpdateInput, UserProfileUncheckedUpdateInput>
  }


  /**
   * UserProfile delete
   */
  export type UserProfileDeleteArgs = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserProfileInclude | null
    /**
     * Filter which UserProfile to delete.
     */
    where: UserProfileWhereUniqueInput
  }


  /**
   * UserProfile deleteMany
   */
  export type UserProfileDeleteManyArgs = {
    /**
     * Filter which UserProfiles to delete
     */
    where?: UserProfileWhereInput
  }


  /**
   * UserProfile without action
   */
  export type UserProfileArgs = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserProfileInclude | null
  }



  /**
   * Model ProductLine
   */


  export type AggregateProductLine = {
    _count: ProductLineCountAggregateOutputType | null
    _avg: ProductLineAvgAggregateOutputType | null
    _sum: ProductLineSumAggregateOutputType | null
    _min: ProductLineMinAggregateOutputType | null
    _max: ProductLineMaxAggregateOutputType | null
  }

  export type ProductLineAvgAggregateOutputType = {
    id: number | null
  }

  export type ProductLineSumAggregateOutputType = {
    id: number | null
  }

  export type ProductLineMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    name: string | null
    description: string | null
  }

  export type ProductLineMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    name: string | null
    description: string | null
  }

  export type ProductLineCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    isDeleted: number
    name: number
    description: number
    _all: number
  }


  export type ProductLineAvgAggregateInputType = {
    id?: true
  }

  export type ProductLineSumAggregateInputType = {
    id?: true
  }

  export type ProductLineMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    name?: true
    description?: true
  }

  export type ProductLineMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    name?: true
    description?: true
  }

  export type ProductLineCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    name?: true
    description?: true
    _all?: true
  }

  export type ProductLineAggregateArgs = {
    /**
     * Filter which ProductLine to aggregate.
     */
    where?: ProductLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductLines to fetch.
     */
    orderBy?: Enumerable<ProductLineOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductLines
    **/
    _count?: true | ProductLineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductLineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductLineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductLineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductLineMaxAggregateInputType
  }

  export type GetProductLineAggregateType<T extends ProductLineAggregateArgs> = {
        [P in keyof T & keyof AggregateProductLine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductLine[P]>
      : GetScalarType<T[P], AggregateProductLine[P]>
  }




  export type ProductLineGroupByArgs = {
    where?: ProductLineWhereInput
    orderBy?: Enumerable<ProductLineOrderByWithAggregationInput>
    by: ProductLineScalarFieldEnum[]
    having?: ProductLineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductLineCountAggregateInputType | true
    _avg?: ProductLineAvgAggregateInputType
    _sum?: ProductLineSumAggregateInputType
    _min?: ProductLineMinAggregateInputType
    _max?: ProductLineMaxAggregateInputType
  }


  export type ProductLineGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    isDeleted: boolean
    name: string
    description: string | null
    _count: ProductLineCountAggregateOutputType | null
    _avg: ProductLineAvgAggregateOutputType | null
    _sum: ProductLineSumAggregateOutputType | null
    _min: ProductLineMinAggregateOutputType | null
    _max: ProductLineMaxAggregateOutputType | null
  }

  type GetProductLineGroupByPayload<T extends ProductLineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ProductLineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductLineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductLineGroupByOutputType[P]>
            : GetScalarType<T[P], ProductLineGroupByOutputType[P]>
        }
      >
    >


  export type ProductLineSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    name?: boolean
    description?: boolean
    equipment?: boolean | ProductLine$equipmentArgs
    _count?: boolean | ProductLineCountOutputTypeArgs
  }


  export type ProductLineInclude = {
    equipment?: boolean | ProductLine$equipmentArgs
    _count?: boolean | ProductLineCountOutputTypeArgs
  }

  export type ProductLineGetPayload<S extends boolean | null | undefined | ProductLineArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ProductLine :
    S extends undefined ? never :
    S extends { include: any } & (ProductLineArgs | ProductLineFindManyArgs)
    ? ProductLine  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'equipment' ? Array < EquipmentGetPayload<S['include'][P]>>  :
        P extends '_count' ? ProductLineCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ProductLineArgs | ProductLineFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'equipment' ? Array < EquipmentGetPayload<S['select'][P]>>  :
        P extends '_count' ? ProductLineCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof ProductLine ? ProductLine[P] : never
  } 
      : ProductLine


  type ProductLineCountArgs = 
    Omit<ProductLineFindManyArgs, 'select' | 'include'> & {
      select?: ProductLineCountAggregateInputType | true
    }

  export interface ProductLineDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one ProductLine that matches the filter.
     * @param {ProductLineFindUniqueArgs} args - Arguments to find a ProductLine
     * @example
     * // Get one ProductLine
     * const productLine = await prisma.productLine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductLineFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProductLineFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ProductLine'> extends True ? Prisma__ProductLineClient<ProductLineGetPayload<T>> : Prisma__ProductLineClient<ProductLineGetPayload<T> | null, null>

    /**
     * Find one ProductLine that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProductLineFindUniqueOrThrowArgs} args - Arguments to find a ProductLine
     * @example
     * // Get one ProductLine
     * const productLine = await prisma.productLine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProductLineFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ProductLineFindUniqueOrThrowArgs>
    ): Prisma__ProductLineClient<ProductLineGetPayload<T>>

    /**
     * Find the first ProductLine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductLineFindFirstArgs} args - Arguments to find a ProductLine
     * @example
     * // Get one ProductLine
     * const productLine = await prisma.productLine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductLineFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProductLineFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ProductLine'> extends True ? Prisma__ProductLineClient<ProductLineGetPayload<T>> : Prisma__ProductLineClient<ProductLineGetPayload<T> | null, null>

    /**
     * Find the first ProductLine that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductLineFindFirstOrThrowArgs} args - Arguments to find a ProductLine
     * @example
     * // Get one ProductLine
     * const productLine = await prisma.productLine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProductLineFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ProductLineFindFirstOrThrowArgs>
    ): Prisma__ProductLineClient<ProductLineGetPayload<T>>

    /**
     * Find zero or more ProductLines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductLineFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductLines
     * const productLines = await prisma.productLine.findMany()
     * 
     * // Get first 10 ProductLines
     * const productLines = await prisma.productLine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productLineWithIdOnly = await prisma.productLine.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductLineFindManyArgs>(
      args?: SelectSubset<T, ProductLineFindManyArgs>
    ): Prisma.PrismaPromise<Array<ProductLineGetPayload<T>>>

    /**
     * Create a ProductLine.
     * @param {ProductLineCreateArgs} args - Arguments to create a ProductLine.
     * @example
     * // Create one ProductLine
     * const ProductLine = await prisma.productLine.create({
     *   data: {
     *     // ... data to create a ProductLine
     *   }
     * })
     * 
    **/
    create<T extends ProductLineCreateArgs>(
      args: SelectSubset<T, ProductLineCreateArgs>
    ): Prisma__ProductLineClient<ProductLineGetPayload<T>>

    /**
     * Create many ProductLines.
     *     @param {ProductLineCreateManyArgs} args - Arguments to create many ProductLines.
     *     @example
     *     // Create many ProductLines
     *     const productLine = await prisma.productLine.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductLineCreateManyArgs>(
      args?: SelectSubset<T, ProductLineCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProductLine.
     * @param {ProductLineDeleteArgs} args - Arguments to delete one ProductLine.
     * @example
     * // Delete one ProductLine
     * const ProductLine = await prisma.productLine.delete({
     *   where: {
     *     // ... filter to delete one ProductLine
     *   }
     * })
     * 
    **/
    delete<T extends ProductLineDeleteArgs>(
      args: SelectSubset<T, ProductLineDeleteArgs>
    ): Prisma__ProductLineClient<ProductLineGetPayload<T>>

    /**
     * Update one ProductLine.
     * @param {ProductLineUpdateArgs} args - Arguments to update one ProductLine.
     * @example
     * // Update one ProductLine
     * const productLine = await prisma.productLine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductLineUpdateArgs>(
      args: SelectSubset<T, ProductLineUpdateArgs>
    ): Prisma__ProductLineClient<ProductLineGetPayload<T>>

    /**
     * Delete zero or more ProductLines.
     * @param {ProductLineDeleteManyArgs} args - Arguments to filter ProductLines to delete.
     * @example
     * // Delete a few ProductLines
     * const { count } = await prisma.productLine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductLineDeleteManyArgs>(
      args?: SelectSubset<T, ProductLineDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductLineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductLines
     * const productLine = await prisma.productLine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductLineUpdateManyArgs>(
      args: SelectSubset<T, ProductLineUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductLine.
     * @param {ProductLineUpsertArgs} args - Arguments to update or create a ProductLine.
     * @example
     * // Update or create a ProductLine
     * const productLine = await prisma.productLine.upsert({
     *   create: {
     *     // ... data to create a ProductLine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductLine we want to update
     *   }
     * })
    **/
    upsert<T extends ProductLineUpsertArgs>(
      args: SelectSubset<T, ProductLineUpsertArgs>
    ): Prisma__ProductLineClient<ProductLineGetPayload<T>>

    /**
     * Count the number of ProductLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductLineCountArgs} args - Arguments to filter ProductLines to count.
     * @example
     * // Count the number of ProductLines
     * const count = await prisma.productLine.count({
     *   where: {
     *     // ... the filter for the ProductLines we want to count
     *   }
     * })
    **/
    count<T extends ProductLineCountArgs>(
      args?: Subset<T, ProductLineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductLineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductLineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductLineAggregateArgs>(args: Subset<T, ProductLineAggregateArgs>): Prisma.PrismaPromise<GetProductLineAggregateType<T>>

    /**
     * Group by ProductLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductLineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductLineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductLineGroupByArgs['orderBy'] }
        : { orderBy?: ProductLineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductLineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductLineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductLine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProductLineClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    equipment<T extends ProductLine$equipmentArgs= {}>(args?: Subset<T, ProductLine$equipmentArgs>): Prisma.PrismaPromise<Array<EquipmentGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ProductLine base type for findUnique actions
   */
  export type ProductLineFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ProductLine
     */
    select?: ProductLineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductLineInclude | null
    /**
     * Filter, which ProductLine to fetch.
     */
    where: ProductLineWhereUniqueInput
  }

  /**
   * ProductLine findUnique
   */
  export interface ProductLineFindUniqueArgs extends ProductLineFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ProductLine findUniqueOrThrow
   */
  export type ProductLineFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ProductLine
     */
    select?: ProductLineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductLineInclude | null
    /**
     * Filter, which ProductLine to fetch.
     */
    where: ProductLineWhereUniqueInput
  }


  /**
   * ProductLine base type for findFirst actions
   */
  export type ProductLineFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ProductLine
     */
    select?: ProductLineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductLineInclude | null
    /**
     * Filter, which ProductLine to fetch.
     */
    where?: ProductLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductLines to fetch.
     */
    orderBy?: Enumerable<ProductLineOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductLines.
     */
    cursor?: ProductLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductLines.
     */
    distinct?: Enumerable<ProductLineScalarFieldEnum>
  }

  /**
   * ProductLine findFirst
   */
  export interface ProductLineFindFirstArgs extends ProductLineFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ProductLine findFirstOrThrow
   */
  export type ProductLineFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ProductLine
     */
    select?: ProductLineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductLineInclude | null
    /**
     * Filter, which ProductLine to fetch.
     */
    where?: ProductLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductLines to fetch.
     */
    orderBy?: Enumerable<ProductLineOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductLines.
     */
    cursor?: ProductLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductLines.
     */
    distinct?: Enumerable<ProductLineScalarFieldEnum>
  }


  /**
   * ProductLine findMany
   */
  export type ProductLineFindManyArgs = {
    /**
     * Select specific fields to fetch from the ProductLine
     */
    select?: ProductLineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductLineInclude | null
    /**
     * Filter, which ProductLines to fetch.
     */
    where?: ProductLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductLines to fetch.
     */
    orderBy?: Enumerable<ProductLineOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductLines.
     */
    cursor?: ProductLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductLines.
     */
    skip?: number
    distinct?: Enumerable<ProductLineScalarFieldEnum>
  }


  /**
   * ProductLine create
   */
  export type ProductLineCreateArgs = {
    /**
     * Select specific fields to fetch from the ProductLine
     */
    select?: ProductLineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductLineInclude | null
    /**
     * The data needed to create a ProductLine.
     */
    data: XOR<ProductLineCreateInput, ProductLineUncheckedCreateInput>
  }


  /**
   * ProductLine createMany
   */
  export type ProductLineCreateManyArgs = {
    /**
     * The data used to create many ProductLines.
     */
    data: Enumerable<ProductLineCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ProductLine update
   */
  export type ProductLineUpdateArgs = {
    /**
     * Select specific fields to fetch from the ProductLine
     */
    select?: ProductLineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductLineInclude | null
    /**
     * The data needed to update a ProductLine.
     */
    data: XOR<ProductLineUpdateInput, ProductLineUncheckedUpdateInput>
    /**
     * Choose, which ProductLine to update.
     */
    where: ProductLineWhereUniqueInput
  }


  /**
   * ProductLine updateMany
   */
  export type ProductLineUpdateManyArgs = {
    /**
     * The data used to update ProductLines.
     */
    data: XOR<ProductLineUpdateManyMutationInput, ProductLineUncheckedUpdateManyInput>
    /**
     * Filter which ProductLines to update
     */
    where?: ProductLineWhereInput
  }


  /**
   * ProductLine upsert
   */
  export type ProductLineUpsertArgs = {
    /**
     * Select specific fields to fetch from the ProductLine
     */
    select?: ProductLineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductLineInclude | null
    /**
     * The filter to search for the ProductLine to update in case it exists.
     */
    where: ProductLineWhereUniqueInput
    /**
     * In case the ProductLine found by the `where` argument doesn't exist, create a new ProductLine with this data.
     */
    create: XOR<ProductLineCreateInput, ProductLineUncheckedCreateInput>
    /**
     * In case the ProductLine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductLineUpdateInput, ProductLineUncheckedUpdateInput>
  }


  /**
   * ProductLine delete
   */
  export type ProductLineDeleteArgs = {
    /**
     * Select specific fields to fetch from the ProductLine
     */
    select?: ProductLineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductLineInclude | null
    /**
     * Filter which ProductLine to delete.
     */
    where: ProductLineWhereUniqueInput
  }


  /**
   * ProductLine deleteMany
   */
  export type ProductLineDeleteManyArgs = {
    /**
     * Filter which ProductLines to delete
     */
    where?: ProductLineWhereInput
  }


  /**
   * ProductLine.equipment
   */
  export type ProductLine$equipmentArgs = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EquipmentInclude | null
    where?: EquipmentWhereInput
    orderBy?: Enumerable<EquipmentOrderByWithRelationInput>
    cursor?: EquipmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<EquipmentScalarFieldEnum>
  }


  /**
   * ProductLine without action
   */
  export type ProductLineArgs = {
    /**
     * Select specific fields to fetch from the ProductLine
     */
    select?: ProductLineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductLineInclude | null
  }



  /**
   * Model Equipment
   */


  export type AggregateEquipment = {
    _count: EquipmentCountAggregateOutputType | null
    _avg: EquipmentAvgAggregateOutputType | null
    _sum: EquipmentSumAggregateOutputType | null
    _min: EquipmentMinAggregateOutputType | null
    _max: EquipmentMaxAggregateOutputType | null
  }

  export type EquipmentAvgAggregateOutputType = {
    id: number | null
    productLineId: number | null
  }

  export type EquipmentSumAggregateOutputType = {
    id: number | null
    productLineId: number | null
  }

  export type EquipmentMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    name: string | null
    description: string | null
    purchaseDate: Date | null
    productLineId: number | null
  }

  export type EquipmentMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    name: string | null
    description: string | null
    purchaseDate: Date | null
    productLineId: number | null
  }

  export type EquipmentCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    isDeleted: number
    name: number
    description: number
    purchaseDate: number
    productLineId: number
    _all: number
  }


  export type EquipmentAvgAggregateInputType = {
    id?: true
    productLineId?: true
  }

  export type EquipmentSumAggregateInputType = {
    id?: true
    productLineId?: true
  }

  export type EquipmentMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    name?: true
    description?: true
    purchaseDate?: true
    productLineId?: true
  }

  export type EquipmentMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    name?: true
    description?: true
    purchaseDate?: true
    productLineId?: true
  }

  export type EquipmentCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    name?: true
    description?: true
    purchaseDate?: true
    productLineId?: true
    _all?: true
  }

  export type EquipmentAggregateArgs = {
    /**
     * Filter which Equipment to aggregate.
     */
    where?: EquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equipment to fetch.
     */
    orderBy?: Enumerable<EquipmentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equipment from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equipment.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Equipment
    **/
    _count?: true | EquipmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EquipmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EquipmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EquipmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EquipmentMaxAggregateInputType
  }

  export type GetEquipmentAggregateType<T extends EquipmentAggregateArgs> = {
        [P in keyof T & keyof AggregateEquipment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEquipment[P]>
      : GetScalarType<T[P], AggregateEquipment[P]>
  }




  export type EquipmentGroupByArgs = {
    where?: EquipmentWhereInput
    orderBy?: Enumerable<EquipmentOrderByWithAggregationInput>
    by: EquipmentScalarFieldEnum[]
    having?: EquipmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EquipmentCountAggregateInputType | true
    _avg?: EquipmentAvgAggregateInputType
    _sum?: EquipmentSumAggregateInputType
    _min?: EquipmentMinAggregateInputType
    _max?: EquipmentMaxAggregateInputType
  }


  export type EquipmentGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    isDeleted: boolean
    name: string
    description: string | null
    purchaseDate: Date
    productLineId: number | null
    _count: EquipmentCountAggregateOutputType | null
    _avg: EquipmentAvgAggregateOutputType | null
    _sum: EquipmentSumAggregateOutputType | null
    _min: EquipmentMinAggregateOutputType | null
    _max: EquipmentMaxAggregateOutputType | null
  }

  type GetEquipmentGroupByPayload<T extends EquipmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<EquipmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EquipmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EquipmentGroupByOutputType[P]>
            : GetScalarType<T[P], EquipmentGroupByOutputType[P]>
        }
      >
    >


  export type EquipmentSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    name?: boolean
    description?: boolean
    purchaseDate?: boolean
    productLineId?: boolean
    plan?: boolean | RepairPlanArgs
    records?: boolean | Equipment$recordsArgs
    productLine?: boolean | ProductLineArgs
    _count?: boolean | EquipmentCountOutputTypeArgs
  }


  export type EquipmentInclude = {
    plan?: boolean | RepairPlanArgs
    records?: boolean | Equipment$recordsArgs
    productLine?: boolean | ProductLineArgs
    _count?: boolean | EquipmentCountOutputTypeArgs
  }

  export type EquipmentGetPayload<S extends boolean | null | undefined | EquipmentArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Equipment :
    S extends undefined ? never :
    S extends { include: any } & (EquipmentArgs | EquipmentFindManyArgs)
    ? Equipment  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'plan' ? RepairPlanGetPayload<S['include'][P]> | null :
        P extends 'records' ? Array < RepairRecordGetPayload<S['include'][P]>>  :
        P extends 'productLine' ? ProductLineGetPayload<S['include'][P]> | null :
        P extends '_count' ? EquipmentCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (EquipmentArgs | EquipmentFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'plan' ? RepairPlanGetPayload<S['select'][P]> | null :
        P extends 'records' ? Array < RepairRecordGetPayload<S['select'][P]>>  :
        P extends 'productLine' ? ProductLineGetPayload<S['select'][P]> | null :
        P extends '_count' ? EquipmentCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Equipment ? Equipment[P] : never
  } 
      : Equipment


  type EquipmentCountArgs = 
    Omit<EquipmentFindManyArgs, 'select' | 'include'> & {
      select?: EquipmentCountAggregateInputType | true
    }

  export interface EquipmentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Equipment that matches the filter.
     * @param {EquipmentFindUniqueArgs} args - Arguments to find a Equipment
     * @example
     * // Get one Equipment
     * const equipment = await prisma.equipment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EquipmentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, EquipmentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Equipment'> extends True ? Prisma__EquipmentClient<EquipmentGetPayload<T>> : Prisma__EquipmentClient<EquipmentGetPayload<T> | null, null>

    /**
     * Find one Equipment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EquipmentFindUniqueOrThrowArgs} args - Arguments to find a Equipment
     * @example
     * // Get one Equipment
     * const equipment = await prisma.equipment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EquipmentFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, EquipmentFindUniqueOrThrowArgs>
    ): Prisma__EquipmentClient<EquipmentGetPayload<T>>

    /**
     * Find the first Equipment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentFindFirstArgs} args - Arguments to find a Equipment
     * @example
     * // Get one Equipment
     * const equipment = await prisma.equipment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EquipmentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, EquipmentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Equipment'> extends True ? Prisma__EquipmentClient<EquipmentGetPayload<T>> : Prisma__EquipmentClient<EquipmentGetPayload<T> | null, null>

    /**
     * Find the first Equipment that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentFindFirstOrThrowArgs} args - Arguments to find a Equipment
     * @example
     * // Get one Equipment
     * const equipment = await prisma.equipment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EquipmentFindFirstOrThrowArgs>(
      args?: SelectSubset<T, EquipmentFindFirstOrThrowArgs>
    ): Prisma__EquipmentClient<EquipmentGetPayload<T>>

    /**
     * Find zero or more Equipment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Equipment
     * const equipment = await prisma.equipment.findMany()
     * 
     * // Get first 10 Equipment
     * const equipment = await prisma.equipment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const equipmentWithIdOnly = await prisma.equipment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EquipmentFindManyArgs>(
      args?: SelectSubset<T, EquipmentFindManyArgs>
    ): Prisma.PrismaPromise<Array<EquipmentGetPayload<T>>>

    /**
     * Create a Equipment.
     * @param {EquipmentCreateArgs} args - Arguments to create a Equipment.
     * @example
     * // Create one Equipment
     * const Equipment = await prisma.equipment.create({
     *   data: {
     *     // ... data to create a Equipment
     *   }
     * })
     * 
    **/
    create<T extends EquipmentCreateArgs>(
      args: SelectSubset<T, EquipmentCreateArgs>
    ): Prisma__EquipmentClient<EquipmentGetPayload<T>>

    /**
     * Create many Equipment.
     *     @param {EquipmentCreateManyArgs} args - Arguments to create many Equipment.
     *     @example
     *     // Create many Equipment
     *     const equipment = await prisma.equipment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EquipmentCreateManyArgs>(
      args?: SelectSubset<T, EquipmentCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Equipment.
     * @param {EquipmentDeleteArgs} args - Arguments to delete one Equipment.
     * @example
     * // Delete one Equipment
     * const Equipment = await prisma.equipment.delete({
     *   where: {
     *     // ... filter to delete one Equipment
     *   }
     * })
     * 
    **/
    delete<T extends EquipmentDeleteArgs>(
      args: SelectSubset<T, EquipmentDeleteArgs>
    ): Prisma__EquipmentClient<EquipmentGetPayload<T>>

    /**
     * Update one Equipment.
     * @param {EquipmentUpdateArgs} args - Arguments to update one Equipment.
     * @example
     * // Update one Equipment
     * const equipment = await prisma.equipment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EquipmentUpdateArgs>(
      args: SelectSubset<T, EquipmentUpdateArgs>
    ): Prisma__EquipmentClient<EquipmentGetPayload<T>>

    /**
     * Delete zero or more Equipment.
     * @param {EquipmentDeleteManyArgs} args - Arguments to filter Equipment to delete.
     * @example
     * // Delete a few Equipment
     * const { count } = await prisma.equipment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EquipmentDeleteManyArgs>(
      args?: SelectSubset<T, EquipmentDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Equipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Equipment
     * const equipment = await prisma.equipment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EquipmentUpdateManyArgs>(
      args: SelectSubset<T, EquipmentUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Equipment.
     * @param {EquipmentUpsertArgs} args - Arguments to update or create a Equipment.
     * @example
     * // Update or create a Equipment
     * const equipment = await prisma.equipment.upsert({
     *   create: {
     *     // ... data to create a Equipment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Equipment we want to update
     *   }
     * })
    **/
    upsert<T extends EquipmentUpsertArgs>(
      args: SelectSubset<T, EquipmentUpsertArgs>
    ): Prisma__EquipmentClient<EquipmentGetPayload<T>>

    /**
     * Count the number of Equipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentCountArgs} args - Arguments to filter Equipment to count.
     * @example
     * // Count the number of Equipment
     * const count = await prisma.equipment.count({
     *   where: {
     *     // ... the filter for the Equipment we want to count
     *   }
     * })
    **/
    count<T extends EquipmentCountArgs>(
      args?: Subset<T, EquipmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EquipmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Equipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EquipmentAggregateArgs>(args: Subset<T, EquipmentAggregateArgs>): Prisma.PrismaPromise<GetEquipmentAggregateType<T>>

    /**
     * Group by Equipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EquipmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EquipmentGroupByArgs['orderBy'] }
        : { orderBy?: EquipmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EquipmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEquipmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Equipment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__EquipmentClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    plan<T extends RepairPlanArgs= {}>(args?: Subset<T, RepairPlanArgs>): Prisma__RepairPlanClient<RepairPlanGetPayload<T> | Null>;

    records<T extends Equipment$recordsArgs= {}>(args?: Subset<T, Equipment$recordsArgs>): Prisma.PrismaPromise<Array<RepairRecordGetPayload<T>>| Null>;

    productLine<T extends ProductLineArgs= {}>(args?: Subset<T, ProductLineArgs>): Prisma__ProductLineClient<ProductLineGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Equipment base type for findUnique actions
   */
  export type EquipmentFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EquipmentInclude | null
    /**
     * Filter, which Equipment to fetch.
     */
    where: EquipmentWhereUniqueInput
  }

  /**
   * Equipment findUnique
   */
  export interface EquipmentFindUniqueArgs extends EquipmentFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Equipment findUniqueOrThrow
   */
  export type EquipmentFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EquipmentInclude | null
    /**
     * Filter, which Equipment to fetch.
     */
    where: EquipmentWhereUniqueInput
  }


  /**
   * Equipment base type for findFirst actions
   */
  export type EquipmentFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EquipmentInclude | null
    /**
     * Filter, which Equipment to fetch.
     */
    where?: EquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equipment to fetch.
     */
    orderBy?: Enumerable<EquipmentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Equipment.
     */
    cursor?: EquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equipment from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equipment.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Equipment.
     */
    distinct?: Enumerable<EquipmentScalarFieldEnum>
  }

  /**
   * Equipment findFirst
   */
  export interface EquipmentFindFirstArgs extends EquipmentFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Equipment findFirstOrThrow
   */
  export type EquipmentFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EquipmentInclude | null
    /**
     * Filter, which Equipment to fetch.
     */
    where?: EquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equipment to fetch.
     */
    orderBy?: Enumerable<EquipmentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Equipment.
     */
    cursor?: EquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equipment from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equipment.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Equipment.
     */
    distinct?: Enumerable<EquipmentScalarFieldEnum>
  }


  /**
   * Equipment findMany
   */
  export type EquipmentFindManyArgs = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EquipmentInclude | null
    /**
     * Filter, which Equipment to fetch.
     */
    where?: EquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equipment to fetch.
     */
    orderBy?: Enumerable<EquipmentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Equipment.
     */
    cursor?: EquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equipment from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equipment.
     */
    skip?: number
    distinct?: Enumerable<EquipmentScalarFieldEnum>
  }


  /**
   * Equipment create
   */
  export type EquipmentCreateArgs = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EquipmentInclude | null
    /**
     * The data needed to create a Equipment.
     */
    data: XOR<EquipmentCreateInput, EquipmentUncheckedCreateInput>
  }


  /**
   * Equipment createMany
   */
  export type EquipmentCreateManyArgs = {
    /**
     * The data used to create many Equipment.
     */
    data: Enumerable<EquipmentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Equipment update
   */
  export type EquipmentUpdateArgs = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EquipmentInclude | null
    /**
     * The data needed to update a Equipment.
     */
    data: XOR<EquipmentUpdateInput, EquipmentUncheckedUpdateInput>
    /**
     * Choose, which Equipment to update.
     */
    where: EquipmentWhereUniqueInput
  }


  /**
   * Equipment updateMany
   */
  export type EquipmentUpdateManyArgs = {
    /**
     * The data used to update Equipment.
     */
    data: XOR<EquipmentUpdateManyMutationInput, EquipmentUncheckedUpdateManyInput>
    /**
     * Filter which Equipment to update
     */
    where?: EquipmentWhereInput
  }


  /**
   * Equipment upsert
   */
  export type EquipmentUpsertArgs = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EquipmentInclude | null
    /**
     * The filter to search for the Equipment to update in case it exists.
     */
    where: EquipmentWhereUniqueInput
    /**
     * In case the Equipment found by the `where` argument doesn't exist, create a new Equipment with this data.
     */
    create: XOR<EquipmentCreateInput, EquipmentUncheckedCreateInput>
    /**
     * In case the Equipment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EquipmentUpdateInput, EquipmentUncheckedUpdateInput>
  }


  /**
   * Equipment delete
   */
  export type EquipmentDeleteArgs = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EquipmentInclude | null
    /**
     * Filter which Equipment to delete.
     */
    where: EquipmentWhereUniqueInput
  }


  /**
   * Equipment deleteMany
   */
  export type EquipmentDeleteManyArgs = {
    /**
     * Filter which Equipment to delete
     */
    where?: EquipmentWhereInput
  }


  /**
   * Equipment.records
   */
  export type Equipment$recordsArgs = {
    /**
     * Select specific fields to fetch from the RepairRecord
     */
    select?: RepairRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairRecordInclude | null
    where?: RepairRecordWhereInput
    orderBy?: Enumerable<RepairRecordOrderByWithRelationInput>
    cursor?: RepairRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<RepairRecordScalarFieldEnum>
  }


  /**
   * Equipment without action
   */
  export type EquipmentArgs = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EquipmentInclude | null
  }



  /**
   * Model RepairMaterial
   */


  export type AggregateRepairMaterial = {
    _count: RepairMaterialCountAggregateOutputType | null
    _avg: RepairMaterialAvgAggregateOutputType | null
    _sum: RepairMaterialSumAggregateOutputType | null
    _min: RepairMaterialMinAggregateOutputType | null
    _max: RepairMaterialMaxAggregateOutputType | null
  }

  export type RepairMaterialAvgAggregateOutputType = {
    id: number | null
  }

  export type RepairMaterialSumAggregateOutputType = {
    id: number | null
  }

  export type RepairMaterialMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    name: string | null
    description: string | null
  }

  export type RepairMaterialMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    name: string | null
    description: string | null
  }

  export type RepairMaterialCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    isDeleted: number
    name: number
    description: number
    _all: number
  }


  export type RepairMaterialAvgAggregateInputType = {
    id?: true
  }

  export type RepairMaterialSumAggregateInputType = {
    id?: true
  }

  export type RepairMaterialMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    name?: true
    description?: true
  }

  export type RepairMaterialMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    name?: true
    description?: true
  }

  export type RepairMaterialCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    name?: true
    description?: true
    _all?: true
  }

  export type RepairMaterialAggregateArgs = {
    /**
     * Filter which RepairMaterial to aggregate.
     */
    where?: RepairMaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RepairMaterials to fetch.
     */
    orderBy?: Enumerable<RepairMaterialOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RepairMaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RepairMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RepairMaterials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RepairMaterials
    **/
    _count?: true | RepairMaterialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RepairMaterialAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RepairMaterialSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RepairMaterialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RepairMaterialMaxAggregateInputType
  }

  export type GetRepairMaterialAggregateType<T extends RepairMaterialAggregateArgs> = {
        [P in keyof T & keyof AggregateRepairMaterial]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRepairMaterial[P]>
      : GetScalarType<T[P], AggregateRepairMaterial[P]>
  }




  export type RepairMaterialGroupByArgs = {
    where?: RepairMaterialWhereInput
    orderBy?: Enumerable<RepairMaterialOrderByWithAggregationInput>
    by: RepairMaterialScalarFieldEnum[]
    having?: RepairMaterialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RepairMaterialCountAggregateInputType | true
    _avg?: RepairMaterialAvgAggregateInputType
    _sum?: RepairMaterialSumAggregateInputType
    _min?: RepairMaterialMinAggregateInputType
    _max?: RepairMaterialMaxAggregateInputType
  }


  export type RepairMaterialGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    isDeleted: boolean
    name: string
    description: string | null
    _count: RepairMaterialCountAggregateOutputType | null
    _avg: RepairMaterialAvgAggregateOutputType | null
    _sum: RepairMaterialSumAggregateOutputType | null
    _min: RepairMaterialMinAggregateOutputType | null
    _max: RepairMaterialMaxAggregateOutputType | null
  }

  type GetRepairMaterialGroupByPayload<T extends RepairMaterialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<RepairMaterialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RepairMaterialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RepairMaterialGroupByOutputType[P]>
            : GetScalarType<T[P], RepairMaterialGroupByOutputType[P]>
        }
      >
    >


  export type RepairMaterialSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    name?: boolean
    description?: boolean
    inventory?: boolean | RepairMaterialInventoryArgs
  }


  export type RepairMaterialInclude = {
    inventory?: boolean | RepairMaterialInventoryArgs
  }

  export type RepairMaterialGetPayload<S extends boolean | null | undefined | RepairMaterialArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? RepairMaterial :
    S extends undefined ? never :
    S extends { include: any } & (RepairMaterialArgs | RepairMaterialFindManyArgs)
    ? RepairMaterial  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'inventory' ? RepairMaterialInventoryGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (RepairMaterialArgs | RepairMaterialFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'inventory' ? RepairMaterialInventoryGetPayload<S['select'][P]> | null :  P extends keyof RepairMaterial ? RepairMaterial[P] : never
  } 
      : RepairMaterial


  type RepairMaterialCountArgs = 
    Omit<RepairMaterialFindManyArgs, 'select' | 'include'> & {
      select?: RepairMaterialCountAggregateInputType | true
    }

  export interface RepairMaterialDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one RepairMaterial that matches the filter.
     * @param {RepairMaterialFindUniqueArgs} args - Arguments to find a RepairMaterial
     * @example
     * // Get one RepairMaterial
     * const repairMaterial = await prisma.repairMaterial.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RepairMaterialFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RepairMaterialFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'RepairMaterial'> extends True ? Prisma__RepairMaterialClient<RepairMaterialGetPayload<T>> : Prisma__RepairMaterialClient<RepairMaterialGetPayload<T> | null, null>

    /**
     * Find one RepairMaterial that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RepairMaterialFindUniqueOrThrowArgs} args - Arguments to find a RepairMaterial
     * @example
     * // Get one RepairMaterial
     * const repairMaterial = await prisma.repairMaterial.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RepairMaterialFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, RepairMaterialFindUniqueOrThrowArgs>
    ): Prisma__RepairMaterialClient<RepairMaterialGetPayload<T>>

    /**
     * Find the first RepairMaterial that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairMaterialFindFirstArgs} args - Arguments to find a RepairMaterial
     * @example
     * // Get one RepairMaterial
     * const repairMaterial = await prisma.repairMaterial.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RepairMaterialFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RepairMaterialFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'RepairMaterial'> extends True ? Prisma__RepairMaterialClient<RepairMaterialGetPayload<T>> : Prisma__RepairMaterialClient<RepairMaterialGetPayload<T> | null, null>

    /**
     * Find the first RepairMaterial that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairMaterialFindFirstOrThrowArgs} args - Arguments to find a RepairMaterial
     * @example
     * // Get one RepairMaterial
     * const repairMaterial = await prisma.repairMaterial.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RepairMaterialFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RepairMaterialFindFirstOrThrowArgs>
    ): Prisma__RepairMaterialClient<RepairMaterialGetPayload<T>>

    /**
     * Find zero or more RepairMaterials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairMaterialFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RepairMaterials
     * const repairMaterials = await prisma.repairMaterial.findMany()
     * 
     * // Get first 10 RepairMaterials
     * const repairMaterials = await prisma.repairMaterial.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const repairMaterialWithIdOnly = await prisma.repairMaterial.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RepairMaterialFindManyArgs>(
      args?: SelectSubset<T, RepairMaterialFindManyArgs>
    ): Prisma.PrismaPromise<Array<RepairMaterialGetPayload<T>>>

    /**
     * Create a RepairMaterial.
     * @param {RepairMaterialCreateArgs} args - Arguments to create a RepairMaterial.
     * @example
     * // Create one RepairMaterial
     * const RepairMaterial = await prisma.repairMaterial.create({
     *   data: {
     *     // ... data to create a RepairMaterial
     *   }
     * })
     * 
    **/
    create<T extends RepairMaterialCreateArgs>(
      args: SelectSubset<T, RepairMaterialCreateArgs>
    ): Prisma__RepairMaterialClient<RepairMaterialGetPayload<T>>

    /**
     * Create many RepairMaterials.
     *     @param {RepairMaterialCreateManyArgs} args - Arguments to create many RepairMaterials.
     *     @example
     *     // Create many RepairMaterials
     *     const repairMaterial = await prisma.repairMaterial.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RepairMaterialCreateManyArgs>(
      args?: SelectSubset<T, RepairMaterialCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RepairMaterial.
     * @param {RepairMaterialDeleteArgs} args - Arguments to delete one RepairMaterial.
     * @example
     * // Delete one RepairMaterial
     * const RepairMaterial = await prisma.repairMaterial.delete({
     *   where: {
     *     // ... filter to delete one RepairMaterial
     *   }
     * })
     * 
    **/
    delete<T extends RepairMaterialDeleteArgs>(
      args: SelectSubset<T, RepairMaterialDeleteArgs>
    ): Prisma__RepairMaterialClient<RepairMaterialGetPayload<T>>

    /**
     * Update one RepairMaterial.
     * @param {RepairMaterialUpdateArgs} args - Arguments to update one RepairMaterial.
     * @example
     * // Update one RepairMaterial
     * const repairMaterial = await prisma.repairMaterial.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RepairMaterialUpdateArgs>(
      args: SelectSubset<T, RepairMaterialUpdateArgs>
    ): Prisma__RepairMaterialClient<RepairMaterialGetPayload<T>>

    /**
     * Delete zero or more RepairMaterials.
     * @param {RepairMaterialDeleteManyArgs} args - Arguments to filter RepairMaterials to delete.
     * @example
     * // Delete a few RepairMaterials
     * const { count } = await prisma.repairMaterial.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RepairMaterialDeleteManyArgs>(
      args?: SelectSubset<T, RepairMaterialDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RepairMaterials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairMaterialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RepairMaterials
     * const repairMaterial = await prisma.repairMaterial.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RepairMaterialUpdateManyArgs>(
      args: SelectSubset<T, RepairMaterialUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RepairMaterial.
     * @param {RepairMaterialUpsertArgs} args - Arguments to update or create a RepairMaterial.
     * @example
     * // Update or create a RepairMaterial
     * const repairMaterial = await prisma.repairMaterial.upsert({
     *   create: {
     *     // ... data to create a RepairMaterial
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RepairMaterial we want to update
     *   }
     * })
    **/
    upsert<T extends RepairMaterialUpsertArgs>(
      args: SelectSubset<T, RepairMaterialUpsertArgs>
    ): Prisma__RepairMaterialClient<RepairMaterialGetPayload<T>>

    /**
     * Count the number of RepairMaterials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairMaterialCountArgs} args - Arguments to filter RepairMaterials to count.
     * @example
     * // Count the number of RepairMaterials
     * const count = await prisma.repairMaterial.count({
     *   where: {
     *     // ... the filter for the RepairMaterials we want to count
     *   }
     * })
    **/
    count<T extends RepairMaterialCountArgs>(
      args?: Subset<T, RepairMaterialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RepairMaterialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RepairMaterial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairMaterialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RepairMaterialAggregateArgs>(args: Subset<T, RepairMaterialAggregateArgs>): Prisma.PrismaPromise<GetRepairMaterialAggregateType<T>>

    /**
     * Group by RepairMaterial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairMaterialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RepairMaterialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RepairMaterialGroupByArgs['orderBy'] }
        : { orderBy?: RepairMaterialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RepairMaterialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRepairMaterialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for RepairMaterial.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RepairMaterialClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    inventory<T extends RepairMaterialInventoryArgs= {}>(args?: Subset<T, RepairMaterialInventoryArgs>): Prisma__RepairMaterialInventoryClient<RepairMaterialInventoryGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * RepairMaterial base type for findUnique actions
   */
  export type RepairMaterialFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the RepairMaterial
     */
    select?: RepairMaterialSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairMaterialInclude | null
    /**
     * Filter, which RepairMaterial to fetch.
     */
    where: RepairMaterialWhereUniqueInput
  }

  /**
   * RepairMaterial findUnique
   */
  export interface RepairMaterialFindUniqueArgs extends RepairMaterialFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RepairMaterial findUniqueOrThrow
   */
  export type RepairMaterialFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the RepairMaterial
     */
    select?: RepairMaterialSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairMaterialInclude | null
    /**
     * Filter, which RepairMaterial to fetch.
     */
    where: RepairMaterialWhereUniqueInput
  }


  /**
   * RepairMaterial base type for findFirst actions
   */
  export type RepairMaterialFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the RepairMaterial
     */
    select?: RepairMaterialSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairMaterialInclude | null
    /**
     * Filter, which RepairMaterial to fetch.
     */
    where?: RepairMaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RepairMaterials to fetch.
     */
    orderBy?: Enumerable<RepairMaterialOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RepairMaterials.
     */
    cursor?: RepairMaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RepairMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RepairMaterials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RepairMaterials.
     */
    distinct?: Enumerable<RepairMaterialScalarFieldEnum>
  }

  /**
   * RepairMaterial findFirst
   */
  export interface RepairMaterialFindFirstArgs extends RepairMaterialFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RepairMaterial findFirstOrThrow
   */
  export type RepairMaterialFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the RepairMaterial
     */
    select?: RepairMaterialSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairMaterialInclude | null
    /**
     * Filter, which RepairMaterial to fetch.
     */
    where?: RepairMaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RepairMaterials to fetch.
     */
    orderBy?: Enumerable<RepairMaterialOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RepairMaterials.
     */
    cursor?: RepairMaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RepairMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RepairMaterials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RepairMaterials.
     */
    distinct?: Enumerable<RepairMaterialScalarFieldEnum>
  }


  /**
   * RepairMaterial findMany
   */
  export type RepairMaterialFindManyArgs = {
    /**
     * Select specific fields to fetch from the RepairMaterial
     */
    select?: RepairMaterialSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairMaterialInclude | null
    /**
     * Filter, which RepairMaterials to fetch.
     */
    where?: RepairMaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RepairMaterials to fetch.
     */
    orderBy?: Enumerable<RepairMaterialOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RepairMaterials.
     */
    cursor?: RepairMaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RepairMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RepairMaterials.
     */
    skip?: number
    distinct?: Enumerable<RepairMaterialScalarFieldEnum>
  }


  /**
   * RepairMaterial create
   */
  export type RepairMaterialCreateArgs = {
    /**
     * Select specific fields to fetch from the RepairMaterial
     */
    select?: RepairMaterialSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairMaterialInclude | null
    /**
     * The data needed to create a RepairMaterial.
     */
    data: XOR<RepairMaterialCreateInput, RepairMaterialUncheckedCreateInput>
  }


  /**
   * RepairMaterial createMany
   */
  export type RepairMaterialCreateManyArgs = {
    /**
     * The data used to create many RepairMaterials.
     */
    data: Enumerable<RepairMaterialCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * RepairMaterial update
   */
  export type RepairMaterialUpdateArgs = {
    /**
     * Select specific fields to fetch from the RepairMaterial
     */
    select?: RepairMaterialSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairMaterialInclude | null
    /**
     * The data needed to update a RepairMaterial.
     */
    data: XOR<RepairMaterialUpdateInput, RepairMaterialUncheckedUpdateInput>
    /**
     * Choose, which RepairMaterial to update.
     */
    where: RepairMaterialWhereUniqueInput
  }


  /**
   * RepairMaterial updateMany
   */
  export type RepairMaterialUpdateManyArgs = {
    /**
     * The data used to update RepairMaterials.
     */
    data: XOR<RepairMaterialUpdateManyMutationInput, RepairMaterialUncheckedUpdateManyInput>
    /**
     * Filter which RepairMaterials to update
     */
    where?: RepairMaterialWhereInput
  }


  /**
   * RepairMaterial upsert
   */
  export type RepairMaterialUpsertArgs = {
    /**
     * Select specific fields to fetch from the RepairMaterial
     */
    select?: RepairMaterialSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairMaterialInclude | null
    /**
     * The filter to search for the RepairMaterial to update in case it exists.
     */
    where: RepairMaterialWhereUniqueInput
    /**
     * In case the RepairMaterial found by the `where` argument doesn't exist, create a new RepairMaterial with this data.
     */
    create: XOR<RepairMaterialCreateInput, RepairMaterialUncheckedCreateInput>
    /**
     * In case the RepairMaterial was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RepairMaterialUpdateInput, RepairMaterialUncheckedUpdateInput>
  }


  /**
   * RepairMaterial delete
   */
  export type RepairMaterialDeleteArgs = {
    /**
     * Select specific fields to fetch from the RepairMaterial
     */
    select?: RepairMaterialSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairMaterialInclude | null
    /**
     * Filter which RepairMaterial to delete.
     */
    where: RepairMaterialWhereUniqueInput
  }


  /**
   * RepairMaterial deleteMany
   */
  export type RepairMaterialDeleteManyArgs = {
    /**
     * Filter which RepairMaterials to delete
     */
    where?: RepairMaterialWhereInput
  }


  /**
   * RepairMaterial without action
   */
  export type RepairMaterialArgs = {
    /**
     * Select specific fields to fetch from the RepairMaterial
     */
    select?: RepairMaterialSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairMaterialInclude | null
  }



  /**
   * Model RepairPlan
   */


  export type AggregateRepairPlan = {
    _count: RepairPlanCountAggregateOutputType | null
    _avg: RepairPlanAvgAggregateOutputType | null
    _sum: RepairPlanSumAggregateOutputType | null
    _min: RepairPlanMinAggregateOutputType | null
    _max: RepairPlanMaxAggregateOutputType | null
  }

  export type RepairPlanAvgAggregateOutputType = {
    id: number | null
    equimentId: number | null
  }

  export type RepairPlanSumAggregateOutputType = {
    id: number | null
    equimentId: number | null
  }

  export type RepairPlanMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    description: string | null
    equimentId: number | null
  }

  export type RepairPlanMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    description: string | null
    equimentId: number | null
  }

  export type RepairPlanCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    isDeleted: number
    description: number
    equimentId: number
    _all: number
  }


  export type RepairPlanAvgAggregateInputType = {
    id?: true
    equimentId?: true
  }

  export type RepairPlanSumAggregateInputType = {
    id?: true
    equimentId?: true
  }

  export type RepairPlanMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    description?: true
    equimentId?: true
  }

  export type RepairPlanMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    description?: true
    equimentId?: true
  }

  export type RepairPlanCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    description?: true
    equimentId?: true
    _all?: true
  }

  export type RepairPlanAggregateArgs = {
    /**
     * Filter which RepairPlan to aggregate.
     */
    where?: RepairPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RepairPlans to fetch.
     */
    orderBy?: Enumerable<RepairPlanOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RepairPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RepairPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RepairPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RepairPlans
    **/
    _count?: true | RepairPlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RepairPlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RepairPlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RepairPlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RepairPlanMaxAggregateInputType
  }

  export type GetRepairPlanAggregateType<T extends RepairPlanAggregateArgs> = {
        [P in keyof T & keyof AggregateRepairPlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRepairPlan[P]>
      : GetScalarType<T[P], AggregateRepairPlan[P]>
  }




  export type RepairPlanGroupByArgs = {
    where?: RepairPlanWhereInput
    orderBy?: Enumerable<RepairPlanOrderByWithAggregationInput>
    by: RepairPlanScalarFieldEnum[]
    having?: RepairPlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RepairPlanCountAggregateInputType | true
    _avg?: RepairPlanAvgAggregateInputType
    _sum?: RepairPlanSumAggregateInputType
    _min?: RepairPlanMinAggregateInputType
    _max?: RepairPlanMaxAggregateInputType
  }


  export type RepairPlanGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    isDeleted: boolean
    description: string | null
    equimentId: number
    _count: RepairPlanCountAggregateOutputType | null
    _avg: RepairPlanAvgAggregateOutputType | null
    _sum: RepairPlanSumAggregateOutputType | null
    _min: RepairPlanMinAggregateOutputType | null
    _max: RepairPlanMaxAggregateOutputType | null
  }

  type GetRepairPlanGroupByPayload<T extends RepairPlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<RepairPlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RepairPlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RepairPlanGroupByOutputType[P]>
            : GetScalarType<T[P], RepairPlanGroupByOutputType[P]>
        }
      >
    >


  export type RepairPlanSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    description?: boolean
    equimentId?: boolean
    equipment?: boolean | EquipmentArgs
  }


  export type RepairPlanInclude = {
    equipment?: boolean | EquipmentArgs
  }

  export type RepairPlanGetPayload<S extends boolean | null | undefined | RepairPlanArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? RepairPlan :
    S extends undefined ? never :
    S extends { include: any } & (RepairPlanArgs | RepairPlanFindManyArgs)
    ? RepairPlan  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'equipment' ? EquipmentGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (RepairPlanArgs | RepairPlanFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'equipment' ? EquipmentGetPayload<S['select'][P]> :  P extends keyof RepairPlan ? RepairPlan[P] : never
  } 
      : RepairPlan


  type RepairPlanCountArgs = 
    Omit<RepairPlanFindManyArgs, 'select' | 'include'> & {
      select?: RepairPlanCountAggregateInputType | true
    }

  export interface RepairPlanDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one RepairPlan that matches the filter.
     * @param {RepairPlanFindUniqueArgs} args - Arguments to find a RepairPlan
     * @example
     * // Get one RepairPlan
     * const repairPlan = await prisma.repairPlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RepairPlanFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RepairPlanFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'RepairPlan'> extends True ? Prisma__RepairPlanClient<RepairPlanGetPayload<T>> : Prisma__RepairPlanClient<RepairPlanGetPayload<T> | null, null>

    /**
     * Find one RepairPlan that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RepairPlanFindUniqueOrThrowArgs} args - Arguments to find a RepairPlan
     * @example
     * // Get one RepairPlan
     * const repairPlan = await prisma.repairPlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RepairPlanFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, RepairPlanFindUniqueOrThrowArgs>
    ): Prisma__RepairPlanClient<RepairPlanGetPayload<T>>

    /**
     * Find the first RepairPlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairPlanFindFirstArgs} args - Arguments to find a RepairPlan
     * @example
     * // Get one RepairPlan
     * const repairPlan = await prisma.repairPlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RepairPlanFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RepairPlanFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'RepairPlan'> extends True ? Prisma__RepairPlanClient<RepairPlanGetPayload<T>> : Prisma__RepairPlanClient<RepairPlanGetPayload<T> | null, null>

    /**
     * Find the first RepairPlan that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairPlanFindFirstOrThrowArgs} args - Arguments to find a RepairPlan
     * @example
     * // Get one RepairPlan
     * const repairPlan = await prisma.repairPlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RepairPlanFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RepairPlanFindFirstOrThrowArgs>
    ): Prisma__RepairPlanClient<RepairPlanGetPayload<T>>

    /**
     * Find zero or more RepairPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairPlanFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RepairPlans
     * const repairPlans = await prisma.repairPlan.findMany()
     * 
     * // Get first 10 RepairPlans
     * const repairPlans = await prisma.repairPlan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const repairPlanWithIdOnly = await prisma.repairPlan.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RepairPlanFindManyArgs>(
      args?: SelectSubset<T, RepairPlanFindManyArgs>
    ): Prisma.PrismaPromise<Array<RepairPlanGetPayload<T>>>

    /**
     * Create a RepairPlan.
     * @param {RepairPlanCreateArgs} args - Arguments to create a RepairPlan.
     * @example
     * // Create one RepairPlan
     * const RepairPlan = await prisma.repairPlan.create({
     *   data: {
     *     // ... data to create a RepairPlan
     *   }
     * })
     * 
    **/
    create<T extends RepairPlanCreateArgs>(
      args: SelectSubset<T, RepairPlanCreateArgs>
    ): Prisma__RepairPlanClient<RepairPlanGetPayload<T>>

    /**
     * Create many RepairPlans.
     *     @param {RepairPlanCreateManyArgs} args - Arguments to create many RepairPlans.
     *     @example
     *     // Create many RepairPlans
     *     const repairPlan = await prisma.repairPlan.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RepairPlanCreateManyArgs>(
      args?: SelectSubset<T, RepairPlanCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RepairPlan.
     * @param {RepairPlanDeleteArgs} args - Arguments to delete one RepairPlan.
     * @example
     * // Delete one RepairPlan
     * const RepairPlan = await prisma.repairPlan.delete({
     *   where: {
     *     // ... filter to delete one RepairPlan
     *   }
     * })
     * 
    **/
    delete<T extends RepairPlanDeleteArgs>(
      args: SelectSubset<T, RepairPlanDeleteArgs>
    ): Prisma__RepairPlanClient<RepairPlanGetPayload<T>>

    /**
     * Update one RepairPlan.
     * @param {RepairPlanUpdateArgs} args - Arguments to update one RepairPlan.
     * @example
     * // Update one RepairPlan
     * const repairPlan = await prisma.repairPlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RepairPlanUpdateArgs>(
      args: SelectSubset<T, RepairPlanUpdateArgs>
    ): Prisma__RepairPlanClient<RepairPlanGetPayload<T>>

    /**
     * Delete zero or more RepairPlans.
     * @param {RepairPlanDeleteManyArgs} args - Arguments to filter RepairPlans to delete.
     * @example
     * // Delete a few RepairPlans
     * const { count } = await prisma.repairPlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RepairPlanDeleteManyArgs>(
      args?: SelectSubset<T, RepairPlanDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RepairPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairPlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RepairPlans
     * const repairPlan = await prisma.repairPlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RepairPlanUpdateManyArgs>(
      args: SelectSubset<T, RepairPlanUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RepairPlan.
     * @param {RepairPlanUpsertArgs} args - Arguments to update or create a RepairPlan.
     * @example
     * // Update or create a RepairPlan
     * const repairPlan = await prisma.repairPlan.upsert({
     *   create: {
     *     // ... data to create a RepairPlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RepairPlan we want to update
     *   }
     * })
    **/
    upsert<T extends RepairPlanUpsertArgs>(
      args: SelectSubset<T, RepairPlanUpsertArgs>
    ): Prisma__RepairPlanClient<RepairPlanGetPayload<T>>

    /**
     * Count the number of RepairPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairPlanCountArgs} args - Arguments to filter RepairPlans to count.
     * @example
     * // Count the number of RepairPlans
     * const count = await prisma.repairPlan.count({
     *   where: {
     *     // ... the filter for the RepairPlans we want to count
     *   }
     * })
    **/
    count<T extends RepairPlanCountArgs>(
      args?: Subset<T, RepairPlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RepairPlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RepairPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairPlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RepairPlanAggregateArgs>(args: Subset<T, RepairPlanAggregateArgs>): Prisma.PrismaPromise<GetRepairPlanAggregateType<T>>

    /**
     * Group by RepairPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairPlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RepairPlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RepairPlanGroupByArgs['orderBy'] }
        : { orderBy?: RepairPlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RepairPlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRepairPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for RepairPlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RepairPlanClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    equipment<T extends EquipmentArgs= {}>(args?: Subset<T, EquipmentArgs>): Prisma__EquipmentClient<EquipmentGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * RepairPlan base type for findUnique actions
   */
  export type RepairPlanFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the RepairPlan
     */
    select?: RepairPlanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairPlanInclude | null
    /**
     * Filter, which RepairPlan to fetch.
     */
    where: RepairPlanWhereUniqueInput
  }

  /**
   * RepairPlan findUnique
   */
  export interface RepairPlanFindUniqueArgs extends RepairPlanFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RepairPlan findUniqueOrThrow
   */
  export type RepairPlanFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the RepairPlan
     */
    select?: RepairPlanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairPlanInclude | null
    /**
     * Filter, which RepairPlan to fetch.
     */
    where: RepairPlanWhereUniqueInput
  }


  /**
   * RepairPlan base type for findFirst actions
   */
  export type RepairPlanFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the RepairPlan
     */
    select?: RepairPlanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairPlanInclude | null
    /**
     * Filter, which RepairPlan to fetch.
     */
    where?: RepairPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RepairPlans to fetch.
     */
    orderBy?: Enumerable<RepairPlanOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RepairPlans.
     */
    cursor?: RepairPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RepairPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RepairPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RepairPlans.
     */
    distinct?: Enumerable<RepairPlanScalarFieldEnum>
  }

  /**
   * RepairPlan findFirst
   */
  export interface RepairPlanFindFirstArgs extends RepairPlanFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RepairPlan findFirstOrThrow
   */
  export type RepairPlanFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the RepairPlan
     */
    select?: RepairPlanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairPlanInclude | null
    /**
     * Filter, which RepairPlan to fetch.
     */
    where?: RepairPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RepairPlans to fetch.
     */
    orderBy?: Enumerable<RepairPlanOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RepairPlans.
     */
    cursor?: RepairPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RepairPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RepairPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RepairPlans.
     */
    distinct?: Enumerable<RepairPlanScalarFieldEnum>
  }


  /**
   * RepairPlan findMany
   */
  export type RepairPlanFindManyArgs = {
    /**
     * Select specific fields to fetch from the RepairPlan
     */
    select?: RepairPlanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairPlanInclude | null
    /**
     * Filter, which RepairPlans to fetch.
     */
    where?: RepairPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RepairPlans to fetch.
     */
    orderBy?: Enumerable<RepairPlanOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RepairPlans.
     */
    cursor?: RepairPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RepairPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RepairPlans.
     */
    skip?: number
    distinct?: Enumerable<RepairPlanScalarFieldEnum>
  }


  /**
   * RepairPlan create
   */
  export type RepairPlanCreateArgs = {
    /**
     * Select specific fields to fetch from the RepairPlan
     */
    select?: RepairPlanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairPlanInclude | null
    /**
     * The data needed to create a RepairPlan.
     */
    data: XOR<RepairPlanCreateInput, RepairPlanUncheckedCreateInput>
  }


  /**
   * RepairPlan createMany
   */
  export type RepairPlanCreateManyArgs = {
    /**
     * The data used to create many RepairPlans.
     */
    data: Enumerable<RepairPlanCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * RepairPlan update
   */
  export type RepairPlanUpdateArgs = {
    /**
     * Select specific fields to fetch from the RepairPlan
     */
    select?: RepairPlanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairPlanInclude | null
    /**
     * The data needed to update a RepairPlan.
     */
    data: XOR<RepairPlanUpdateInput, RepairPlanUncheckedUpdateInput>
    /**
     * Choose, which RepairPlan to update.
     */
    where: RepairPlanWhereUniqueInput
  }


  /**
   * RepairPlan updateMany
   */
  export type RepairPlanUpdateManyArgs = {
    /**
     * The data used to update RepairPlans.
     */
    data: XOR<RepairPlanUpdateManyMutationInput, RepairPlanUncheckedUpdateManyInput>
    /**
     * Filter which RepairPlans to update
     */
    where?: RepairPlanWhereInput
  }


  /**
   * RepairPlan upsert
   */
  export type RepairPlanUpsertArgs = {
    /**
     * Select specific fields to fetch from the RepairPlan
     */
    select?: RepairPlanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairPlanInclude | null
    /**
     * The filter to search for the RepairPlan to update in case it exists.
     */
    where: RepairPlanWhereUniqueInput
    /**
     * In case the RepairPlan found by the `where` argument doesn't exist, create a new RepairPlan with this data.
     */
    create: XOR<RepairPlanCreateInput, RepairPlanUncheckedCreateInput>
    /**
     * In case the RepairPlan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RepairPlanUpdateInput, RepairPlanUncheckedUpdateInput>
  }


  /**
   * RepairPlan delete
   */
  export type RepairPlanDeleteArgs = {
    /**
     * Select specific fields to fetch from the RepairPlan
     */
    select?: RepairPlanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairPlanInclude | null
    /**
     * Filter which RepairPlan to delete.
     */
    where: RepairPlanWhereUniqueInput
  }


  /**
   * RepairPlan deleteMany
   */
  export type RepairPlanDeleteManyArgs = {
    /**
     * Filter which RepairPlans to delete
     */
    where?: RepairPlanWhereInput
  }


  /**
   * RepairPlan without action
   */
  export type RepairPlanArgs = {
    /**
     * Select specific fields to fetch from the RepairPlan
     */
    select?: RepairPlanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairPlanInclude | null
  }



  /**
   * Model RepairMaterialInventory
   */


  export type AggregateRepairMaterialInventory = {
    _count: RepairMaterialInventoryCountAggregateOutputType | null
    _avg: RepairMaterialInventoryAvgAggregateOutputType | null
    _sum: RepairMaterialInventorySumAggregateOutputType | null
    _min: RepairMaterialInventoryMinAggregateOutputType | null
    _max: RepairMaterialInventoryMaxAggregateOutputType | null
  }

  export type RepairMaterialInventoryAvgAggregateOutputType = {
    id: number | null
    materialId: number | null
    quantity: number | null
  }

  export type RepairMaterialInventorySumAggregateOutputType = {
    id: number | null
    materialId: number | null
    quantity: number | null
  }

  export type RepairMaterialInventoryMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    materialId: number | null
    quantity: number | null
  }

  export type RepairMaterialInventoryMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    materialId: number | null
    quantity: number | null
  }

  export type RepairMaterialInventoryCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    isDeleted: number
    materialId: number
    quantity: number
    _all: number
  }


  export type RepairMaterialInventoryAvgAggregateInputType = {
    id?: true
    materialId?: true
    quantity?: true
  }

  export type RepairMaterialInventorySumAggregateInputType = {
    id?: true
    materialId?: true
    quantity?: true
  }

  export type RepairMaterialInventoryMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    materialId?: true
    quantity?: true
  }

  export type RepairMaterialInventoryMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    materialId?: true
    quantity?: true
  }

  export type RepairMaterialInventoryCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    materialId?: true
    quantity?: true
    _all?: true
  }

  export type RepairMaterialInventoryAggregateArgs = {
    /**
     * Filter which RepairMaterialInventory to aggregate.
     */
    where?: RepairMaterialInventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RepairMaterialInventories to fetch.
     */
    orderBy?: Enumerable<RepairMaterialInventoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RepairMaterialInventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RepairMaterialInventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RepairMaterialInventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RepairMaterialInventories
    **/
    _count?: true | RepairMaterialInventoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RepairMaterialInventoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RepairMaterialInventorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RepairMaterialInventoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RepairMaterialInventoryMaxAggregateInputType
  }

  export type GetRepairMaterialInventoryAggregateType<T extends RepairMaterialInventoryAggregateArgs> = {
        [P in keyof T & keyof AggregateRepairMaterialInventory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRepairMaterialInventory[P]>
      : GetScalarType<T[P], AggregateRepairMaterialInventory[P]>
  }




  export type RepairMaterialInventoryGroupByArgs = {
    where?: RepairMaterialInventoryWhereInput
    orderBy?: Enumerable<RepairMaterialInventoryOrderByWithAggregationInput>
    by: RepairMaterialInventoryScalarFieldEnum[]
    having?: RepairMaterialInventoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RepairMaterialInventoryCountAggregateInputType | true
    _avg?: RepairMaterialInventoryAvgAggregateInputType
    _sum?: RepairMaterialInventorySumAggregateInputType
    _min?: RepairMaterialInventoryMinAggregateInputType
    _max?: RepairMaterialInventoryMaxAggregateInputType
  }


  export type RepairMaterialInventoryGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    isDeleted: boolean
    materialId: number
    quantity: number
    _count: RepairMaterialInventoryCountAggregateOutputType | null
    _avg: RepairMaterialInventoryAvgAggregateOutputType | null
    _sum: RepairMaterialInventorySumAggregateOutputType | null
    _min: RepairMaterialInventoryMinAggregateOutputType | null
    _max: RepairMaterialInventoryMaxAggregateOutputType | null
  }

  type GetRepairMaterialInventoryGroupByPayload<T extends RepairMaterialInventoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<RepairMaterialInventoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RepairMaterialInventoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RepairMaterialInventoryGroupByOutputType[P]>
            : GetScalarType<T[P], RepairMaterialInventoryGroupByOutputType[P]>
        }
      >
    >


  export type RepairMaterialInventorySelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    materialId?: boolean
    quantity?: boolean
    repairMaterial?: boolean | RepairMaterialArgs
  }


  export type RepairMaterialInventoryInclude = {
    repairMaterial?: boolean | RepairMaterialArgs
  }

  export type RepairMaterialInventoryGetPayload<S extends boolean | null | undefined | RepairMaterialInventoryArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? RepairMaterialInventory :
    S extends undefined ? never :
    S extends { include: any } & (RepairMaterialInventoryArgs | RepairMaterialInventoryFindManyArgs)
    ? RepairMaterialInventory  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'repairMaterial' ? RepairMaterialGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (RepairMaterialInventoryArgs | RepairMaterialInventoryFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'repairMaterial' ? RepairMaterialGetPayload<S['select'][P]> :  P extends keyof RepairMaterialInventory ? RepairMaterialInventory[P] : never
  } 
      : RepairMaterialInventory


  type RepairMaterialInventoryCountArgs = 
    Omit<RepairMaterialInventoryFindManyArgs, 'select' | 'include'> & {
      select?: RepairMaterialInventoryCountAggregateInputType | true
    }

  export interface RepairMaterialInventoryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one RepairMaterialInventory that matches the filter.
     * @param {RepairMaterialInventoryFindUniqueArgs} args - Arguments to find a RepairMaterialInventory
     * @example
     * // Get one RepairMaterialInventory
     * const repairMaterialInventory = await prisma.repairMaterialInventory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RepairMaterialInventoryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RepairMaterialInventoryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'RepairMaterialInventory'> extends True ? Prisma__RepairMaterialInventoryClient<RepairMaterialInventoryGetPayload<T>> : Prisma__RepairMaterialInventoryClient<RepairMaterialInventoryGetPayload<T> | null, null>

    /**
     * Find one RepairMaterialInventory that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RepairMaterialInventoryFindUniqueOrThrowArgs} args - Arguments to find a RepairMaterialInventory
     * @example
     * // Get one RepairMaterialInventory
     * const repairMaterialInventory = await prisma.repairMaterialInventory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RepairMaterialInventoryFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, RepairMaterialInventoryFindUniqueOrThrowArgs>
    ): Prisma__RepairMaterialInventoryClient<RepairMaterialInventoryGetPayload<T>>

    /**
     * Find the first RepairMaterialInventory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairMaterialInventoryFindFirstArgs} args - Arguments to find a RepairMaterialInventory
     * @example
     * // Get one RepairMaterialInventory
     * const repairMaterialInventory = await prisma.repairMaterialInventory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RepairMaterialInventoryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RepairMaterialInventoryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'RepairMaterialInventory'> extends True ? Prisma__RepairMaterialInventoryClient<RepairMaterialInventoryGetPayload<T>> : Prisma__RepairMaterialInventoryClient<RepairMaterialInventoryGetPayload<T> | null, null>

    /**
     * Find the first RepairMaterialInventory that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairMaterialInventoryFindFirstOrThrowArgs} args - Arguments to find a RepairMaterialInventory
     * @example
     * // Get one RepairMaterialInventory
     * const repairMaterialInventory = await prisma.repairMaterialInventory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RepairMaterialInventoryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RepairMaterialInventoryFindFirstOrThrowArgs>
    ): Prisma__RepairMaterialInventoryClient<RepairMaterialInventoryGetPayload<T>>

    /**
     * Find zero or more RepairMaterialInventories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairMaterialInventoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RepairMaterialInventories
     * const repairMaterialInventories = await prisma.repairMaterialInventory.findMany()
     * 
     * // Get first 10 RepairMaterialInventories
     * const repairMaterialInventories = await prisma.repairMaterialInventory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const repairMaterialInventoryWithIdOnly = await prisma.repairMaterialInventory.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RepairMaterialInventoryFindManyArgs>(
      args?: SelectSubset<T, RepairMaterialInventoryFindManyArgs>
    ): Prisma.PrismaPromise<Array<RepairMaterialInventoryGetPayload<T>>>

    /**
     * Create a RepairMaterialInventory.
     * @param {RepairMaterialInventoryCreateArgs} args - Arguments to create a RepairMaterialInventory.
     * @example
     * // Create one RepairMaterialInventory
     * const RepairMaterialInventory = await prisma.repairMaterialInventory.create({
     *   data: {
     *     // ... data to create a RepairMaterialInventory
     *   }
     * })
     * 
    **/
    create<T extends RepairMaterialInventoryCreateArgs>(
      args: SelectSubset<T, RepairMaterialInventoryCreateArgs>
    ): Prisma__RepairMaterialInventoryClient<RepairMaterialInventoryGetPayload<T>>

    /**
     * Create many RepairMaterialInventories.
     *     @param {RepairMaterialInventoryCreateManyArgs} args - Arguments to create many RepairMaterialInventories.
     *     @example
     *     // Create many RepairMaterialInventories
     *     const repairMaterialInventory = await prisma.repairMaterialInventory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RepairMaterialInventoryCreateManyArgs>(
      args?: SelectSubset<T, RepairMaterialInventoryCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RepairMaterialInventory.
     * @param {RepairMaterialInventoryDeleteArgs} args - Arguments to delete one RepairMaterialInventory.
     * @example
     * // Delete one RepairMaterialInventory
     * const RepairMaterialInventory = await prisma.repairMaterialInventory.delete({
     *   where: {
     *     // ... filter to delete one RepairMaterialInventory
     *   }
     * })
     * 
    **/
    delete<T extends RepairMaterialInventoryDeleteArgs>(
      args: SelectSubset<T, RepairMaterialInventoryDeleteArgs>
    ): Prisma__RepairMaterialInventoryClient<RepairMaterialInventoryGetPayload<T>>

    /**
     * Update one RepairMaterialInventory.
     * @param {RepairMaterialInventoryUpdateArgs} args - Arguments to update one RepairMaterialInventory.
     * @example
     * // Update one RepairMaterialInventory
     * const repairMaterialInventory = await prisma.repairMaterialInventory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RepairMaterialInventoryUpdateArgs>(
      args: SelectSubset<T, RepairMaterialInventoryUpdateArgs>
    ): Prisma__RepairMaterialInventoryClient<RepairMaterialInventoryGetPayload<T>>

    /**
     * Delete zero or more RepairMaterialInventories.
     * @param {RepairMaterialInventoryDeleteManyArgs} args - Arguments to filter RepairMaterialInventories to delete.
     * @example
     * // Delete a few RepairMaterialInventories
     * const { count } = await prisma.repairMaterialInventory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RepairMaterialInventoryDeleteManyArgs>(
      args?: SelectSubset<T, RepairMaterialInventoryDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RepairMaterialInventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairMaterialInventoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RepairMaterialInventories
     * const repairMaterialInventory = await prisma.repairMaterialInventory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RepairMaterialInventoryUpdateManyArgs>(
      args: SelectSubset<T, RepairMaterialInventoryUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RepairMaterialInventory.
     * @param {RepairMaterialInventoryUpsertArgs} args - Arguments to update or create a RepairMaterialInventory.
     * @example
     * // Update or create a RepairMaterialInventory
     * const repairMaterialInventory = await prisma.repairMaterialInventory.upsert({
     *   create: {
     *     // ... data to create a RepairMaterialInventory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RepairMaterialInventory we want to update
     *   }
     * })
    **/
    upsert<T extends RepairMaterialInventoryUpsertArgs>(
      args: SelectSubset<T, RepairMaterialInventoryUpsertArgs>
    ): Prisma__RepairMaterialInventoryClient<RepairMaterialInventoryGetPayload<T>>

    /**
     * Count the number of RepairMaterialInventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairMaterialInventoryCountArgs} args - Arguments to filter RepairMaterialInventories to count.
     * @example
     * // Count the number of RepairMaterialInventories
     * const count = await prisma.repairMaterialInventory.count({
     *   where: {
     *     // ... the filter for the RepairMaterialInventories we want to count
     *   }
     * })
    **/
    count<T extends RepairMaterialInventoryCountArgs>(
      args?: Subset<T, RepairMaterialInventoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RepairMaterialInventoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RepairMaterialInventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairMaterialInventoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RepairMaterialInventoryAggregateArgs>(args: Subset<T, RepairMaterialInventoryAggregateArgs>): Prisma.PrismaPromise<GetRepairMaterialInventoryAggregateType<T>>

    /**
     * Group by RepairMaterialInventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairMaterialInventoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RepairMaterialInventoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RepairMaterialInventoryGroupByArgs['orderBy'] }
        : { orderBy?: RepairMaterialInventoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RepairMaterialInventoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRepairMaterialInventoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for RepairMaterialInventory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RepairMaterialInventoryClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    repairMaterial<T extends RepairMaterialArgs= {}>(args?: Subset<T, RepairMaterialArgs>): Prisma__RepairMaterialClient<RepairMaterialGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * RepairMaterialInventory base type for findUnique actions
   */
  export type RepairMaterialInventoryFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the RepairMaterialInventory
     */
    select?: RepairMaterialInventorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairMaterialInventoryInclude | null
    /**
     * Filter, which RepairMaterialInventory to fetch.
     */
    where: RepairMaterialInventoryWhereUniqueInput
  }

  /**
   * RepairMaterialInventory findUnique
   */
  export interface RepairMaterialInventoryFindUniqueArgs extends RepairMaterialInventoryFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RepairMaterialInventory findUniqueOrThrow
   */
  export type RepairMaterialInventoryFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the RepairMaterialInventory
     */
    select?: RepairMaterialInventorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairMaterialInventoryInclude | null
    /**
     * Filter, which RepairMaterialInventory to fetch.
     */
    where: RepairMaterialInventoryWhereUniqueInput
  }


  /**
   * RepairMaterialInventory base type for findFirst actions
   */
  export type RepairMaterialInventoryFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the RepairMaterialInventory
     */
    select?: RepairMaterialInventorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairMaterialInventoryInclude | null
    /**
     * Filter, which RepairMaterialInventory to fetch.
     */
    where?: RepairMaterialInventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RepairMaterialInventories to fetch.
     */
    orderBy?: Enumerable<RepairMaterialInventoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RepairMaterialInventories.
     */
    cursor?: RepairMaterialInventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RepairMaterialInventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RepairMaterialInventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RepairMaterialInventories.
     */
    distinct?: Enumerable<RepairMaterialInventoryScalarFieldEnum>
  }

  /**
   * RepairMaterialInventory findFirst
   */
  export interface RepairMaterialInventoryFindFirstArgs extends RepairMaterialInventoryFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RepairMaterialInventory findFirstOrThrow
   */
  export type RepairMaterialInventoryFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the RepairMaterialInventory
     */
    select?: RepairMaterialInventorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairMaterialInventoryInclude | null
    /**
     * Filter, which RepairMaterialInventory to fetch.
     */
    where?: RepairMaterialInventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RepairMaterialInventories to fetch.
     */
    orderBy?: Enumerable<RepairMaterialInventoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RepairMaterialInventories.
     */
    cursor?: RepairMaterialInventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RepairMaterialInventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RepairMaterialInventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RepairMaterialInventories.
     */
    distinct?: Enumerable<RepairMaterialInventoryScalarFieldEnum>
  }


  /**
   * RepairMaterialInventory findMany
   */
  export type RepairMaterialInventoryFindManyArgs = {
    /**
     * Select specific fields to fetch from the RepairMaterialInventory
     */
    select?: RepairMaterialInventorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairMaterialInventoryInclude | null
    /**
     * Filter, which RepairMaterialInventories to fetch.
     */
    where?: RepairMaterialInventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RepairMaterialInventories to fetch.
     */
    orderBy?: Enumerable<RepairMaterialInventoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RepairMaterialInventories.
     */
    cursor?: RepairMaterialInventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RepairMaterialInventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RepairMaterialInventories.
     */
    skip?: number
    distinct?: Enumerable<RepairMaterialInventoryScalarFieldEnum>
  }


  /**
   * RepairMaterialInventory create
   */
  export type RepairMaterialInventoryCreateArgs = {
    /**
     * Select specific fields to fetch from the RepairMaterialInventory
     */
    select?: RepairMaterialInventorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairMaterialInventoryInclude | null
    /**
     * The data needed to create a RepairMaterialInventory.
     */
    data: XOR<RepairMaterialInventoryCreateInput, RepairMaterialInventoryUncheckedCreateInput>
  }


  /**
   * RepairMaterialInventory createMany
   */
  export type RepairMaterialInventoryCreateManyArgs = {
    /**
     * The data used to create many RepairMaterialInventories.
     */
    data: Enumerable<RepairMaterialInventoryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * RepairMaterialInventory update
   */
  export type RepairMaterialInventoryUpdateArgs = {
    /**
     * Select specific fields to fetch from the RepairMaterialInventory
     */
    select?: RepairMaterialInventorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairMaterialInventoryInclude | null
    /**
     * The data needed to update a RepairMaterialInventory.
     */
    data: XOR<RepairMaterialInventoryUpdateInput, RepairMaterialInventoryUncheckedUpdateInput>
    /**
     * Choose, which RepairMaterialInventory to update.
     */
    where: RepairMaterialInventoryWhereUniqueInput
  }


  /**
   * RepairMaterialInventory updateMany
   */
  export type RepairMaterialInventoryUpdateManyArgs = {
    /**
     * The data used to update RepairMaterialInventories.
     */
    data: XOR<RepairMaterialInventoryUpdateManyMutationInput, RepairMaterialInventoryUncheckedUpdateManyInput>
    /**
     * Filter which RepairMaterialInventories to update
     */
    where?: RepairMaterialInventoryWhereInput
  }


  /**
   * RepairMaterialInventory upsert
   */
  export type RepairMaterialInventoryUpsertArgs = {
    /**
     * Select specific fields to fetch from the RepairMaterialInventory
     */
    select?: RepairMaterialInventorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairMaterialInventoryInclude | null
    /**
     * The filter to search for the RepairMaterialInventory to update in case it exists.
     */
    where: RepairMaterialInventoryWhereUniqueInput
    /**
     * In case the RepairMaterialInventory found by the `where` argument doesn't exist, create a new RepairMaterialInventory with this data.
     */
    create: XOR<RepairMaterialInventoryCreateInput, RepairMaterialInventoryUncheckedCreateInput>
    /**
     * In case the RepairMaterialInventory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RepairMaterialInventoryUpdateInput, RepairMaterialInventoryUncheckedUpdateInput>
  }


  /**
   * RepairMaterialInventory delete
   */
  export type RepairMaterialInventoryDeleteArgs = {
    /**
     * Select specific fields to fetch from the RepairMaterialInventory
     */
    select?: RepairMaterialInventorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairMaterialInventoryInclude | null
    /**
     * Filter which RepairMaterialInventory to delete.
     */
    where: RepairMaterialInventoryWhereUniqueInput
  }


  /**
   * RepairMaterialInventory deleteMany
   */
  export type RepairMaterialInventoryDeleteManyArgs = {
    /**
     * Filter which RepairMaterialInventories to delete
     */
    where?: RepairMaterialInventoryWhereInput
  }


  /**
   * RepairMaterialInventory without action
   */
  export type RepairMaterialInventoryArgs = {
    /**
     * Select specific fields to fetch from the RepairMaterialInventory
     */
    select?: RepairMaterialInventorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairMaterialInventoryInclude | null
  }



  /**
   * Model RepairRecord
   */


  export type AggregateRepairRecord = {
    _count: RepairRecordCountAggregateOutputType | null
    _avg: RepairRecordAvgAggregateOutputType | null
    _sum: RepairRecordSumAggregateOutputType | null
    _min: RepairRecordMinAggregateOutputType | null
    _max: RepairRecordMaxAggregateOutputType | null
  }

  export type RepairRecordAvgAggregateOutputType = {
    id: number | null
    equimentId: number | null
  }

  export type RepairRecordSumAggregateOutputType = {
    id: number | null
    equimentId: number | null
  }

  export type RepairRecordMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    equimentId: number | null
    description: string | null
    status: RepairRecordStatus | null
    type: RepairType | null
  }

  export type RepairRecordMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    equimentId: number | null
    description: string | null
    status: RepairRecordStatus | null
    type: RepairType | null
  }

  export type RepairRecordCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    isDeleted: number
    equimentId: number
    description: number
    status: number
    type: number
    _all: number
  }


  export type RepairRecordAvgAggregateInputType = {
    id?: true
    equimentId?: true
  }

  export type RepairRecordSumAggregateInputType = {
    id?: true
    equimentId?: true
  }

  export type RepairRecordMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    equimentId?: true
    description?: true
    status?: true
    type?: true
  }

  export type RepairRecordMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    equimentId?: true
    description?: true
    status?: true
    type?: true
  }

  export type RepairRecordCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    equimentId?: true
    description?: true
    status?: true
    type?: true
    _all?: true
  }

  export type RepairRecordAggregateArgs = {
    /**
     * Filter which RepairRecord to aggregate.
     */
    where?: RepairRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RepairRecords to fetch.
     */
    orderBy?: Enumerable<RepairRecordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RepairRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RepairRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RepairRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RepairRecords
    **/
    _count?: true | RepairRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RepairRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RepairRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RepairRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RepairRecordMaxAggregateInputType
  }

  export type GetRepairRecordAggregateType<T extends RepairRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateRepairRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRepairRecord[P]>
      : GetScalarType<T[P], AggregateRepairRecord[P]>
  }




  export type RepairRecordGroupByArgs = {
    where?: RepairRecordWhereInput
    orderBy?: Enumerable<RepairRecordOrderByWithAggregationInput>
    by: RepairRecordScalarFieldEnum[]
    having?: RepairRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RepairRecordCountAggregateInputType | true
    _avg?: RepairRecordAvgAggregateInputType
    _sum?: RepairRecordSumAggregateInputType
    _min?: RepairRecordMinAggregateInputType
    _max?: RepairRecordMaxAggregateInputType
  }


  export type RepairRecordGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    isDeleted: boolean
    equimentId: number
    description: string | null
    status: RepairRecordStatus | null
    type: RepairType
    _count: RepairRecordCountAggregateOutputType | null
    _avg: RepairRecordAvgAggregateOutputType | null
    _sum: RepairRecordSumAggregateOutputType | null
    _min: RepairRecordMinAggregateOutputType | null
    _max: RepairRecordMaxAggregateOutputType | null
  }

  type GetRepairRecordGroupByPayload<T extends RepairRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<RepairRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RepairRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RepairRecordGroupByOutputType[P]>
            : GetScalarType<T[P], RepairRecordGroupByOutputType[P]>
        }
      >
    >


  export type RepairRecordSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    equimentId?: boolean
    description?: boolean
    status?: boolean
    type?: boolean
    equipment?: boolean | EquipmentArgs
  }


  export type RepairRecordInclude = {
    equipment?: boolean | EquipmentArgs
  }

  export type RepairRecordGetPayload<S extends boolean | null | undefined | RepairRecordArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? RepairRecord :
    S extends undefined ? never :
    S extends { include: any } & (RepairRecordArgs | RepairRecordFindManyArgs)
    ? RepairRecord  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'equipment' ? EquipmentGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (RepairRecordArgs | RepairRecordFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'equipment' ? EquipmentGetPayload<S['select'][P]> :  P extends keyof RepairRecord ? RepairRecord[P] : never
  } 
      : RepairRecord


  type RepairRecordCountArgs = 
    Omit<RepairRecordFindManyArgs, 'select' | 'include'> & {
      select?: RepairRecordCountAggregateInputType | true
    }

  export interface RepairRecordDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one RepairRecord that matches the filter.
     * @param {RepairRecordFindUniqueArgs} args - Arguments to find a RepairRecord
     * @example
     * // Get one RepairRecord
     * const repairRecord = await prisma.repairRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RepairRecordFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RepairRecordFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'RepairRecord'> extends True ? Prisma__RepairRecordClient<RepairRecordGetPayload<T>> : Prisma__RepairRecordClient<RepairRecordGetPayload<T> | null, null>

    /**
     * Find one RepairRecord that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RepairRecordFindUniqueOrThrowArgs} args - Arguments to find a RepairRecord
     * @example
     * // Get one RepairRecord
     * const repairRecord = await prisma.repairRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RepairRecordFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, RepairRecordFindUniqueOrThrowArgs>
    ): Prisma__RepairRecordClient<RepairRecordGetPayload<T>>

    /**
     * Find the first RepairRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairRecordFindFirstArgs} args - Arguments to find a RepairRecord
     * @example
     * // Get one RepairRecord
     * const repairRecord = await prisma.repairRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RepairRecordFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RepairRecordFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'RepairRecord'> extends True ? Prisma__RepairRecordClient<RepairRecordGetPayload<T>> : Prisma__RepairRecordClient<RepairRecordGetPayload<T> | null, null>

    /**
     * Find the first RepairRecord that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairRecordFindFirstOrThrowArgs} args - Arguments to find a RepairRecord
     * @example
     * // Get one RepairRecord
     * const repairRecord = await prisma.repairRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RepairRecordFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RepairRecordFindFirstOrThrowArgs>
    ): Prisma__RepairRecordClient<RepairRecordGetPayload<T>>

    /**
     * Find zero or more RepairRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairRecordFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RepairRecords
     * const repairRecords = await prisma.repairRecord.findMany()
     * 
     * // Get first 10 RepairRecords
     * const repairRecords = await prisma.repairRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const repairRecordWithIdOnly = await prisma.repairRecord.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RepairRecordFindManyArgs>(
      args?: SelectSubset<T, RepairRecordFindManyArgs>
    ): Prisma.PrismaPromise<Array<RepairRecordGetPayload<T>>>

    /**
     * Create a RepairRecord.
     * @param {RepairRecordCreateArgs} args - Arguments to create a RepairRecord.
     * @example
     * // Create one RepairRecord
     * const RepairRecord = await prisma.repairRecord.create({
     *   data: {
     *     // ... data to create a RepairRecord
     *   }
     * })
     * 
    **/
    create<T extends RepairRecordCreateArgs>(
      args: SelectSubset<T, RepairRecordCreateArgs>
    ): Prisma__RepairRecordClient<RepairRecordGetPayload<T>>

    /**
     * Create many RepairRecords.
     *     @param {RepairRecordCreateManyArgs} args - Arguments to create many RepairRecords.
     *     @example
     *     // Create many RepairRecords
     *     const repairRecord = await prisma.repairRecord.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RepairRecordCreateManyArgs>(
      args?: SelectSubset<T, RepairRecordCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RepairRecord.
     * @param {RepairRecordDeleteArgs} args - Arguments to delete one RepairRecord.
     * @example
     * // Delete one RepairRecord
     * const RepairRecord = await prisma.repairRecord.delete({
     *   where: {
     *     // ... filter to delete one RepairRecord
     *   }
     * })
     * 
    **/
    delete<T extends RepairRecordDeleteArgs>(
      args: SelectSubset<T, RepairRecordDeleteArgs>
    ): Prisma__RepairRecordClient<RepairRecordGetPayload<T>>

    /**
     * Update one RepairRecord.
     * @param {RepairRecordUpdateArgs} args - Arguments to update one RepairRecord.
     * @example
     * // Update one RepairRecord
     * const repairRecord = await prisma.repairRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RepairRecordUpdateArgs>(
      args: SelectSubset<T, RepairRecordUpdateArgs>
    ): Prisma__RepairRecordClient<RepairRecordGetPayload<T>>

    /**
     * Delete zero or more RepairRecords.
     * @param {RepairRecordDeleteManyArgs} args - Arguments to filter RepairRecords to delete.
     * @example
     * // Delete a few RepairRecords
     * const { count } = await prisma.repairRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RepairRecordDeleteManyArgs>(
      args?: SelectSubset<T, RepairRecordDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RepairRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RepairRecords
     * const repairRecord = await prisma.repairRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RepairRecordUpdateManyArgs>(
      args: SelectSubset<T, RepairRecordUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RepairRecord.
     * @param {RepairRecordUpsertArgs} args - Arguments to update or create a RepairRecord.
     * @example
     * // Update or create a RepairRecord
     * const repairRecord = await prisma.repairRecord.upsert({
     *   create: {
     *     // ... data to create a RepairRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RepairRecord we want to update
     *   }
     * })
    **/
    upsert<T extends RepairRecordUpsertArgs>(
      args: SelectSubset<T, RepairRecordUpsertArgs>
    ): Prisma__RepairRecordClient<RepairRecordGetPayload<T>>

    /**
     * Count the number of RepairRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairRecordCountArgs} args - Arguments to filter RepairRecords to count.
     * @example
     * // Count the number of RepairRecords
     * const count = await prisma.repairRecord.count({
     *   where: {
     *     // ... the filter for the RepairRecords we want to count
     *   }
     * })
    **/
    count<T extends RepairRecordCountArgs>(
      args?: Subset<T, RepairRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RepairRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RepairRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RepairRecordAggregateArgs>(args: Subset<T, RepairRecordAggregateArgs>): Prisma.PrismaPromise<GetRepairRecordAggregateType<T>>

    /**
     * Group by RepairRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RepairRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RepairRecordGroupByArgs['orderBy'] }
        : { orderBy?: RepairRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RepairRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRepairRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for RepairRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RepairRecordClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    equipment<T extends EquipmentArgs= {}>(args?: Subset<T, EquipmentArgs>): Prisma__EquipmentClient<EquipmentGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * RepairRecord base type for findUnique actions
   */
  export type RepairRecordFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the RepairRecord
     */
    select?: RepairRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairRecordInclude | null
    /**
     * Filter, which RepairRecord to fetch.
     */
    where: RepairRecordWhereUniqueInput
  }

  /**
   * RepairRecord findUnique
   */
  export interface RepairRecordFindUniqueArgs extends RepairRecordFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RepairRecord findUniqueOrThrow
   */
  export type RepairRecordFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the RepairRecord
     */
    select?: RepairRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairRecordInclude | null
    /**
     * Filter, which RepairRecord to fetch.
     */
    where: RepairRecordWhereUniqueInput
  }


  /**
   * RepairRecord base type for findFirst actions
   */
  export type RepairRecordFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the RepairRecord
     */
    select?: RepairRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairRecordInclude | null
    /**
     * Filter, which RepairRecord to fetch.
     */
    where?: RepairRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RepairRecords to fetch.
     */
    orderBy?: Enumerable<RepairRecordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RepairRecords.
     */
    cursor?: RepairRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RepairRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RepairRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RepairRecords.
     */
    distinct?: Enumerable<RepairRecordScalarFieldEnum>
  }

  /**
   * RepairRecord findFirst
   */
  export interface RepairRecordFindFirstArgs extends RepairRecordFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RepairRecord findFirstOrThrow
   */
  export type RepairRecordFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the RepairRecord
     */
    select?: RepairRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairRecordInclude | null
    /**
     * Filter, which RepairRecord to fetch.
     */
    where?: RepairRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RepairRecords to fetch.
     */
    orderBy?: Enumerable<RepairRecordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RepairRecords.
     */
    cursor?: RepairRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RepairRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RepairRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RepairRecords.
     */
    distinct?: Enumerable<RepairRecordScalarFieldEnum>
  }


  /**
   * RepairRecord findMany
   */
  export type RepairRecordFindManyArgs = {
    /**
     * Select specific fields to fetch from the RepairRecord
     */
    select?: RepairRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairRecordInclude | null
    /**
     * Filter, which RepairRecords to fetch.
     */
    where?: RepairRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RepairRecords to fetch.
     */
    orderBy?: Enumerable<RepairRecordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RepairRecords.
     */
    cursor?: RepairRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RepairRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RepairRecords.
     */
    skip?: number
    distinct?: Enumerable<RepairRecordScalarFieldEnum>
  }


  /**
   * RepairRecord create
   */
  export type RepairRecordCreateArgs = {
    /**
     * Select specific fields to fetch from the RepairRecord
     */
    select?: RepairRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairRecordInclude | null
    /**
     * The data needed to create a RepairRecord.
     */
    data: XOR<RepairRecordCreateInput, RepairRecordUncheckedCreateInput>
  }


  /**
   * RepairRecord createMany
   */
  export type RepairRecordCreateManyArgs = {
    /**
     * The data used to create many RepairRecords.
     */
    data: Enumerable<RepairRecordCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * RepairRecord update
   */
  export type RepairRecordUpdateArgs = {
    /**
     * Select specific fields to fetch from the RepairRecord
     */
    select?: RepairRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairRecordInclude | null
    /**
     * The data needed to update a RepairRecord.
     */
    data: XOR<RepairRecordUpdateInput, RepairRecordUncheckedUpdateInput>
    /**
     * Choose, which RepairRecord to update.
     */
    where: RepairRecordWhereUniqueInput
  }


  /**
   * RepairRecord updateMany
   */
  export type RepairRecordUpdateManyArgs = {
    /**
     * The data used to update RepairRecords.
     */
    data: XOR<RepairRecordUpdateManyMutationInput, RepairRecordUncheckedUpdateManyInput>
    /**
     * Filter which RepairRecords to update
     */
    where?: RepairRecordWhereInput
  }


  /**
   * RepairRecord upsert
   */
  export type RepairRecordUpsertArgs = {
    /**
     * Select specific fields to fetch from the RepairRecord
     */
    select?: RepairRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairRecordInclude | null
    /**
     * The filter to search for the RepairRecord to update in case it exists.
     */
    where: RepairRecordWhereUniqueInput
    /**
     * In case the RepairRecord found by the `where` argument doesn't exist, create a new RepairRecord with this data.
     */
    create: XOR<RepairRecordCreateInput, RepairRecordUncheckedCreateInput>
    /**
     * In case the RepairRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RepairRecordUpdateInput, RepairRecordUncheckedUpdateInput>
  }


  /**
   * RepairRecord delete
   */
  export type RepairRecordDeleteArgs = {
    /**
     * Select specific fields to fetch from the RepairRecord
     */
    select?: RepairRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairRecordInclude | null
    /**
     * Filter which RepairRecord to delete.
     */
    where: RepairRecordWhereUniqueInput
  }


  /**
   * RepairRecord deleteMany
   */
  export type RepairRecordDeleteManyArgs = {
    /**
     * Filter which RepairRecords to delete
     */
    where?: RepairRecordWhereInput
  }


  /**
   * RepairRecord without action
   */
  export type RepairRecordArgs = {
    /**
     * Select specific fields to fetch from the RepairRecord
     */
    select?: RepairRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairRecordInclude | null
  }



  /**
   * Model Material
   */


  export type AggregateMaterial = {
    _count: MaterialCountAggregateOutputType | null
    _avg: MaterialAvgAggregateOutputType | null
    _sum: MaterialSumAggregateOutputType | null
    _min: MaterialMinAggregateOutputType | null
    _max: MaterialMaxAggregateOutputType | null
  }

  export type MaterialAvgAggregateOutputType = {
    id: number | null
  }

  export type MaterialSumAggregateOutputType = {
    id: number | null
  }

  export type MaterialMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    name: string | null
    description: string | null
  }

  export type MaterialMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    name: string | null
    description: string | null
  }

  export type MaterialCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    isDeleted: number
    name: number
    description: number
    _all: number
  }


  export type MaterialAvgAggregateInputType = {
    id?: true
  }

  export type MaterialSumAggregateInputType = {
    id?: true
  }

  export type MaterialMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    name?: true
    description?: true
  }

  export type MaterialMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    name?: true
    description?: true
  }

  export type MaterialCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    name?: true
    description?: true
    _all?: true
  }

  export type MaterialAggregateArgs = {
    /**
     * Filter which Material to aggregate.
     */
    where?: MaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: Enumerable<MaterialOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Materials
    **/
    _count?: true | MaterialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MaterialAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MaterialSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaterialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaterialMaxAggregateInputType
  }

  export type GetMaterialAggregateType<T extends MaterialAggregateArgs> = {
        [P in keyof T & keyof AggregateMaterial]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaterial[P]>
      : GetScalarType<T[P], AggregateMaterial[P]>
  }




  export type MaterialGroupByArgs = {
    where?: MaterialWhereInput
    orderBy?: Enumerable<MaterialOrderByWithAggregationInput>
    by: MaterialScalarFieldEnum[]
    having?: MaterialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaterialCountAggregateInputType | true
    _avg?: MaterialAvgAggregateInputType
    _sum?: MaterialSumAggregateInputType
    _min?: MaterialMinAggregateInputType
    _max?: MaterialMaxAggregateInputType
  }


  export type MaterialGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    isDeleted: boolean
    name: string
    description: string | null
    _count: MaterialCountAggregateOutputType | null
    _avg: MaterialAvgAggregateOutputType | null
    _sum: MaterialSumAggregateOutputType | null
    _min: MaterialMinAggregateOutputType | null
    _max: MaterialMaxAggregateOutputType | null
  }

  type GetMaterialGroupByPayload<T extends MaterialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<MaterialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaterialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaterialGroupByOutputType[P]>
            : GetScalarType<T[P], MaterialGroupByOutputType[P]>
        }
      >
    >


  export type MaterialSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    name?: boolean
    description?: boolean
    specs?: boolean | Material$specsArgs
    operations?: boolean | Material$operationsArgs
    incomingInspectRecord?: boolean | Material$incomingInspectRecordArgs
    inProcessInspectRecord?: boolean | Material$inProcessInspectRecordArgs
    _count?: boolean | MaterialCountOutputTypeArgs
  }


  export type MaterialInclude = {
    specs?: boolean | Material$specsArgs
    operations?: boolean | Material$operationsArgs
    incomingInspectRecord?: boolean | Material$incomingInspectRecordArgs
    inProcessInspectRecord?: boolean | Material$inProcessInspectRecordArgs
    _count?: boolean | MaterialCountOutputTypeArgs
  }

  export type MaterialGetPayload<S extends boolean | null | undefined | MaterialArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Material :
    S extends undefined ? never :
    S extends { include: any } & (MaterialArgs | MaterialFindManyArgs)
    ? Material  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'specs' ? Array < MaterialSpecGetPayload<S['include'][P]>>  :
        P extends 'operations' ? Array < OperationGetPayload<S['include'][P]>>  :
        P extends 'incomingInspectRecord' ? Array < IncomingInspectRecordGetPayload<S['include'][P]>>  :
        P extends 'inProcessInspectRecord' ? Array < InProcessInspectRecordGetPayload<S['include'][P]>>  :
        P extends '_count' ? MaterialCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (MaterialArgs | MaterialFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'specs' ? Array < MaterialSpecGetPayload<S['select'][P]>>  :
        P extends 'operations' ? Array < OperationGetPayload<S['select'][P]>>  :
        P extends 'incomingInspectRecord' ? Array < IncomingInspectRecordGetPayload<S['select'][P]>>  :
        P extends 'inProcessInspectRecord' ? Array < InProcessInspectRecordGetPayload<S['select'][P]>>  :
        P extends '_count' ? MaterialCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Material ? Material[P] : never
  } 
      : Material


  type MaterialCountArgs = 
    Omit<MaterialFindManyArgs, 'select' | 'include'> & {
      select?: MaterialCountAggregateInputType | true
    }

  export interface MaterialDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Material that matches the filter.
     * @param {MaterialFindUniqueArgs} args - Arguments to find a Material
     * @example
     * // Get one Material
     * const material = await prisma.material.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MaterialFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MaterialFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Material'> extends True ? Prisma__MaterialClient<MaterialGetPayload<T>> : Prisma__MaterialClient<MaterialGetPayload<T> | null, null>

    /**
     * Find one Material that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MaterialFindUniqueOrThrowArgs} args - Arguments to find a Material
     * @example
     * // Get one Material
     * const material = await prisma.material.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MaterialFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, MaterialFindUniqueOrThrowArgs>
    ): Prisma__MaterialClient<MaterialGetPayload<T>>

    /**
     * Find the first Material that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialFindFirstArgs} args - Arguments to find a Material
     * @example
     * // Get one Material
     * const material = await prisma.material.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MaterialFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MaterialFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Material'> extends True ? Prisma__MaterialClient<MaterialGetPayload<T>> : Prisma__MaterialClient<MaterialGetPayload<T> | null, null>

    /**
     * Find the first Material that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialFindFirstOrThrowArgs} args - Arguments to find a Material
     * @example
     * // Get one Material
     * const material = await prisma.material.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MaterialFindFirstOrThrowArgs>(
      args?: SelectSubset<T, MaterialFindFirstOrThrowArgs>
    ): Prisma__MaterialClient<MaterialGetPayload<T>>

    /**
     * Find zero or more Materials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Materials
     * const materials = await prisma.material.findMany()
     * 
     * // Get first 10 Materials
     * const materials = await prisma.material.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const materialWithIdOnly = await prisma.material.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MaterialFindManyArgs>(
      args?: SelectSubset<T, MaterialFindManyArgs>
    ): Prisma.PrismaPromise<Array<MaterialGetPayload<T>>>

    /**
     * Create a Material.
     * @param {MaterialCreateArgs} args - Arguments to create a Material.
     * @example
     * // Create one Material
     * const Material = await prisma.material.create({
     *   data: {
     *     // ... data to create a Material
     *   }
     * })
     * 
    **/
    create<T extends MaterialCreateArgs>(
      args: SelectSubset<T, MaterialCreateArgs>
    ): Prisma__MaterialClient<MaterialGetPayload<T>>

    /**
     * Create many Materials.
     *     @param {MaterialCreateManyArgs} args - Arguments to create many Materials.
     *     @example
     *     // Create many Materials
     *     const material = await prisma.material.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MaterialCreateManyArgs>(
      args?: SelectSubset<T, MaterialCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Material.
     * @param {MaterialDeleteArgs} args - Arguments to delete one Material.
     * @example
     * // Delete one Material
     * const Material = await prisma.material.delete({
     *   where: {
     *     // ... filter to delete one Material
     *   }
     * })
     * 
    **/
    delete<T extends MaterialDeleteArgs>(
      args: SelectSubset<T, MaterialDeleteArgs>
    ): Prisma__MaterialClient<MaterialGetPayload<T>>

    /**
     * Update one Material.
     * @param {MaterialUpdateArgs} args - Arguments to update one Material.
     * @example
     * // Update one Material
     * const material = await prisma.material.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MaterialUpdateArgs>(
      args: SelectSubset<T, MaterialUpdateArgs>
    ): Prisma__MaterialClient<MaterialGetPayload<T>>

    /**
     * Delete zero or more Materials.
     * @param {MaterialDeleteManyArgs} args - Arguments to filter Materials to delete.
     * @example
     * // Delete a few Materials
     * const { count } = await prisma.material.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MaterialDeleteManyArgs>(
      args?: SelectSubset<T, MaterialDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Materials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Materials
     * const material = await prisma.material.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MaterialUpdateManyArgs>(
      args: SelectSubset<T, MaterialUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Material.
     * @param {MaterialUpsertArgs} args - Arguments to update or create a Material.
     * @example
     * // Update or create a Material
     * const material = await prisma.material.upsert({
     *   create: {
     *     // ... data to create a Material
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Material we want to update
     *   }
     * })
    **/
    upsert<T extends MaterialUpsertArgs>(
      args: SelectSubset<T, MaterialUpsertArgs>
    ): Prisma__MaterialClient<MaterialGetPayload<T>>

    /**
     * Count the number of Materials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialCountArgs} args - Arguments to filter Materials to count.
     * @example
     * // Count the number of Materials
     * const count = await prisma.material.count({
     *   where: {
     *     // ... the filter for the Materials we want to count
     *   }
     * })
    **/
    count<T extends MaterialCountArgs>(
      args?: Subset<T, MaterialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaterialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Material.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaterialAggregateArgs>(args: Subset<T, MaterialAggregateArgs>): Prisma.PrismaPromise<GetMaterialAggregateType<T>>

    /**
     * Group by Material.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaterialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaterialGroupByArgs['orderBy'] }
        : { orderBy?: MaterialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaterialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaterialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Material.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MaterialClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    specs<T extends Material$specsArgs= {}>(args?: Subset<T, Material$specsArgs>): Prisma.PrismaPromise<Array<MaterialSpecGetPayload<T>>| Null>;

    operations<T extends Material$operationsArgs= {}>(args?: Subset<T, Material$operationsArgs>): Prisma.PrismaPromise<Array<OperationGetPayload<T>>| Null>;

    incomingInspectRecord<T extends Material$incomingInspectRecordArgs= {}>(args?: Subset<T, Material$incomingInspectRecordArgs>): Prisma.PrismaPromise<Array<IncomingInspectRecordGetPayload<T>>| Null>;

    inProcessInspectRecord<T extends Material$inProcessInspectRecordArgs= {}>(args?: Subset<T, Material$inProcessInspectRecordArgs>): Prisma.PrismaPromise<Array<InProcessInspectRecordGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Material base type for findUnique actions
   */
  export type MaterialFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MaterialInclude | null
    /**
     * Filter, which Material to fetch.
     */
    where: MaterialWhereUniqueInput
  }

  /**
   * Material findUnique
   */
  export interface MaterialFindUniqueArgs extends MaterialFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Material findUniqueOrThrow
   */
  export type MaterialFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MaterialInclude | null
    /**
     * Filter, which Material to fetch.
     */
    where: MaterialWhereUniqueInput
  }


  /**
   * Material base type for findFirst actions
   */
  export type MaterialFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MaterialInclude | null
    /**
     * Filter, which Material to fetch.
     */
    where?: MaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: Enumerable<MaterialOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Materials.
     */
    cursor?: MaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Materials.
     */
    distinct?: Enumerable<MaterialScalarFieldEnum>
  }

  /**
   * Material findFirst
   */
  export interface MaterialFindFirstArgs extends MaterialFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Material findFirstOrThrow
   */
  export type MaterialFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MaterialInclude | null
    /**
     * Filter, which Material to fetch.
     */
    where?: MaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: Enumerable<MaterialOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Materials.
     */
    cursor?: MaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Materials.
     */
    distinct?: Enumerable<MaterialScalarFieldEnum>
  }


  /**
   * Material findMany
   */
  export type MaterialFindManyArgs = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MaterialInclude | null
    /**
     * Filter, which Materials to fetch.
     */
    where?: MaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: Enumerable<MaterialOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Materials.
     */
    cursor?: MaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    distinct?: Enumerable<MaterialScalarFieldEnum>
  }


  /**
   * Material create
   */
  export type MaterialCreateArgs = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MaterialInclude | null
    /**
     * The data needed to create a Material.
     */
    data: XOR<MaterialCreateInput, MaterialUncheckedCreateInput>
  }


  /**
   * Material createMany
   */
  export type MaterialCreateManyArgs = {
    /**
     * The data used to create many Materials.
     */
    data: Enumerable<MaterialCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Material update
   */
  export type MaterialUpdateArgs = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MaterialInclude | null
    /**
     * The data needed to update a Material.
     */
    data: XOR<MaterialUpdateInput, MaterialUncheckedUpdateInput>
    /**
     * Choose, which Material to update.
     */
    where: MaterialWhereUniqueInput
  }


  /**
   * Material updateMany
   */
  export type MaterialUpdateManyArgs = {
    /**
     * The data used to update Materials.
     */
    data: XOR<MaterialUpdateManyMutationInput, MaterialUncheckedUpdateManyInput>
    /**
     * Filter which Materials to update
     */
    where?: MaterialWhereInput
  }


  /**
   * Material upsert
   */
  export type MaterialUpsertArgs = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MaterialInclude | null
    /**
     * The filter to search for the Material to update in case it exists.
     */
    where: MaterialWhereUniqueInput
    /**
     * In case the Material found by the `where` argument doesn't exist, create a new Material with this data.
     */
    create: XOR<MaterialCreateInput, MaterialUncheckedCreateInput>
    /**
     * In case the Material was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MaterialUpdateInput, MaterialUncheckedUpdateInput>
  }


  /**
   * Material delete
   */
  export type MaterialDeleteArgs = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MaterialInclude | null
    /**
     * Filter which Material to delete.
     */
    where: MaterialWhereUniqueInput
  }


  /**
   * Material deleteMany
   */
  export type MaterialDeleteManyArgs = {
    /**
     * Filter which Materials to delete
     */
    where?: MaterialWhereInput
  }


  /**
   * Material.specs
   */
  export type Material$specsArgs = {
    /**
     * Select specific fields to fetch from the MaterialSpec
     */
    select?: MaterialSpecSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MaterialSpecInclude | null
    where?: MaterialSpecWhereInput
    orderBy?: Enumerable<MaterialSpecOrderByWithRelationInput>
    cursor?: MaterialSpecWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<MaterialSpecScalarFieldEnum>
  }


  /**
   * Material.operations
   */
  export type Material$operationsArgs = {
    /**
     * Select specific fields to fetch from the Operation
     */
    select?: OperationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OperationInclude | null
    where?: OperationWhereInput
    orderBy?: Enumerable<OperationOrderByWithRelationInput>
    cursor?: OperationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<OperationScalarFieldEnum>
  }


  /**
   * Material.incomingInspectRecord
   */
  export type Material$incomingInspectRecordArgs = {
    /**
     * Select specific fields to fetch from the IncomingInspectRecord
     */
    select?: IncomingInspectRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IncomingInspectRecordInclude | null
    where?: IncomingInspectRecordWhereInput
    orderBy?: Enumerable<IncomingInspectRecordOrderByWithRelationInput>
    cursor?: IncomingInspectRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<IncomingInspectRecordScalarFieldEnum>
  }


  /**
   * Material.inProcessInspectRecord
   */
  export type Material$inProcessInspectRecordArgs = {
    /**
     * Select specific fields to fetch from the InProcessInspectRecord
     */
    select?: InProcessInspectRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InProcessInspectRecordInclude | null
    where?: InProcessInspectRecordWhereInput
    orderBy?: Enumerable<InProcessInspectRecordOrderByWithRelationInput>
    cursor?: InProcessInspectRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<InProcessInspectRecordScalarFieldEnum>
  }


  /**
   * Material without action
   */
  export type MaterialArgs = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MaterialInclude | null
  }



  /**
   * Model MaterialSpec
   */


  export type AggregateMaterialSpec = {
    _count: MaterialSpecCountAggregateOutputType | null
    _avg: MaterialSpecAvgAggregateOutputType | null
    _sum: MaterialSpecSumAggregateOutputType | null
    _min: MaterialSpecMinAggregateOutputType | null
    _max: MaterialSpecMaxAggregateOutputType | null
  }

  export type MaterialSpecAvgAggregateOutputType = {
    id: number | null
    materialId: number | null
  }

  export type MaterialSpecSumAggregateOutputType = {
    id: number | null
    materialId: number | null
  }

  export type MaterialSpecMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    name: string | null
    description: string | null
    materialId: number | null
  }

  export type MaterialSpecMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    name: string | null
    description: string | null
    materialId: number | null
  }

  export type MaterialSpecCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    isDeleted: number
    name: number
    description: number
    materialId: number
    _all: number
  }


  export type MaterialSpecAvgAggregateInputType = {
    id?: true
    materialId?: true
  }

  export type MaterialSpecSumAggregateInputType = {
    id?: true
    materialId?: true
  }

  export type MaterialSpecMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    name?: true
    description?: true
    materialId?: true
  }

  export type MaterialSpecMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    name?: true
    description?: true
    materialId?: true
  }

  export type MaterialSpecCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    name?: true
    description?: true
    materialId?: true
    _all?: true
  }

  export type MaterialSpecAggregateArgs = {
    /**
     * Filter which MaterialSpec to aggregate.
     */
    where?: MaterialSpecWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaterialSpecs to fetch.
     */
    orderBy?: Enumerable<MaterialSpecOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MaterialSpecWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaterialSpecs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaterialSpecs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MaterialSpecs
    **/
    _count?: true | MaterialSpecCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MaterialSpecAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MaterialSpecSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaterialSpecMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaterialSpecMaxAggregateInputType
  }

  export type GetMaterialSpecAggregateType<T extends MaterialSpecAggregateArgs> = {
        [P in keyof T & keyof AggregateMaterialSpec]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaterialSpec[P]>
      : GetScalarType<T[P], AggregateMaterialSpec[P]>
  }




  export type MaterialSpecGroupByArgs = {
    where?: MaterialSpecWhereInput
    orderBy?: Enumerable<MaterialSpecOrderByWithAggregationInput>
    by: MaterialSpecScalarFieldEnum[]
    having?: MaterialSpecScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaterialSpecCountAggregateInputType | true
    _avg?: MaterialSpecAvgAggregateInputType
    _sum?: MaterialSpecSumAggregateInputType
    _min?: MaterialSpecMinAggregateInputType
    _max?: MaterialSpecMaxAggregateInputType
  }


  export type MaterialSpecGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    isDeleted: boolean
    name: string
    description: string | null
    materialId: number
    _count: MaterialSpecCountAggregateOutputType | null
    _avg: MaterialSpecAvgAggregateOutputType | null
    _sum: MaterialSpecSumAggregateOutputType | null
    _min: MaterialSpecMinAggregateOutputType | null
    _max: MaterialSpecMaxAggregateOutputType | null
  }

  type GetMaterialSpecGroupByPayload<T extends MaterialSpecGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<MaterialSpecGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaterialSpecGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaterialSpecGroupByOutputType[P]>
            : GetScalarType<T[P], MaterialSpecGroupByOutputType[P]>
        }
      >
    >


  export type MaterialSpecSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    name?: boolean
    description?: boolean
    materialId?: boolean
    material?: boolean | MaterialArgs
    inspects?: boolean | MaterialSpec$inspectsArgs
    _count?: boolean | MaterialSpecCountOutputTypeArgs
  }


  export type MaterialSpecInclude = {
    material?: boolean | MaterialArgs
    inspects?: boolean | MaterialSpec$inspectsArgs
    _count?: boolean | MaterialSpecCountOutputTypeArgs
  }

  export type MaterialSpecGetPayload<S extends boolean | null | undefined | MaterialSpecArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? MaterialSpec :
    S extends undefined ? never :
    S extends { include: any } & (MaterialSpecArgs | MaterialSpecFindManyArgs)
    ? MaterialSpec  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'material' ? MaterialGetPayload<S['include'][P]> :
        P extends 'inspects' ? Array < MaterialSpecInspectGetPayload<S['include'][P]>>  :
        P extends '_count' ? MaterialSpecCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (MaterialSpecArgs | MaterialSpecFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'material' ? MaterialGetPayload<S['select'][P]> :
        P extends 'inspects' ? Array < MaterialSpecInspectGetPayload<S['select'][P]>>  :
        P extends '_count' ? MaterialSpecCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof MaterialSpec ? MaterialSpec[P] : never
  } 
      : MaterialSpec


  type MaterialSpecCountArgs = 
    Omit<MaterialSpecFindManyArgs, 'select' | 'include'> & {
      select?: MaterialSpecCountAggregateInputType | true
    }

  export interface MaterialSpecDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one MaterialSpec that matches the filter.
     * @param {MaterialSpecFindUniqueArgs} args - Arguments to find a MaterialSpec
     * @example
     * // Get one MaterialSpec
     * const materialSpec = await prisma.materialSpec.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MaterialSpecFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MaterialSpecFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'MaterialSpec'> extends True ? Prisma__MaterialSpecClient<MaterialSpecGetPayload<T>> : Prisma__MaterialSpecClient<MaterialSpecGetPayload<T> | null, null>

    /**
     * Find one MaterialSpec that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MaterialSpecFindUniqueOrThrowArgs} args - Arguments to find a MaterialSpec
     * @example
     * // Get one MaterialSpec
     * const materialSpec = await prisma.materialSpec.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MaterialSpecFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, MaterialSpecFindUniqueOrThrowArgs>
    ): Prisma__MaterialSpecClient<MaterialSpecGetPayload<T>>

    /**
     * Find the first MaterialSpec that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialSpecFindFirstArgs} args - Arguments to find a MaterialSpec
     * @example
     * // Get one MaterialSpec
     * const materialSpec = await prisma.materialSpec.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MaterialSpecFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MaterialSpecFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'MaterialSpec'> extends True ? Prisma__MaterialSpecClient<MaterialSpecGetPayload<T>> : Prisma__MaterialSpecClient<MaterialSpecGetPayload<T> | null, null>

    /**
     * Find the first MaterialSpec that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialSpecFindFirstOrThrowArgs} args - Arguments to find a MaterialSpec
     * @example
     * // Get one MaterialSpec
     * const materialSpec = await prisma.materialSpec.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MaterialSpecFindFirstOrThrowArgs>(
      args?: SelectSubset<T, MaterialSpecFindFirstOrThrowArgs>
    ): Prisma__MaterialSpecClient<MaterialSpecGetPayload<T>>

    /**
     * Find zero or more MaterialSpecs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialSpecFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MaterialSpecs
     * const materialSpecs = await prisma.materialSpec.findMany()
     * 
     * // Get first 10 MaterialSpecs
     * const materialSpecs = await prisma.materialSpec.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const materialSpecWithIdOnly = await prisma.materialSpec.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MaterialSpecFindManyArgs>(
      args?: SelectSubset<T, MaterialSpecFindManyArgs>
    ): Prisma.PrismaPromise<Array<MaterialSpecGetPayload<T>>>

    /**
     * Create a MaterialSpec.
     * @param {MaterialSpecCreateArgs} args - Arguments to create a MaterialSpec.
     * @example
     * // Create one MaterialSpec
     * const MaterialSpec = await prisma.materialSpec.create({
     *   data: {
     *     // ... data to create a MaterialSpec
     *   }
     * })
     * 
    **/
    create<T extends MaterialSpecCreateArgs>(
      args: SelectSubset<T, MaterialSpecCreateArgs>
    ): Prisma__MaterialSpecClient<MaterialSpecGetPayload<T>>

    /**
     * Create many MaterialSpecs.
     *     @param {MaterialSpecCreateManyArgs} args - Arguments to create many MaterialSpecs.
     *     @example
     *     // Create many MaterialSpecs
     *     const materialSpec = await prisma.materialSpec.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MaterialSpecCreateManyArgs>(
      args?: SelectSubset<T, MaterialSpecCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MaterialSpec.
     * @param {MaterialSpecDeleteArgs} args - Arguments to delete one MaterialSpec.
     * @example
     * // Delete one MaterialSpec
     * const MaterialSpec = await prisma.materialSpec.delete({
     *   where: {
     *     // ... filter to delete one MaterialSpec
     *   }
     * })
     * 
    **/
    delete<T extends MaterialSpecDeleteArgs>(
      args: SelectSubset<T, MaterialSpecDeleteArgs>
    ): Prisma__MaterialSpecClient<MaterialSpecGetPayload<T>>

    /**
     * Update one MaterialSpec.
     * @param {MaterialSpecUpdateArgs} args - Arguments to update one MaterialSpec.
     * @example
     * // Update one MaterialSpec
     * const materialSpec = await prisma.materialSpec.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MaterialSpecUpdateArgs>(
      args: SelectSubset<T, MaterialSpecUpdateArgs>
    ): Prisma__MaterialSpecClient<MaterialSpecGetPayload<T>>

    /**
     * Delete zero or more MaterialSpecs.
     * @param {MaterialSpecDeleteManyArgs} args - Arguments to filter MaterialSpecs to delete.
     * @example
     * // Delete a few MaterialSpecs
     * const { count } = await prisma.materialSpec.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MaterialSpecDeleteManyArgs>(
      args?: SelectSubset<T, MaterialSpecDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MaterialSpecs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialSpecUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MaterialSpecs
     * const materialSpec = await prisma.materialSpec.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MaterialSpecUpdateManyArgs>(
      args: SelectSubset<T, MaterialSpecUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MaterialSpec.
     * @param {MaterialSpecUpsertArgs} args - Arguments to update or create a MaterialSpec.
     * @example
     * // Update or create a MaterialSpec
     * const materialSpec = await prisma.materialSpec.upsert({
     *   create: {
     *     // ... data to create a MaterialSpec
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MaterialSpec we want to update
     *   }
     * })
    **/
    upsert<T extends MaterialSpecUpsertArgs>(
      args: SelectSubset<T, MaterialSpecUpsertArgs>
    ): Prisma__MaterialSpecClient<MaterialSpecGetPayload<T>>

    /**
     * Count the number of MaterialSpecs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialSpecCountArgs} args - Arguments to filter MaterialSpecs to count.
     * @example
     * // Count the number of MaterialSpecs
     * const count = await prisma.materialSpec.count({
     *   where: {
     *     // ... the filter for the MaterialSpecs we want to count
     *   }
     * })
    **/
    count<T extends MaterialSpecCountArgs>(
      args?: Subset<T, MaterialSpecCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaterialSpecCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MaterialSpec.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialSpecAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaterialSpecAggregateArgs>(args: Subset<T, MaterialSpecAggregateArgs>): Prisma.PrismaPromise<GetMaterialSpecAggregateType<T>>

    /**
     * Group by MaterialSpec.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialSpecGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaterialSpecGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaterialSpecGroupByArgs['orderBy'] }
        : { orderBy?: MaterialSpecGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaterialSpecGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaterialSpecGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for MaterialSpec.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MaterialSpecClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    material<T extends MaterialArgs= {}>(args?: Subset<T, MaterialArgs>): Prisma__MaterialClient<MaterialGetPayload<T> | Null>;

    inspects<T extends MaterialSpec$inspectsArgs= {}>(args?: Subset<T, MaterialSpec$inspectsArgs>): Prisma.PrismaPromise<Array<MaterialSpecInspectGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * MaterialSpec base type for findUnique actions
   */
  export type MaterialSpecFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the MaterialSpec
     */
    select?: MaterialSpecSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MaterialSpecInclude | null
    /**
     * Filter, which MaterialSpec to fetch.
     */
    where: MaterialSpecWhereUniqueInput
  }

  /**
   * MaterialSpec findUnique
   */
  export interface MaterialSpecFindUniqueArgs extends MaterialSpecFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MaterialSpec findUniqueOrThrow
   */
  export type MaterialSpecFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the MaterialSpec
     */
    select?: MaterialSpecSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MaterialSpecInclude | null
    /**
     * Filter, which MaterialSpec to fetch.
     */
    where: MaterialSpecWhereUniqueInput
  }


  /**
   * MaterialSpec base type for findFirst actions
   */
  export type MaterialSpecFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the MaterialSpec
     */
    select?: MaterialSpecSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MaterialSpecInclude | null
    /**
     * Filter, which MaterialSpec to fetch.
     */
    where?: MaterialSpecWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaterialSpecs to fetch.
     */
    orderBy?: Enumerable<MaterialSpecOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaterialSpecs.
     */
    cursor?: MaterialSpecWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaterialSpecs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaterialSpecs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaterialSpecs.
     */
    distinct?: Enumerable<MaterialSpecScalarFieldEnum>
  }

  /**
   * MaterialSpec findFirst
   */
  export interface MaterialSpecFindFirstArgs extends MaterialSpecFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MaterialSpec findFirstOrThrow
   */
  export type MaterialSpecFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the MaterialSpec
     */
    select?: MaterialSpecSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MaterialSpecInclude | null
    /**
     * Filter, which MaterialSpec to fetch.
     */
    where?: MaterialSpecWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaterialSpecs to fetch.
     */
    orderBy?: Enumerable<MaterialSpecOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaterialSpecs.
     */
    cursor?: MaterialSpecWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaterialSpecs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaterialSpecs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaterialSpecs.
     */
    distinct?: Enumerable<MaterialSpecScalarFieldEnum>
  }


  /**
   * MaterialSpec findMany
   */
  export type MaterialSpecFindManyArgs = {
    /**
     * Select specific fields to fetch from the MaterialSpec
     */
    select?: MaterialSpecSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MaterialSpecInclude | null
    /**
     * Filter, which MaterialSpecs to fetch.
     */
    where?: MaterialSpecWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaterialSpecs to fetch.
     */
    orderBy?: Enumerable<MaterialSpecOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MaterialSpecs.
     */
    cursor?: MaterialSpecWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaterialSpecs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaterialSpecs.
     */
    skip?: number
    distinct?: Enumerable<MaterialSpecScalarFieldEnum>
  }


  /**
   * MaterialSpec create
   */
  export type MaterialSpecCreateArgs = {
    /**
     * Select specific fields to fetch from the MaterialSpec
     */
    select?: MaterialSpecSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MaterialSpecInclude | null
    /**
     * The data needed to create a MaterialSpec.
     */
    data: XOR<MaterialSpecCreateInput, MaterialSpecUncheckedCreateInput>
  }


  /**
   * MaterialSpec createMany
   */
  export type MaterialSpecCreateManyArgs = {
    /**
     * The data used to create many MaterialSpecs.
     */
    data: Enumerable<MaterialSpecCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * MaterialSpec update
   */
  export type MaterialSpecUpdateArgs = {
    /**
     * Select specific fields to fetch from the MaterialSpec
     */
    select?: MaterialSpecSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MaterialSpecInclude | null
    /**
     * The data needed to update a MaterialSpec.
     */
    data: XOR<MaterialSpecUpdateInput, MaterialSpecUncheckedUpdateInput>
    /**
     * Choose, which MaterialSpec to update.
     */
    where: MaterialSpecWhereUniqueInput
  }


  /**
   * MaterialSpec updateMany
   */
  export type MaterialSpecUpdateManyArgs = {
    /**
     * The data used to update MaterialSpecs.
     */
    data: XOR<MaterialSpecUpdateManyMutationInput, MaterialSpecUncheckedUpdateManyInput>
    /**
     * Filter which MaterialSpecs to update
     */
    where?: MaterialSpecWhereInput
  }


  /**
   * MaterialSpec upsert
   */
  export type MaterialSpecUpsertArgs = {
    /**
     * Select specific fields to fetch from the MaterialSpec
     */
    select?: MaterialSpecSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MaterialSpecInclude | null
    /**
     * The filter to search for the MaterialSpec to update in case it exists.
     */
    where: MaterialSpecWhereUniqueInput
    /**
     * In case the MaterialSpec found by the `where` argument doesn't exist, create a new MaterialSpec with this data.
     */
    create: XOR<MaterialSpecCreateInput, MaterialSpecUncheckedCreateInput>
    /**
     * In case the MaterialSpec was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MaterialSpecUpdateInput, MaterialSpecUncheckedUpdateInput>
  }


  /**
   * MaterialSpec delete
   */
  export type MaterialSpecDeleteArgs = {
    /**
     * Select specific fields to fetch from the MaterialSpec
     */
    select?: MaterialSpecSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MaterialSpecInclude | null
    /**
     * Filter which MaterialSpec to delete.
     */
    where: MaterialSpecWhereUniqueInput
  }


  /**
   * MaterialSpec deleteMany
   */
  export type MaterialSpecDeleteManyArgs = {
    /**
     * Filter which MaterialSpecs to delete
     */
    where?: MaterialSpecWhereInput
  }


  /**
   * MaterialSpec.inspects
   */
  export type MaterialSpec$inspectsArgs = {
    /**
     * Select specific fields to fetch from the MaterialSpecInspect
     */
    select?: MaterialSpecInspectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MaterialSpecInspectInclude | null
    where?: MaterialSpecInspectWhereInput
    orderBy?: Enumerable<MaterialSpecInspectOrderByWithRelationInput>
    cursor?: MaterialSpecInspectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<MaterialSpecInspectScalarFieldEnum>
  }


  /**
   * MaterialSpec without action
   */
  export type MaterialSpecArgs = {
    /**
     * Select specific fields to fetch from the MaterialSpec
     */
    select?: MaterialSpecSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MaterialSpecInclude | null
  }



  /**
   * Model Operation
   */


  export type AggregateOperation = {
    _count: OperationCountAggregateOutputType | null
    _avg: OperationAvgAggregateOutputType | null
    _sum: OperationSumAggregateOutputType | null
    _min: OperationMinAggregateOutputType | null
    _max: OperationMaxAggregateOutputType | null
  }

  export type OperationAvgAggregateOutputType = {
    id: number | null
    materialId: number | null
  }

  export type OperationSumAggregateOutputType = {
    id: number | null
    materialId: number | null
  }

  export type OperationMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    name: string | null
    description: string | null
    materialId: number | null
  }

  export type OperationMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    name: string | null
    description: string | null
    materialId: number | null
  }

  export type OperationCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    isDeleted: number
    name: number
    description: number
    materialId: number
    _all: number
  }


  export type OperationAvgAggregateInputType = {
    id?: true
    materialId?: true
  }

  export type OperationSumAggregateInputType = {
    id?: true
    materialId?: true
  }

  export type OperationMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    name?: true
    description?: true
    materialId?: true
  }

  export type OperationMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    name?: true
    description?: true
    materialId?: true
  }

  export type OperationCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    name?: true
    description?: true
    materialId?: true
    _all?: true
  }

  export type OperationAggregateArgs = {
    /**
     * Filter which Operation to aggregate.
     */
    where?: OperationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Operations to fetch.
     */
    orderBy?: Enumerable<OperationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OperationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Operations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Operations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Operations
    **/
    _count?: true | OperationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OperationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OperationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OperationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OperationMaxAggregateInputType
  }

  export type GetOperationAggregateType<T extends OperationAggregateArgs> = {
        [P in keyof T & keyof AggregateOperation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOperation[P]>
      : GetScalarType<T[P], AggregateOperation[P]>
  }




  export type OperationGroupByArgs = {
    where?: OperationWhereInput
    orderBy?: Enumerable<OperationOrderByWithAggregationInput>
    by: OperationScalarFieldEnum[]
    having?: OperationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OperationCountAggregateInputType | true
    _avg?: OperationAvgAggregateInputType
    _sum?: OperationSumAggregateInputType
    _min?: OperationMinAggregateInputType
    _max?: OperationMaxAggregateInputType
  }


  export type OperationGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    isDeleted: boolean
    name: string
    description: string | null
    materialId: number
    _count: OperationCountAggregateOutputType | null
    _avg: OperationAvgAggregateOutputType | null
    _sum: OperationSumAggregateOutputType | null
    _min: OperationMinAggregateOutputType | null
    _max: OperationMaxAggregateOutputType | null
  }

  type GetOperationGroupByPayload<T extends OperationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<OperationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OperationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OperationGroupByOutputType[P]>
            : GetScalarType<T[P], OperationGroupByOutputType[P]>
        }
      >
    >


  export type OperationSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    name?: boolean
    description?: boolean
    materialId?: boolean
    material?: boolean | MaterialArgs
    specs?: boolean | Operation$specsArgs
    _count?: boolean | OperationCountOutputTypeArgs
  }


  export type OperationInclude = {
    material?: boolean | MaterialArgs
    specs?: boolean | Operation$specsArgs
    _count?: boolean | OperationCountOutputTypeArgs
  }

  export type OperationGetPayload<S extends boolean | null | undefined | OperationArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Operation :
    S extends undefined ? never :
    S extends { include: any } & (OperationArgs | OperationFindManyArgs)
    ? Operation  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'material' ? MaterialGetPayload<S['include'][P]> :
        P extends 'specs' ? Array < OperationSpecGetPayload<S['include'][P]>>  :
        P extends '_count' ? OperationCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (OperationArgs | OperationFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'material' ? MaterialGetPayload<S['select'][P]> :
        P extends 'specs' ? Array < OperationSpecGetPayload<S['select'][P]>>  :
        P extends '_count' ? OperationCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Operation ? Operation[P] : never
  } 
      : Operation


  type OperationCountArgs = 
    Omit<OperationFindManyArgs, 'select' | 'include'> & {
      select?: OperationCountAggregateInputType | true
    }

  export interface OperationDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Operation that matches the filter.
     * @param {OperationFindUniqueArgs} args - Arguments to find a Operation
     * @example
     * // Get one Operation
     * const operation = await prisma.operation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OperationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OperationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Operation'> extends True ? Prisma__OperationClient<OperationGetPayload<T>> : Prisma__OperationClient<OperationGetPayload<T> | null, null>

    /**
     * Find one Operation that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OperationFindUniqueOrThrowArgs} args - Arguments to find a Operation
     * @example
     * // Get one Operation
     * const operation = await prisma.operation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OperationFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, OperationFindUniqueOrThrowArgs>
    ): Prisma__OperationClient<OperationGetPayload<T>>

    /**
     * Find the first Operation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationFindFirstArgs} args - Arguments to find a Operation
     * @example
     * // Get one Operation
     * const operation = await prisma.operation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OperationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OperationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Operation'> extends True ? Prisma__OperationClient<OperationGetPayload<T>> : Prisma__OperationClient<OperationGetPayload<T> | null, null>

    /**
     * Find the first Operation that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationFindFirstOrThrowArgs} args - Arguments to find a Operation
     * @example
     * // Get one Operation
     * const operation = await prisma.operation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OperationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, OperationFindFirstOrThrowArgs>
    ): Prisma__OperationClient<OperationGetPayload<T>>

    /**
     * Find zero or more Operations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Operations
     * const operations = await prisma.operation.findMany()
     * 
     * // Get first 10 Operations
     * const operations = await prisma.operation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const operationWithIdOnly = await prisma.operation.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OperationFindManyArgs>(
      args?: SelectSubset<T, OperationFindManyArgs>
    ): Prisma.PrismaPromise<Array<OperationGetPayload<T>>>

    /**
     * Create a Operation.
     * @param {OperationCreateArgs} args - Arguments to create a Operation.
     * @example
     * // Create one Operation
     * const Operation = await prisma.operation.create({
     *   data: {
     *     // ... data to create a Operation
     *   }
     * })
     * 
    **/
    create<T extends OperationCreateArgs>(
      args: SelectSubset<T, OperationCreateArgs>
    ): Prisma__OperationClient<OperationGetPayload<T>>

    /**
     * Create many Operations.
     *     @param {OperationCreateManyArgs} args - Arguments to create many Operations.
     *     @example
     *     // Create many Operations
     *     const operation = await prisma.operation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OperationCreateManyArgs>(
      args?: SelectSubset<T, OperationCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Operation.
     * @param {OperationDeleteArgs} args - Arguments to delete one Operation.
     * @example
     * // Delete one Operation
     * const Operation = await prisma.operation.delete({
     *   where: {
     *     // ... filter to delete one Operation
     *   }
     * })
     * 
    **/
    delete<T extends OperationDeleteArgs>(
      args: SelectSubset<T, OperationDeleteArgs>
    ): Prisma__OperationClient<OperationGetPayload<T>>

    /**
     * Update one Operation.
     * @param {OperationUpdateArgs} args - Arguments to update one Operation.
     * @example
     * // Update one Operation
     * const operation = await prisma.operation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OperationUpdateArgs>(
      args: SelectSubset<T, OperationUpdateArgs>
    ): Prisma__OperationClient<OperationGetPayload<T>>

    /**
     * Delete zero or more Operations.
     * @param {OperationDeleteManyArgs} args - Arguments to filter Operations to delete.
     * @example
     * // Delete a few Operations
     * const { count } = await prisma.operation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OperationDeleteManyArgs>(
      args?: SelectSubset<T, OperationDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Operations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Operations
     * const operation = await prisma.operation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OperationUpdateManyArgs>(
      args: SelectSubset<T, OperationUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Operation.
     * @param {OperationUpsertArgs} args - Arguments to update or create a Operation.
     * @example
     * // Update or create a Operation
     * const operation = await prisma.operation.upsert({
     *   create: {
     *     // ... data to create a Operation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Operation we want to update
     *   }
     * })
    **/
    upsert<T extends OperationUpsertArgs>(
      args: SelectSubset<T, OperationUpsertArgs>
    ): Prisma__OperationClient<OperationGetPayload<T>>

    /**
     * Count the number of Operations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationCountArgs} args - Arguments to filter Operations to count.
     * @example
     * // Count the number of Operations
     * const count = await prisma.operation.count({
     *   where: {
     *     // ... the filter for the Operations we want to count
     *   }
     * })
    **/
    count<T extends OperationCountArgs>(
      args?: Subset<T, OperationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OperationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Operation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OperationAggregateArgs>(args: Subset<T, OperationAggregateArgs>): Prisma.PrismaPromise<GetOperationAggregateType<T>>

    /**
     * Group by Operation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OperationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OperationGroupByArgs['orderBy'] }
        : { orderBy?: OperationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OperationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOperationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Operation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OperationClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    material<T extends MaterialArgs= {}>(args?: Subset<T, MaterialArgs>): Prisma__MaterialClient<MaterialGetPayload<T> | Null>;

    specs<T extends Operation$specsArgs= {}>(args?: Subset<T, Operation$specsArgs>): Prisma.PrismaPromise<Array<OperationSpecGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Operation base type for findUnique actions
   */
  export type OperationFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Operation
     */
    select?: OperationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OperationInclude | null
    /**
     * Filter, which Operation to fetch.
     */
    where: OperationWhereUniqueInput
  }

  /**
   * Operation findUnique
   */
  export interface OperationFindUniqueArgs extends OperationFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Operation findUniqueOrThrow
   */
  export type OperationFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Operation
     */
    select?: OperationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OperationInclude | null
    /**
     * Filter, which Operation to fetch.
     */
    where: OperationWhereUniqueInput
  }


  /**
   * Operation base type for findFirst actions
   */
  export type OperationFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Operation
     */
    select?: OperationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OperationInclude | null
    /**
     * Filter, which Operation to fetch.
     */
    where?: OperationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Operations to fetch.
     */
    orderBy?: Enumerable<OperationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Operations.
     */
    cursor?: OperationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Operations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Operations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Operations.
     */
    distinct?: Enumerable<OperationScalarFieldEnum>
  }

  /**
   * Operation findFirst
   */
  export interface OperationFindFirstArgs extends OperationFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Operation findFirstOrThrow
   */
  export type OperationFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Operation
     */
    select?: OperationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OperationInclude | null
    /**
     * Filter, which Operation to fetch.
     */
    where?: OperationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Operations to fetch.
     */
    orderBy?: Enumerable<OperationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Operations.
     */
    cursor?: OperationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Operations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Operations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Operations.
     */
    distinct?: Enumerable<OperationScalarFieldEnum>
  }


  /**
   * Operation findMany
   */
  export type OperationFindManyArgs = {
    /**
     * Select specific fields to fetch from the Operation
     */
    select?: OperationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OperationInclude | null
    /**
     * Filter, which Operations to fetch.
     */
    where?: OperationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Operations to fetch.
     */
    orderBy?: Enumerable<OperationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Operations.
     */
    cursor?: OperationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Operations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Operations.
     */
    skip?: number
    distinct?: Enumerable<OperationScalarFieldEnum>
  }


  /**
   * Operation create
   */
  export type OperationCreateArgs = {
    /**
     * Select specific fields to fetch from the Operation
     */
    select?: OperationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OperationInclude | null
    /**
     * The data needed to create a Operation.
     */
    data: XOR<OperationCreateInput, OperationUncheckedCreateInput>
  }


  /**
   * Operation createMany
   */
  export type OperationCreateManyArgs = {
    /**
     * The data used to create many Operations.
     */
    data: Enumerable<OperationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Operation update
   */
  export type OperationUpdateArgs = {
    /**
     * Select specific fields to fetch from the Operation
     */
    select?: OperationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OperationInclude | null
    /**
     * The data needed to update a Operation.
     */
    data: XOR<OperationUpdateInput, OperationUncheckedUpdateInput>
    /**
     * Choose, which Operation to update.
     */
    where: OperationWhereUniqueInput
  }


  /**
   * Operation updateMany
   */
  export type OperationUpdateManyArgs = {
    /**
     * The data used to update Operations.
     */
    data: XOR<OperationUpdateManyMutationInput, OperationUncheckedUpdateManyInput>
    /**
     * Filter which Operations to update
     */
    where?: OperationWhereInput
  }


  /**
   * Operation upsert
   */
  export type OperationUpsertArgs = {
    /**
     * Select specific fields to fetch from the Operation
     */
    select?: OperationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OperationInclude | null
    /**
     * The filter to search for the Operation to update in case it exists.
     */
    where: OperationWhereUniqueInput
    /**
     * In case the Operation found by the `where` argument doesn't exist, create a new Operation with this data.
     */
    create: XOR<OperationCreateInput, OperationUncheckedCreateInput>
    /**
     * In case the Operation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OperationUpdateInput, OperationUncheckedUpdateInput>
  }


  /**
   * Operation delete
   */
  export type OperationDeleteArgs = {
    /**
     * Select specific fields to fetch from the Operation
     */
    select?: OperationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OperationInclude | null
    /**
     * Filter which Operation to delete.
     */
    where: OperationWhereUniqueInput
  }


  /**
   * Operation deleteMany
   */
  export type OperationDeleteManyArgs = {
    /**
     * Filter which Operations to delete
     */
    where?: OperationWhereInput
  }


  /**
   * Operation.specs
   */
  export type Operation$specsArgs = {
    /**
     * Select specific fields to fetch from the OperationSpec
     */
    select?: OperationSpecSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OperationSpecInclude | null
    where?: OperationSpecWhereInput
    orderBy?: Enumerable<OperationSpecOrderByWithRelationInput>
    cursor?: OperationSpecWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<OperationSpecScalarFieldEnum>
  }


  /**
   * Operation without action
   */
  export type OperationArgs = {
    /**
     * Select specific fields to fetch from the Operation
     */
    select?: OperationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OperationInclude | null
  }



  /**
   * Model OperationSpec
   */


  export type AggregateOperationSpec = {
    _count: OperationSpecCountAggregateOutputType | null
    _avg: OperationSpecAvgAggregateOutputType | null
    _sum: OperationSpecSumAggregateOutputType | null
    _min: OperationSpecMinAggregateOutputType | null
    _max: OperationSpecMaxAggregateOutputType | null
  }

  export type OperationSpecAvgAggregateOutputType = {
    id: number | null
    operationId: number | null
  }

  export type OperationSpecSumAggregateOutputType = {
    id: number | null
    operationId: number | null
  }

  export type OperationSpecMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    name: string | null
    description: string | null
    operationId: number | null
  }

  export type OperationSpecMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    name: string | null
    description: string | null
    operationId: number | null
  }

  export type OperationSpecCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    isDeleted: number
    name: number
    description: number
    operationId: number
    _all: number
  }


  export type OperationSpecAvgAggregateInputType = {
    id?: true
    operationId?: true
  }

  export type OperationSpecSumAggregateInputType = {
    id?: true
    operationId?: true
  }

  export type OperationSpecMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    name?: true
    description?: true
    operationId?: true
  }

  export type OperationSpecMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    name?: true
    description?: true
    operationId?: true
  }

  export type OperationSpecCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    name?: true
    description?: true
    operationId?: true
    _all?: true
  }

  export type OperationSpecAggregateArgs = {
    /**
     * Filter which OperationSpec to aggregate.
     */
    where?: OperationSpecWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperationSpecs to fetch.
     */
    orderBy?: Enumerable<OperationSpecOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OperationSpecWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperationSpecs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperationSpecs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OperationSpecs
    **/
    _count?: true | OperationSpecCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OperationSpecAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OperationSpecSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OperationSpecMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OperationSpecMaxAggregateInputType
  }

  export type GetOperationSpecAggregateType<T extends OperationSpecAggregateArgs> = {
        [P in keyof T & keyof AggregateOperationSpec]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOperationSpec[P]>
      : GetScalarType<T[P], AggregateOperationSpec[P]>
  }




  export type OperationSpecGroupByArgs = {
    where?: OperationSpecWhereInput
    orderBy?: Enumerable<OperationSpecOrderByWithAggregationInput>
    by: OperationSpecScalarFieldEnum[]
    having?: OperationSpecScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OperationSpecCountAggregateInputType | true
    _avg?: OperationSpecAvgAggregateInputType
    _sum?: OperationSpecSumAggregateInputType
    _min?: OperationSpecMinAggregateInputType
    _max?: OperationSpecMaxAggregateInputType
  }


  export type OperationSpecGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    isDeleted: boolean
    name: string
    description: string | null
    operationId: number
    _count: OperationSpecCountAggregateOutputType | null
    _avg: OperationSpecAvgAggregateOutputType | null
    _sum: OperationSpecSumAggregateOutputType | null
    _min: OperationSpecMinAggregateOutputType | null
    _max: OperationSpecMaxAggregateOutputType | null
  }

  type GetOperationSpecGroupByPayload<T extends OperationSpecGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<OperationSpecGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OperationSpecGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OperationSpecGroupByOutputType[P]>
            : GetScalarType<T[P], OperationSpecGroupByOutputType[P]>
        }
      >
    >


  export type OperationSpecSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    name?: boolean
    description?: boolean
    operationId?: boolean
    operation?: boolean | OperationArgs
    inspect?: boolean | OperationSpec$inspectArgs
    _count?: boolean | OperationSpecCountOutputTypeArgs
  }


  export type OperationSpecInclude = {
    operation?: boolean | OperationArgs
    inspect?: boolean | OperationSpec$inspectArgs
    _count?: boolean | OperationSpecCountOutputTypeArgs
  }

  export type OperationSpecGetPayload<S extends boolean | null | undefined | OperationSpecArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? OperationSpec :
    S extends undefined ? never :
    S extends { include: any } & (OperationSpecArgs | OperationSpecFindManyArgs)
    ? OperationSpec  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'operation' ? OperationGetPayload<S['include'][P]> :
        P extends 'inspect' ? Array < OperationSpecInspectGetPayload<S['include'][P]>>  :
        P extends '_count' ? OperationSpecCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (OperationSpecArgs | OperationSpecFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'operation' ? OperationGetPayload<S['select'][P]> :
        P extends 'inspect' ? Array < OperationSpecInspectGetPayload<S['select'][P]>>  :
        P extends '_count' ? OperationSpecCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof OperationSpec ? OperationSpec[P] : never
  } 
      : OperationSpec


  type OperationSpecCountArgs = 
    Omit<OperationSpecFindManyArgs, 'select' | 'include'> & {
      select?: OperationSpecCountAggregateInputType | true
    }

  export interface OperationSpecDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one OperationSpec that matches the filter.
     * @param {OperationSpecFindUniqueArgs} args - Arguments to find a OperationSpec
     * @example
     * // Get one OperationSpec
     * const operationSpec = await prisma.operationSpec.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OperationSpecFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OperationSpecFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'OperationSpec'> extends True ? Prisma__OperationSpecClient<OperationSpecGetPayload<T>> : Prisma__OperationSpecClient<OperationSpecGetPayload<T> | null, null>

    /**
     * Find one OperationSpec that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OperationSpecFindUniqueOrThrowArgs} args - Arguments to find a OperationSpec
     * @example
     * // Get one OperationSpec
     * const operationSpec = await prisma.operationSpec.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OperationSpecFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, OperationSpecFindUniqueOrThrowArgs>
    ): Prisma__OperationSpecClient<OperationSpecGetPayload<T>>

    /**
     * Find the first OperationSpec that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationSpecFindFirstArgs} args - Arguments to find a OperationSpec
     * @example
     * // Get one OperationSpec
     * const operationSpec = await prisma.operationSpec.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OperationSpecFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OperationSpecFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'OperationSpec'> extends True ? Prisma__OperationSpecClient<OperationSpecGetPayload<T>> : Prisma__OperationSpecClient<OperationSpecGetPayload<T> | null, null>

    /**
     * Find the first OperationSpec that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationSpecFindFirstOrThrowArgs} args - Arguments to find a OperationSpec
     * @example
     * // Get one OperationSpec
     * const operationSpec = await prisma.operationSpec.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OperationSpecFindFirstOrThrowArgs>(
      args?: SelectSubset<T, OperationSpecFindFirstOrThrowArgs>
    ): Prisma__OperationSpecClient<OperationSpecGetPayload<T>>

    /**
     * Find zero or more OperationSpecs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationSpecFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OperationSpecs
     * const operationSpecs = await prisma.operationSpec.findMany()
     * 
     * // Get first 10 OperationSpecs
     * const operationSpecs = await prisma.operationSpec.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const operationSpecWithIdOnly = await prisma.operationSpec.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OperationSpecFindManyArgs>(
      args?: SelectSubset<T, OperationSpecFindManyArgs>
    ): Prisma.PrismaPromise<Array<OperationSpecGetPayload<T>>>

    /**
     * Create a OperationSpec.
     * @param {OperationSpecCreateArgs} args - Arguments to create a OperationSpec.
     * @example
     * // Create one OperationSpec
     * const OperationSpec = await prisma.operationSpec.create({
     *   data: {
     *     // ... data to create a OperationSpec
     *   }
     * })
     * 
    **/
    create<T extends OperationSpecCreateArgs>(
      args: SelectSubset<T, OperationSpecCreateArgs>
    ): Prisma__OperationSpecClient<OperationSpecGetPayload<T>>

    /**
     * Create many OperationSpecs.
     *     @param {OperationSpecCreateManyArgs} args - Arguments to create many OperationSpecs.
     *     @example
     *     // Create many OperationSpecs
     *     const operationSpec = await prisma.operationSpec.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OperationSpecCreateManyArgs>(
      args?: SelectSubset<T, OperationSpecCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OperationSpec.
     * @param {OperationSpecDeleteArgs} args - Arguments to delete one OperationSpec.
     * @example
     * // Delete one OperationSpec
     * const OperationSpec = await prisma.operationSpec.delete({
     *   where: {
     *     // ... filter to delete one OperationSpec
     *   }
     * })
     * 
    **/
    delete<T extends OperationSpecDeleteArgs>(
      args: SelectSubset<T, OperationSpecDeleteArgs>
    ): Prisma__OperationSpecClient<OperationSpecGetPayload<T>>

    /**
     * Update one OperationSpec.
     * @param {OperationSpecUpdateArgs} args - Arguments to update one OperationSpec.
     * @example
     * // Update one OperationSpec
     * const operationSpec = await prisma.operationSpec.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OperationSpecUpdateArgs>(
      args: SelectSubset<T, OperationSpecUpdateArgs>
    ): Prisma__OperationSpecClient<OperationSpecGetPayload<T>>

    /**
     * Delete zero or more OperationSpecs.
     * @param {OperationSpecDeleteManyArgs} args - Arguments to filter OperationSpecs to delete.
     * @example
     * // Delete a few OperationSpecs
     * const { count } = await prisma.operationSpec.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OperationSpecDeleteManyArgs>(
      args?: SelectSubset<T, OperationSpecDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OperationSpecs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationSpecUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OperationSpecs
     * const operationSpec = await prisma.operationSpec.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OperationSpecUpdateManyArgs>(
      args: SelectSubset<T, OperationSpecUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OperationSpec.
     * @param {OperationSpecUpsertArgs} args - Arguments to update or create a OperationSpec.
     * @example
     * // Update or create a OperationSpec
     * const operationSpec = await prisma.operationSpec.upsert({
     *   create: {
     *     // ... data to create a OperationSpec
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OperationSpec we want to update
     *   }
     * })
    **/
    upsert<T extends OperationSpecUpsertArgs>(
      args: SelectSubset<T, OperationSpecUpsertArgs>
    ): Prisma__OperationSpecClient<OperationSpecGetPayload<T>>

    /**
     * Count the number of OperationSpecs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationSpecCountArgs} args - Arguments to filter OperationSpecs to count.
     * @example
     * // Count the number of OperationSpecs
     * const count = await prisma.operationSpec.count({
     *   where: {
     *     // ... the filter for the OperationSpecs we want to count
     *   }
     * })
    **/
    count<T extends OperationSpecCountArgs>(
      args?: Subset<T, OperationSpecCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OperationSpecCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OperationSpec.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationSpecAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OperationSpecAggregateArgs>(args: Subset<T, OperationSpecAggregateArgs>): Prisma.PrismaPromise<GetOperationSpecAggregateType<T>>

    /**
     * Group by OperationSpec.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationSpecGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OperationSpecGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OperationSpecGroupByArgs['orderBy'] }
        : { orderBy?: OperationSpecGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OperationSpecGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOperationSpecGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for OperationSpec.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OperationSpecClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    operation<T extends OperationArgs= {}>(args?: Subset<T, OperationArgs>): Prisma__OperationClient<OperationGetPayload<T> | Null>;

    inspect<T extends OperationSpec$inspectArgs= {}>(args?: Subset<T, OperationSpec$inspectArgs>): Prisma.PrismaPromise<Array<OperationSpecInspectGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * OperationSpec base type for findUnique actions
   */
  export type OperationSpecFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the OperationSpec
     */
    select?: OperationSpecSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OperationSpecInclude | null
    /**
     * Filter, which OperationSpec to fetch.
     */
    where: OperationSpecWhereUniqueInput
  }

  /**
   * OperationSpec findUnique
   */
  export interface OperationSpecFindUniqueArgs extends OperationSpecFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * OperationSpec findUniqueOrThrow
   */
  export type OperationSpecFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the OperationSpec
     */
    select?: OperationSpecSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OperationSpecInclude | null
    /**
     * Filter, which OperationSpec to fetch.
     */
    where: OperationSpecWhereUniqueInput
  }


  /**
   * OperationSpec base type for findFirst actions
   */
  export type OperationSpecFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the OperationSpec
     */
    select?: OperationSpecSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OperationSpecInclude | null
    /**
     * Filter, which OperationSpec to fetch.
     */
    where?: OperationSpecWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperationSpecs to fetch.
     */
    orderBy?: Enumerable<OperationSpecOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OperationSpecs.
     */
    cursor?: OperationSpecWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperationSpecs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperationSpecs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OperationSpecs.
     */
    distinct?: Enumerable<OperationSpecScalarFieldEnum>
  }

  /**
   * OperationSpec findFirst
   */
  export interface OperationSpecFindFirstArgs extends OperationSpecFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * OperationSpec findFirstOrThrow
   */
  export type OperationSpecFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the OperationSpec
     */
    select?: OperationSpecSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OperationSpecInclude | null
    /**
     * Filter, which OperationSpec to fetch.
     */
    where?: OperationSpecWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperationSpecs to fetch.
     */
    orderBy?: Enumerable<OperationSpecOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OperationSpecs.
     */
    cursor?: OperationSpecWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperationSpecs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperationSpecs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OperationSpecs.
     */
    distinct?: Enumerable<OperationSpecScalarFieldEnum>
  }


  /**
   * OperationSpec findMany
   */
  export type OperationSpecFindManyArgs = {
    /**
     * Select specific fields to fetch from the OperationSpec
     */
    select?: OperationSpecSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OperationSpecInclude | null
    /**
     * Filter, which OperationSpecs to fetch.
     */
    where?: OperationSpecWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperationSpecs to fetch.
     */
    orderBy?: Enumerable<OperationSpecOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OperationSpecs.
     */
    cursor?: OperationSpecWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperationSpecs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperationSpecs.
     */
    skip?: number
    distinct?: Enumerable<OperationSpecScalarFieldEnum>
  }


  /**
   * OperationSpec create
   */
  export type OperationSpecCreateArgs = {
    /**
     * Select specific fields to fetch from the OperationSpec
     */
    select?: OperationSpecSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OperationSpecInclude | null
    /**
     * The data needed to create a OperationSpec.
     */
    data: XOR<OperationSpecCreateInput, OperationSpecUncheckedCreateInput>
  }


  /**
   * OperationSpec createMany
   */
  export type OperationSpecCreateManyArgs = {
    /**
     * The data used to create many OperationSpecs.
     */
    data: Enumerable<OperationSpecCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * OperationSpec update
   */
  export type OperationSpecUpdateArgs = {
    /**
     * Select specific fields to fetch from the OperationSpec
     */
    select?: OperationSpecSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OperationSpecInclude | null
    /**
     * The data needed to update a OperationSpec.
     */
    data: XOR<OperationSpecUpdateInput, OperationSpecUncheckedUpdateInput>
    /**
     * Choose, which OperationSpec to update.
     */
    where: OperationSpecWhereUniqueInput
  }


  /**
   * OperationSpec updateMany
   */
  export type OperationSpecUpdateManyArgs = {
    /**
     * The data used to update OperationSpecs.
     */
    data: XOR<OperationSpecUpdateManyMutationInput, OperationSpecUncheckedUpdateManyInput>
    /**
     * Filter which OperationSpecs to update
     */
    where?: OperationSpecWhereInput
  }


  /**
   * OperationSpec upsert
   */
  export type OperationSpecUpsertArgs = {
    /**
     * Select specific fields to fetch from the OperationSpec
     */
    select?: OperationSpecSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OperationSpecInclude | null
    /**
     * The filter to search for the OperationSpec to update in case it exists.
     */
    where: OperationSpecWhereUniqueInput
    /**
     * In case the OperationSpec found by the `where` argument doesn't exist, create a new OperationSpec with this data.
     */
    create: XOR<OperationSpecCreateInput, OperationSpecUncheckedCreateInput>
    /**
     * In case the OperationSpec was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OperationSpecUpdateInput, OperationSpecUncheckedUpdateInput>
  }


  /**
   * OperationSpec delete
   */
  export type OperationSpecDeleteArgs = {
    /**
     * Select specific fields to fetch from the OperationSpec
     */
    select?: OperationSpecSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OperationSpecInclude | null
    /**
     * Filter which OperationSpec to delete.
     */
    where: OperationSpecWhereUniqueInput
  }


  /**
   * OperationSpec deleteMany
   */
  export type OperationSpecDeleteManyArgs = {
    /**
     * Filter which OperationSpecs to delete
     */
    where?: OperationSpecWhereInput
  }


  /**
   * OperationSpec.inspect
   */
  export type OperationSpec$inspectArgs = {
    /**
     * Select specific fields to fetch from the OperationSpecInspect
     */
    select?: OperationSpecInspectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OperationSpecInspectInclude | null
    where?: OperationSpecInspectWhereInput
    orderBy?: Enumerable<OperationSpecInspectOrderByWithRelationInput>
    cursor?: OperationSpecInspectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<OperationSpecInspectScalarFieldEnum>
  }


  /**
   * OperationSpec without action
   */
  export type OperationSpecArgs = {
    /**
     * Select specific fields to fetch from the OperationSpec
     */
    select?: OperationSpecSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OperationSpecInclude | null
  }



  /**
   * Model IncomingInspectRecord
   */


  export type AggregateIncomingInspectRecord = {
    _count: IncomingInspectRecordCountAggregateOutputType | null
    _avg: IncomingInspectRecordAvgAggregateOutputType | null
    _sum: IncomingInspectRecordSumAggregateOutputType | null
    _min: IncomingInspectRecordMinAggregateOutputType | null
    _max: IncomingInspectRecordMaxAggregateOutputType | null
  }

  export type IncomingInspectRecordAvgAggregateOutputType = {
    id: number | null
    materialId: number | null
    inspectorId: number | null
    reviewerId: number | null
  }

  export type IncomingInspectRecordSumAggregateOutputType = {
    id: number | null
    materialId: number | null
    inspectorId: number | null
    reviewerId: number | null
  }

  export type IncomingInspectRecordMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    lot: string | null
    materialId: number | null
    description: string | null
    inspectorId: number | null
    reviewerId: number | null
    result: IncomingInspectResult | null
  }

  export type IncomingInspectRecordMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    lot: string | null
    materialId: number | null
    description: string | null
    inspectorId: number | null
    reviewerId: number | null
    result: IncomingInspectResult | null
  }

  export type IncomingInspectRecordCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    isDeleted: number
    lot: number
    materialId: number
    description: number
    inspectorId: number
    reviewerId: number
    result: number
    _all: number
  }


  export type IncomingInspectRecordAvgAggregateInputType = {
    id?: true
    materialId?: true
    inspectorId?: true
    reviewerId?: true
  }

  export type IncomingInspectRecordSumAggregateInputType = {
    id?: true
    materialId?: true
    inspectorId?: true
    reviewerId?: true
  }

  export type IncomingInspectRecordMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    lot?: true
    materialId?: true
    description?: true
    inspectorId?: true
    reviewerId?: true
    result?: true
  }

  export type IncomingInspectRecordMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    lot?: true
    materialId?: true
    description?: true
    inspectorId?: true
    reviewerId?: true
    result?: true
  }

  export type IncomingInspectRecordCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    lot?: true
    materialId?: true
    description?: true
    inspectorId?: true
    reviewerId?: true
    result?: true
    _all?: true
  }

  export type IncomingInspectRecordAggregateArgs = {
    /**
     * Filter which IncomingInspectRecord to aggregate.
     */
    where?: IncomingInspectRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncomingInspectRecords to fetch.
     */
    orderBy?: Enumerable<IncomingInspectRecordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IncomingInspectRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncomingInspectRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncomingInspectRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IncomingInspectRecords
    **/
    _count?: true | IncomingInspectRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IncomingInspectRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IncomingInspectRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IncomingInspectRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IncomingInspectRecordMaxAggregateInputType
  }

  export type GetIncomingInspectRecordAggregateType<T extends IncomingInspectRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateIncomingInspectRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIncomingInspectRecord[P]>
      : GetScalarType<T[P], AggregateIncomingInspectRecord[P]>
  }




  export type IncomingInspectRecordGroupByArgs = {
    where?: IncomingInspectRecordWhereInput
    orderBy?: Enumerable<IncomingInspectRecordOrderByWithAggregationInput>
    by: IncomingInspectRecordScalarFieldEnum[]
    having?: IncomingInspectRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IncomingInspectRecordCountAggregateInputType | true
    _avg?: IncomingInspectRecordAvgAggregateInputType
    _sum?: IncomingInspectRecordSumAggregateInputType
    _min?: IncomingInspectRecordMinAggregateInputType
    _max?: IncomingInspectRecordMaxAggregateInputType
  }


  export type IncomingInspectRecordGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    isDeleted: boolean
    lot: string
    materialId: number
    description: string | null
    inspectorId: number
    reviewerId: number
    result: IncomingInspectResult
    _count: IncomingInspectRecordCountAggregateOutputType | null
    _avg: IncomingInspectRecordAvgAggregateOutputType | null
    _sum: IncomingInspectRecordSumAggregateOutputType | null
    _min: IncomingInspectRecordMinAggregateOutputType | null
    _max: IncomingInspectRecordMaxAggregateOutputType | null
  }

  type GetIncomingInspectRecordGroupByPayload<T extends IncomingInspectRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<IncomingInspectRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IncomingInspectRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IncomingInspectRecordGroupByOutputType[P]>
            : GetScalarType<T[P], IncomingInspectRecordGroupByOutputType[P]>
        }
      >
    >


  export type IncomingInspectRecordSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    lot?: boolean
    materialId?: boolean
    description?: boolean
    inspectorId?: boolean
    reviewerId?: boolean
    result?: boolean
    material?: boolean | MaterialArgs
    details?: boolean | IncomingInspectRecord$detailsArgs
    inspector?: boolean | UserArgs
    reviewer?: boolean | UserArgs
    _count?: boolean | IncomingInspectRecordCountOutputTypeArgs
  }


  export type IncomingInspectRecordInclude = {
    material?: boolean | MaterialArgs
    details?: boolean | IncomingInspectRecord$detailsArgs
    inspector?: boolean | UserArgs
    reviewer?: boolean | UserArgs
    _count?: boolean | IncomingInspectRecordCountOutputTypeArgs
  }

  export type IncomingInspectRecordGetPayload<S extends boolean | null | undefined | IncomingInspectRecordArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? IncomingInspectRecord :
    S extends undefined ? never :
    S extends { include: any } & (IncomingInspectRecordArgs | IncomingInspectRecordFindManyArgs)
    ? IncomingInspectRecord  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'material' ? MaterialGetPayload<S['include'][P]> :
        P extends 'details' ? Array < MaterialSpecInspectGetPayload<S['include'][P]>>  :
        P extends 'inspector' ? UserGetPayload<S['include'][P]> | null :
        P extends 'reviewer' ? UserGetPayload<S['include'][P]> | null :
        P extends '_count' ? IncomingInspectRecordCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (IncomingInspectRecordArgs | IncomingInspectRecordFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'material' ? MaterialGetPayload<S['select'][P]> :
        P extends 'details' ? Array < MaterialSpecInspectGetPayload<S['select'][P]>>  :
        P extends 'inspector' ? UserGetPayload<S['select'][P]> | null :
        P extends 'reviewer' ? UserGetPayload<S['select'][P]> | null :
        P extends '_count' ? IncomingInspectRecordCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof IncomingInspectRecord ? IncomingInspectRecord[P] : never
  } 
      : IncomingInspectRecord


  type IncomingInspectRecordCountArgs = 
    Omit<IncomingInspectRecordFindManyArgs, 'select' | 'include'> & {
      select?: IncomingInspectRecordCountAggregateInputType | true
    }

  export interface IncomingInspectRecordDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one IncomingInspectRecord that matches the filter.
     * @param {IncomingInspectRecordFindUniqueArgs} args - Arguments to find a IncomingInspectRecord
     * @example
     * // Get one IncomingInspectRecord
     * const incomingInspectRecord = await prisma.incomingInspectRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends IncomingInspectRecordFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, IncomingInspectRecordFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'IncomingInspectRecord'> extends True ? Prisma__IncomingInspectRecordClient<IncomingInspectRecordGetPayload<T>> : Prisma__IncomingInspectRecordClient<IncomingInspectRecordGetPayload<T> | null, null>

    /**
     * Find one IncomingInspectRecord that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {IncomingInspectRecordFindUniqueOrThrowArgs} args - Arguments to find a IncomingInspectRecord
     * @example
     * // Get one IncomingInspectRecord
     * const incomingInspectRecord = await prisma.incomingInspectRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends IncomingInspectRecordFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, IncomingInspectRecordFindUniqueOrThrowArgs>
    ): Prisma__IncomingInspectRecordClient<IncomingInspectRecordGetPayload<T>>

    /**
     * Find the first IncomingInspectRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomingInspectRecordFindFirstArgs} args - Arguments to find a IncomingInspectRecord
     * @example
     * // Get one IncomingInspectRecord
     * const incomingInspectRecord = await prisma.incomingInspectRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends IncomingInspectRecordFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, IncomingInspectRecordFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'IncomingInspectRecord'> extends True ? Prisma__IncomingInspectRecordClient<IncomingInspectRecordGetPayload<T>> : Prisma__IncomingInspectRecordClient<IncomingInspectRecordGetPayload<T> | null, null>

    /**
     * Find the first IncomingInspectRecord that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomingInspectRecordFindFirstOrThrowArgs} args - Arguments to find a IncomingInspectRecord
     * @example
     * // Get one IncomingInspectRecord
     * const incomingInspectRecord = await prisma.incomingInspectRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends IncomingInspectRecordFindFirstOrThrowArgs>(
      args?: SelectSubset<T, IncomingInspectRecordFindFirstOrThrowArgs>
    ): Prisma__IncomingInspectRecordClient<IncomingInspectRecordGetPayload<T>>

    /**
     * Find zero or more IncomingInspectRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomingInspectRecordFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IncomingInspectRecords
     * const incomingInspectRecords = await prisma.incomingInspectRecord.findMany()
     * 
     * // Get first 10 IncomingInspectRecords
     * const incomingInspectRecords = await prisma.incomingInspectRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const incomingInspectRecordWithIdOnly = await prisma.incomingInspectRecord.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends IncomingInspectRecordFindManyArgs>(
      args?: SelectSubset<T, IncomingInspectRecordFindManyArgs>
    ): Prisma.PrismaPromise<Array<IncomingInspectRecordGetPayload<T>>>

    /**
     * Create a IncomingInspectRecord.
     * @param {IncomingInspectRecordCreateArgs} args - Arguments to create a IncomingInspectRecord.
     * @example
     * // Create one IncomingInspectRecord
     * const IncomingInspectRecord = await prisma.incomingInspectRecord.create({
     *   data: {
     *     // ... data to create a IncomingInspectRecord
     *   }
     * })
     * 
    **/
    create<T extends IncomingInspectRecordCreateArgs>(
      args: SelectSubset<T, IncomingInspectRecordCreateArgs>
    ): Prisma__IncomingInspectRecordClient<IncomingInspectRecordGetPayload<T>>

    /**
     * Create many IncomingInspectRecords.
     *     @param {IncomingInspectRecordCreateManyArgs} args - Arguments to create many IncomingInspectRecords.
     *     @example
     *     // Create many IncomingInspectRecords
     *     const incomingInspectRecord = await prisma.incomingInspectRecord.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends IncomingInspectRecordCreateManyArgs>(
      args?: SelectSubset<T, IncomingInspectRecordCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a IncomingInspectRecord.
     * @param {IncomingInspectRecordDeleteArgs} args - Arguments to delete one IncomingInspectRecord.
     * @example
     * // Delete one IncomingInspectRecord
     * const IncomingInspectRecord = await prisma.incomingInspectRecord.delete({
     *   where: {
     *     // ... filter to delete one IncomingInspectRecord
     *   }
     * })
     * 
    **/
    delete<T extends IncomingInspectRecordDeleteArgs>(
      args: SelectSubset<T, IncomingInspectRecordDeleteArgs>
    ): Prisma__IncomingInspectRecordClient<IncomingInspectRecordGetPayload<T>>

    /**
     * Update one IncomingInspectRecord.
     * @param {IncomingInspectRecordUpdateArgs} args - Arguments to update one IncomingInspectRecord.
     * @example
     * // Update one IncomingInspectRecord
     * const incomingInspectRecord = await prisma.incomingInspectRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends IncomingInspectRecordUpdateArgs>(
      args: SelectSubset<T, IncomingInspectRecordUpdateArgs>
    ): Prisma__IncomingInspectRecordClient<IncomingInspectRecordGetPayload<T>>

    /**
     * Delete zero or more IncomingInspectRecords.
     * @param {IncomingInspectRecordDeleteManyArgs} args - Arguments to filter IncomingInspectRecords to delete.
     * @example
     * // Delete a few IncomingInspectRecords
     * const { count } = await prisma.incomingInspectRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends IncomingInspectRecordDeleteManyArgs>(
      args?: SelectSubset<T, IncomingInspectRecordDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IncomingInspectRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomingInspectRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IncomingInspectRecords
     * const incomingInspectRecord = await prisma.incomingInspectRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends IncomingInspectRecordUpdateManyArgs>(
      args: SelectSubset<T, IncomingInspectRecordUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one IncomingInspectRecord.
     * @param {IncomingInspectRecordUpsertArgs} args - Arguments to update or create a IncomingInspectRecord.
     * @example
     * // Update or create a IncomingInspectRecord
     * const incomingInspectRecord = await prisma.incomingInspectRecord.upsert({
     *   create: {
     *     // ... data to create a IncomingInspectRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IncomingInspectRecord we want to update
     *   }
     * })
    **/
    upsert<T extends IncomingInspectRecordUpsertArgs>(
      args: SelectSubset<T, IncomingInspectRecordUpsertArgs>
    ): Prisma__IncomingInspectRecordClient<IncomingInspectRecordGetPayload<T>>

    /**
     * Count the number of IncomingInspectRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomingInspectRecordCountArgs} args - Arguments to filter IncomingInspectRecords to count.
     * @example
     * // Count the number of IncomingInspectRecords
     * const count = await prisma.incomingInspectRecord.count({
     *   where: {
     *     // ... the filter for the IncomingInspectRecords we want to count
     *   }
     * })
    **/
    count<T extends IncomingInspectRecordCountArgs>(
      args?: Subset<T, IncomingInspectRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IncomingInspectRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IncomingInspectRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomingInspectRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IncomingInspectRecordAggregateArgs>(args: Subset<T, IncomingInspectRecordAggregateArgs>): Prisma.PrismaPromise<GetIncomingInspectRecordAggregateType<T>>

    /**
     * Group by IncomingInspectRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomingInspectRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IncomingInspectRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IncomingInspectRecordGroupByArgs['orderBy'] }
        : { orderBy?: IncomingInspectRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IncomingInspectRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIncomingInspectRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for IncomingInspectRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__IncomingInspectRecordClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    material<T extends MaterialArgs= {}>(args?: Subset<T, MaterialArgs>): Prisma__MaterialClient<MaterialGetPayload<T> | Null>;

    details<T extends IncomingInspectRecord$detailsArgs= {}>(args?: Subset<T, IncomingInspectRecord$detailsArgs>): Prisma.PrismaPromise<Array<MaterialSpecInspectGetPayload<T>>| Null>;

    inspector<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    reviewer<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * IncomingInspectRecord base type for findUnique actions
   */
  export type IncomingInspectRecordFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the IncomingInspectRecord
     */
    select?: IncomingInspectRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IncomingInspectRecordInclude | null
    /**
     * Filter, which IncomingInspectRecord to fetch.
     */
    where: IncomingInspectRecordWhereUniqueInput
  }

  /**
   * IncomingInspectRecord findUnique
   */
  export interface IncomingInspectRecordFindUniqueArgs extends IncomingInspectRecordFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * IncomingInspectRecord findUniqueOrThrow
   */
  export type IncomingInspectRecordFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the IncomingInspectRecord
     */
    select?: IncomingInspectRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IncomingInspectRecordInclude | null
    /**
     * Filter, which IncomingInspectRecord to fetch.
     */
    where: IncomingInspectRecordWhereUniqueInput
  }


  /**
   * IncomingInspectRecord base type for findFirst actions
   */
  export type IncomingInspectRecordFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the IncomingInspectRecord
     */
    select?: IncomingInspectRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IncomingInspectRecordInclude | null
    /**
     * Filter, which IncomingInspectRecord to fetch.
     */
    where?: IncomingInspectRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncomingInspectRecords to fetch.
     */
    orderBy?: Enumerable<IncomingInspectRecordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IncomingInspectRecords.
     */
    cursor?: IncomingInspectRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncomingInspectRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncomingInspectRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IncomingInspectRecords.
     */
    distinct?: Enumerable<IncomingInspectRecordScalarFieldEnum>
  }

  /**
   * IncomingInspectRecord findFirst
   */
  export interface IncomingInspectRecordFindFirstArgs extends IncomingInspectRecordFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * IncomingInspectRecord findFirstOrThrow
   */
  export type IncomingInspectRecordFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the IncomingInspectRecord
     */
    select?: IncomingInspectRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IncomingInspectRecordInclude | null
    /**
     * Filter, which IncomingInspectRecord to fetch.
     */
    where?: IncomingInspectRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncomingInspectRecords to fetch.
     */
    orderBy?: Enumerable<IncomingInspectRecordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IncomingInspectRecords.
     */
    cursor?: IncomingInspectRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncomingInspectRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncomingInspectRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IncomingInspectRecords.
     */
    distinct?: Enumerable<IncomingInspectRecordScalarFieldEnum>
  }


  /**
   * IncomingInspectRecord findMany
   */
  export type IncomingInspectRecordFindManyArgs = {
    /**
     * Select specific fields to fetch from the IncomingInspectRecord
     */
    select?: IncomingInspectRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IncomingInspectRecordInclude | null
    /**
     * Filter, which IncomingInspectRecords to fetch.
     */
    where?: IncomingInspectRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncomingInspectRecords to fetch.
     */
    orderBy?: Enumerable<IncomingInspectRecordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IncomingInspectRecords.
     */
    cursor?: IncomingInspectRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncomingInspectRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncomingInspectRecords.
     */
    skip?: number
    distinct?: Enumerable<IncomingInspectRecordScalarFieldEnum>
  }


  /**
   * IncomingInspectRecord create
   */
  export type IncomingInspectRecordCreateArgs = {
    /**
     * Select specific fields to fetch from the IncomingInspectRecord
     */
    select?: IncomingInspectRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IncomingInspectRecordInclude | null
    /**
     * The data needed to create a IncomingInspectRecord.
     */
    data: XOR<IncomingInspectRecordCreateInput, IncomingInspectRecordUncheckedCreateInput>
  }


  /**
   * IncomingInspectRecord createMany
   */
  export type IncomingInspectRecordCreateManyArgs = {
    /**
     * The data used to create many IncomingInspectRecords.
     */
    data: Enumerable<IncomingInspectRecordCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * IncomingInspectRecord update
   */
  export type IncomingInspectRecordUpdateArgs = {
    /**
     * Select specific fields to fetch from the IncomingInspectRecord
     */
    select?: IncomingInspectRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IncomingInspectRecordInclude | null
    /**
     * The data needed to update a IncomingInspectRecord.
     */
    data: XOR<IncomingInspectRecordUpdateInput, IncomingInspectRecordUncheckedUpdateInput>
    /**
     * Choose, which IncomingInspectRecord to update.
     */
    where: IncomingInspectRecordWhereUniqueInput
  }


  /**
   * IncomingInspectRecord updateMany
   */
  export type IncomingInspectRecordUpdateManyArgs = {
    /**
     * The data used to update IncomingInspectRecords.
     */
    data: XOR<IncomingInspectRecordUpdateManyMutationInput, IncomingInspectRecordUncheckedUpdateManyInput>
    /**
     * Filter which IncomingInspectRecords to update
     */
    where?: IncomingInspectRecordWhereInput
  }


  /**
   * IncomingInspectRecord upsert
   */
  export type IncomingInspectRecordUpsertArgs = {
    /**
     * Select specific fields to fetch from the IncomingInspectRecord
     */
    select?: IncomingInspectRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IncomingInspectRecordInclude | null
    /**
     * The filter to search for the IncomingInspectRecord to update in case it exists.
     */
    where: IncomingInspectRecordWhereUniqueInput
    /**
     * In case the IncomingInspectRecord found by the `where` argument doesn't exist, create a new IncomingInspectRecord with this data.
     */
    create: XOR<IncomingInspectRecordCreateInput, IncomingInspectRecordUncheckedCreateInput>
    /**
     * In case the IncomingInspectRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IncomingInspectRecordUpdateInput, IncomingInspectRecordUncheckedUpdateInput>
  }


  /**
   * IncomingInspectRecord delete
   */
  export type IncomingInspectRecordDeleteArgs = {
    /**
     * Select specific fields to fetch from the IncomingInspectRecord
     */
    select?: IncomingInspectRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IncomingInspectRecordInclude | null
    /**
     * Filter which IncomingInspectRecord to delete.
     */
    where: IncomingInspectRecordWhereUniqueInput
  }


  /**
   * IncomingInspectRecord deleteMany
   */
  export type IncomingInspectRecordDeleteManyArgs = {
    /**
     * Filter which IncomingInspectRecords to delete
     */
    where?: IncomingInspectRecordWhereInput
  }


  /**
   * IncomingInspectRecord.details
   */
  export type IncomingInspectRecord$detailsArgs = {
    /**
     * Select specific fields to fetch from the MaterialSpecInspect
     */
    select?: MaterialSpecInspectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MaterialSpecInspectInclude | null
    where?: MaterialSpecInspectWhereInput
    orderBy?: Enumerable<MaterialSpecInspectOrderByWithRelationInput>
    cursor?: MaterialSpecInspectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<MaterialSpecInspectScalarFieldEnum>
  }


  /**
   * IncomingInspectRecord without action
   */
  export type IncomingInspectRecordArgs = {
    /**
     * Select specific fields to fetch from the IncomingInspectRecord
     */
    select?: IncomingInspectRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IncomingInspectRecordInclude | null
  }



  /**
   * Model MaterialSpecInspect
   */


  export type AggregateMaterialSpecInspect = {
    _count: MaterialSpecInspectCountAggregateOutputType | null
    _avg: MaterialSpecInspectAvgAggregateOutputType | null
    _sum: MaterialSpecInspectSumAggregateOutputType | null
    _min: MaterialSpecInspectMinAggregateOutputType | null
    _max: MaterialSpecInspectMaxAggregateOutputType | null
  }

  export type MaterialSpecInspectAvgAggregateOutputType = {
    id: number | null
    recordId: number | null
    specId: number | null
  }

  export type MaterialSpecInspectSumAggregateOutputType = {
    id: number | null
    recordId: number | null
    specId: number | null
  }

  export type MaterialSpecInspectMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    recordId: number | null
    specId: number | null
    description: string | null
    result: boolean | null
  }

  export type MaterialSpecInspectMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    recordId: number | null
    specId: number | null
    description: string | null
    result: boolean | null
  }

  export type MaterialSpecInspectCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    isDeleted: number
    recordId: number
    specId: number
    description: number
    result: number
    _all: number
  }


  export type MaterialSpecInspectAvgAggregateInputType = {
    id?: true
    recordId?: true
    specId?: true
  }

  export type MaterialSpecInspectSumAggregateInputType = {
    id?: true
    recordId?: true
    specId?: true
  }

  export type MaterialSpecInspectMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    recordId?: true
    specId?: true
    description?: true
    result?: true
  }

  export type MaterialSpecInspectMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    recordId?: true
    specId?: true
    description?: true
    result?: true
  }

  export type MaterialSpecInspectCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    recordId?: true
    specId?: true
    description?: true
    result?: true
    _all?: true
  }

  export type MaterialSpecInspectAggregateArgs = {
    /**
     * Filter which MaterialSpecInspect to aggregate.
     */
    where?: MaterialSpecInspectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaterialSpecInspects to fetch.
     */
    orderBy?: Enumerable<MaterialSpecInspectOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MaterialSpecInspectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaterialSpecInspects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaterialSpecInspects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MaterialSpecInspects
    **/
    _count?: true | MaterialSpecInspectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MaterialSpecInspectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MaterialSpecInspectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaterialSpecInspectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaterialSpecInspectMaxAggregateInputType
  }

  export type GetMaterialSpecInspectAggregateType<T extends MaterialSpecInspectAggregateArgs> = {
        [P in keyof T & keyof AggregateMaterialSpecInspect]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaterialSpecInspect[P]>
      : GetScalarType<T[P], AggregateMaterialSpecInspect[P]>
  }




  export type MaterialSpecInspectGroupByArgs = {
    where?: MaterialSpecInspectWhereInput
    orderBy?: Enumerable<MaterialSpecInspectOrderByWithAggregationInput>
    by: MaterialSpecInspectScalarFieldEnum[]
    having?: MaterialSpecInspectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaterialSpecInspectCountAggregateInputType | true
    _avg?: MaterialSpecInspectAvgAggregateInputType
    _sum?: MaterialSpecInspectSumAggregateInputType
    _min?: MaterialSpecInspectMinAggregateInputType
    _max?: MaterialSpecInspectMaxAggregateInputType
  }


  export type MaterialSpecInspectGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    isDeleted: boolean
    recordId: number
    specId: number
    description: string | null
    result: boolean
    _count: MaterialSpecInspectCountAggregateOutputType | null
    _avg: MaterialSpecInspectAvgAggregateOutputType | null
    _sum: MaterialSpecInspectSumAggregateOutputType | null
    _min: MaterialSpecInspectMinAggregateOutputType | null
    _max: MaterialSpecInspectMaxAggregateOutputType | null
  }

  type GetMaterialSpecInspectGroupByPayload<T extends MaterialSpecInspectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<MaterialSpecInspectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaterialSpecInspectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaterialSpecInspectGroupByOutputType[P]>
            : GetScalarType<T[P], MaterialSpecInspectGroupByOutputType[P]>
        }
      >
    >


  export type MaterialSpecInspectSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    recordId?: boolean
    specId?: boolean
    description?: boolean
    result?: boolean
    record?: boolean | IncomingInspectRecordArgs
    spec?: boolean | MaterialSpecArgs
  }


  export type MaterialSpecInspectInclude = {
    record?: boolean | IncomingInspectRecordArgs
    spec?: boolean | MaterialSpecArgs
  }

  export type MaterialSpecInspectGetPayload<S extends boolean | null | undefined | MaterialSpecInspectArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? MaterialSpecInspect :
    S extends undefined ? never :
    S extends { include: any } & (MaterialSpecInspectArgs | MaterialSpecInspectFindManyArgs)
    ? MaterialSpecInspect  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'record' ? IncomingInspectRecordGetPayload<S['include'][P]> :
        P extends 'spec' ? MaterialSpecGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (MaterialSpecInspectArgs | MaterialSpecInspectFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'record' ? IncomingInspectRecordGetPayload<S['select'][P]> :
        P extends 'spec' ? MaterialSpecGetPayload<S['select'][P]> :  P extends keyof MaterialSpecInspect ? MaterialSpecInspect[P] : never
  } 
      : MaterialSpecInspect


  type MaterialSpecInspectCountArgs = 
    Omit<MaterialSpecInspectFindManyArgs, 'select' | 'include'> & {
      select?: MaterialSpecInspectCountAggregateInputType | true
    }

  export interface MaterialSpecInspectDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one MaterialSpecInspect that matches the filter.
     * @param {MaterialSpecInspectFindUniqueArgs} args - Arguments to find a MaterialSpecInspect
     * @example
     * // Get one MaterialSpecInspect
     * const materialSpecInspect = await prisma.materialSpecInspect.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MaterialSpecInspectFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MaterialSpecInspectFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'MaterialSpecInspect'> extends True ? Prisma__MaterialSpecInspectClient<MaterialSpecInspectGetPayload<T>> : Prisma__MaterialSpecInspectClient<MaterialSpecInspectGetPayload<T> | null, null>

    /**
     * Find one MaterialSpecInspect that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MaterialSpecInspectFindUniqueOrThrowArgs} args - Arguments to find a MaterialSpecInspect
     * @example
     * // Get one MaterialSpecInspect
     * const materialSpecInspect = await prisma.materialSpecInspect.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MaterialSpecInspectFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, MaterialSpecInspectFindUniqueOrThrowArgs>
    ): Prisma__MaterialSpecInspectClient<MaterialSpecInspectGetPayload<T>>

    /**
     * Find the first MaterialSpecInspect that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialSpecInspectFindFirstArgs} args - Arguments to find a MaterialSpecInspect
     * @example
     * // Get one MaterialSpecInspect
     * const materialSpecInspect = await prisma.materialSpecInspect.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MaterialSpecInspectFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MaterialSpecInspectFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'MaterialSpecInspect'> extends True ? Prisma__MaterialSpecInspectClient<MaterialSpecInspectGetPayload<T>> : Prisma__MaterialSpecInspectClient<MaterialSpecInspectGetPayload<T> | null, null>

    /**
     * Find the first MaterialSpecInspect that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialSpecInspectFindFirstOrThrowArgs} args - Arguments to find a MaterialSpecInspect
     * @example
     * // Get one MaterialSpecInspect
     * const materialSpecInspect = await prisma.materialSpecInspect.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MaterialSpecInspectFindFirstOrThrowArgs>(
      args?: SelectSubset<T, MaterialSpecInspectFindFirstOrThrowArgs>
    ): Prisma__MaterialSpecInspectClient<MaterialSpecInspectGetPayload<T>>

    /**
     * Find zero or more MaterialSpecInspects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialSpecInspectFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MaterialSpecInspects
     * const materialSpecInspects = await prisma.materialSpecInspect.findMany()
     * 
     * // Get first 10 MaterialSpecInspects
     * const materialSpecInspects = await prisma.materialSpecInspect.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const materialSpecInspectWithIdOnly = await prisma.materialSpecInspect.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MaterialSpecInspectFindManyArgs>(
      args?: SelectSubset<T, MaterialSpecInspectFindManyArgs>
    ): Prisma.PrismaPromise<Array<MaterialSpecInspectGetPayload<T>>>

    /**
     * Create a MaterialSpecInspect.
     * @param {MaterialSpecInspectCreateArgs} args - Arguments to create a MaterialSpecInspect.
     * @example
     * // Create one MaterialSpecInspect
     * const MaterialSpecInspect = await prisma.materialSpecInspect.create({
     *   data: {
     *     // ... data to create a MaterialSpecInspect
     *   }
     * })
     * 
    **/
    create<T extends MaterialSpecInspectCreateArgs>(
      args: SelectSubset<T, MaterialSpecInspectCreateArgs>
    ): Prisma__MaterialSpecInspectClient<MaterialSpecInspectGetPayload<T>>

    /**
     * Create many MaterialSpecInspects.
     *     @param {MaterialSpecInspectCreateManyArgs} args - Arguments to create many MaterialSpecInspects.
     *     @example
     *     // Create many MaterialSpecInspects
     *     const materialSpecInspect = await prisma.materialSpecInspect.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MaterialSpecInspectCreateManyArgs>(
      args?: SelectSubset<T, MaterialSpecInspectCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MaterialSpecInspect.
     * @param {MaterialSpecInspectDeleteArgs} args - Arguments to delete one MaterialSpecInspect.
     * @example
     * // Delete one MaterialSpecInspect
     * const MaterialSpecInspect = await prisma.materialSpecInspect.delete({
     *   where: {
     *     // ... filter to delete one MaterialSpecInspect
     *   }
     * })
     * 
    **/
    delete<T extends MaterialSpecInspectDeleteArgs>(
      args: SelectSubset<T, MaterialSpecInspectDeleteArgs>
    ): Prisma__MaterialSpecInspectClient<MaterialSpecInspectGetPayload<T>>

    /**
     * Update one MaterialSpecInspect.
     * @param {MaterialSpecInspectUpdateArgs} args - Arguments to update one MaterialSpecInspect.
     * @example
     * // Update one MaterialSpecInspect
     * const materialSpecInspect = await prisma.materialSpecInspect.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MaterialSpecInspectUpdateArgs>(
      args: SelectSubset<T, MaterialSpecInspectUpdateArgs>
    ): Prisma__MaterialSpecInspectClient<MaterialSpecInspectGetPayload<T>>

    /**
     * Delete zero or more MaterialSpecInspects.
     * @param {MaterialSpecInspectDeleteManyArgs} args - Arguments to filter MaterialSpecInspects to delete.
     * @example
     * // Delete a few MaterialSpecInspects
     * const { count } = await prisma.materialSpecInspect.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MaterialSpecInspectDeleteManyArgs>(
      args?: SelectSubset<T, MaterialSpecInspectDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MaterialSpecInspects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialSpecInspectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MaterialSpecInspects
     * const materialSpecInspect = await prisma.materialSpecInspect.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MaterialSpecInspectUpdateManyArgs>(
      args: SelectSubset<T, MaterialSpecInspectUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MaterialSpecInspect.
     * @param {MaterialSpecInspectUpsertArgs} args - Arguments to update or create a MaterialSpecInspect.
     * @example
     * // Update or create a MaterialSpecInspect
     * const materialSpecInspect = await prisma.materialSpecInspect.upsert({
     *   create: {
     *     // ... data to create a MaterialSpecInspect
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MaterialSpecInspect we want to update
     *   }
     * })
    **/
    upsert<T extends MaterialSpecInspectUpsertArgs>(
      args: SelectSubset<T, MaterialSpecInspectUpsertArgs>
    ): Prisma__MaterialSpecInspectClient<MaterialSpecInspectGetPayload<T>>

    /**
     * Count the number of MaterialSpecInspects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialSpecInspectCountArgs} args - Arguments to filter MaterialSpecInspects to count.
     * @example
     * // Count the number of MaterialSpecInspects
     * const count = await prisma.materialSpecInspect.count({
     *   where: {
     *     // ... the filter for the MaterialSpecInspects we want to count
     *   }
     * })
    **/
    count<T extends MaterialSpecInspectCountArgs>(
      args?: Subset<T, MaterialSpecInspectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaterialSpecInspectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MaterialSpecInspect.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialSpecInspectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaterialSpecInspectAggregateArgs>(args: Subset<T, MaterialSpecInspectAggregateArgs>): Prisma.PrismaPromise<GetMaterialSpecInspectAggregateType<T>>

    /**
     * Group by MaterialSpecInspect.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialSpecInspectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaterialSpecInspectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaterialSpecInspectGroupByArgs['orderBy'] }
        : { orderBy?: MaterialSpecInspectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaterialSpecInspectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaterialSpecInspectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for MaterialSpecInspect.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MaterialSpecInspectClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    record<T extends IncomingInspectRecordArgs= {}>(args?: Subset<T, IncomingInspectRecordArgs>): Prisma__IncomingInspectRecordClient<IncomingInspectRecordGetPayload<T> | Null>;

    spec<T extends MaterialSpecArgs= {}>(args?: Subset<T, MaterialSpecArgs>): Prisma__MaterialSpecClient<MaterialSpecGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * MaterialSpecInspect base type for findUnique actions
   */
  export type MaterialSpecInspectFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the MaterialSpecInspect
     */
    select?: MaterialSpecInspectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MaterialSpecInspectInclude | null
    /**
     * Filter, which MaterialSpecInspect to fetch.
     */
    where: MaterialSpecInspectWhereUniqueInput
  }

  /**
   * MaterialSpecInspect findUnique
   */
  export interface MaterialSpecInspectFindUniqueArgs extends MaterialSpecInspectFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MaterialSpecInspect findUniqueOrThrow
   */
  export type MaterialSpecInspectFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the MaterialSpecInspect
     */
    select?: MaterialSpecInspectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MaterialSpecInspectInclude | null
    /**
     * Filter, which MaterialSpecInspect to fetch.
     */
    where: MaterialSpecInspectWhereUniqueInput
  }


  /**
   * MaterialSpecInspect base type for findFirst actions
   */
  export type MaterialSpecInspectFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the MaterialSpecInspect
     */
    select?: MaterialSpecInspectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MaterialSpecInspectInclude | null
    /**
     * Filter, which MaterialSpecInspect to fetch.
     */
    where?: MaterialSpecInspectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaterialSpecInspects to fetch.
     */
    orderBy?: Enumerable<MaterialSpecInspectOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaterialSpecInspects.
     */
    cursor?: MaterialSpecInspectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaterialSpecInspects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaterialSpecInspects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaterialSpecInspects.
     */
    distinct?: Enumerable<MaterialSpecInspectScalarFieldEnum>
  }

  /**
   * MaterialSpecInspect findFirst
   */
  export interface MaterialSpecInspectFindFirstArgs extends MaterialSpecInspectFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MaterialSpecInspect findFirstOrThrow
   */
  export type MaterialSpecInspectFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the MaterialSpecInspect
     */
    select?: MaterialSpecInspectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MaterialSpecInspectInclude | null
    /**
     * Filter, which MaterialSpecInspect to fetch.
     */
    where?: MaterialSpecInspectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaterialSpecInspects to fetch.
     */
    orderBy?: Enumerable<MaterialSpecInspectOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaterialSpecInspects.
     */
    cursor?: MaterialSpecInspectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaterialSpecInspects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaterialSpecInspects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaterialSpecInspects.
     */
    distinct?: Enumerable<MaterialSpecInspectScalarFieldEnum>
  }


  /**
   * MaterialSpecInspect findMany
   */
  export type MaterialSpecInspectFindManyArgs = {
    /**
     * Select specific fields to fetch from the MaterialSpecInspect
     */
    select?: MaterialSpecInspectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MaterialSpecInspectInclude | null
    /**
     * Filter, which MaterialSpecInspects to fetch.
     */
    where?: MaterialSpecInspectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaterialSpecInspects to fetch.
     */
    orderBy?: Enumerable<MaterialSpecInspectOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MaterialSpecInspects.
     */
    cursor?: MaterialSpecInspectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaterialSpecInspects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaterialSpecInspects.
     */
    skip?: number
    distinct?: Enumerable<MaterialSpecInspectScalarFieldEnum>
  }


  /**
   * MaterialSpecInspect create
   */
  export type MaterialSpecInspectCreateArgs = {
    /**
     * Select specific fields to fetch from the MaterialSpecInspect
     */
    select?: MaterialSpecInspectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MaterialSpecInspectInclude | null
    /**
     * The data needed to create a MaterialSpecInspect.
     */
    data: XOR<MaterialSpecInspectCreateInput, MaterialSpecInspectUncheckedCreateInput>
  }


  /**
   * MaterialSpecInspect createMany
   */
  export type MaterialSpecInspectCreateManyArgs = {
    /**
     * The data used to create many MaterialSpecInspects.
     */
    data: Enumerable<MaterialSpecInspectCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * MaterialSpecInspect update
   */
  export type MaterialSpecInspectUpdateArgs = {
    /**
     * Select specific fields to fetch from the MaterialSpecInspect
     */
    select?: MaterialSpecInspectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MaterialSpecInspectInclude | null
    /**
     * The data needed to update a MaterialSpecInspect.
     */
    data: XOR<MaterialSpecInspectUpdateInput, MaterialSpecInspectUncheckedUpdateInput>
    /**
     * Choose, which MaterialSpecInspect to update.
     */
    where: MaterialSpecInspectWhereUniqueInput
  }


  /**
   * MaterialSpecInspect updateMany
   */
  export type MaterialSpecInspectUpdateManyArgs = {
    /**
     * The data used to update MaterialSpecInspects.
     */
    data: XOR<MaterialSpecInspectUpdateManyMutationInput, MaterialSpecInspectUncheckedUpdateManyInput>
    /**
     * Filter which MaterialSpecInspects to update
     */
    where?: MaterialSpecInspectWhereInput
  }


  /**
   * MaterialSpecInspect upsert
   */
  export type MaterialSpecInspectUpsertArgs = {
    /**
     * Select specific fields to fetch from the MaterialSpecInspect
     */
    select?: MaterialSpecInspectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MaterialSpecInspectInclude | null
    /**
     * The filter to search for the MaterialSpecInspect to update in case it exists.
     */
    where: MaterialSpecInspectWhereUniqueInput
    /**
     * In case the MaterialSpecInspect found by the `where` argument doesn't exist, create a new MaterialSpecInspect with this data.
     */
    create: XOR<MaterialSpecInspectCreateInput, MaterialSpecInspectUncheckedCreateInput>
    /**
     * In case the MaterialSpecInspect was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MaterialSpecInspectUpdateInput, MaterialSpecInspectUncheckedUpdateInput>
  }


  /**
   * MaterialSpecInspect delete
   */
  export type MaterialSpecInspectDeleteArgs = {
    /**
     * Select specific fields to fetch from the MaterialSpecInspect
     */
    select?: MaterialSpecInspectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MaterialSpecInspectInclude | null
    /**
     * Filter which MaterialSpecInspect to delete.
     */
    where: MaterialSpecInspectWhereUniqueInput
  }


  /**
   * MaterialSpecInspect deleteMany
   */
  export type MaterialSpecInspectDeleteManyArgs = {
    /**
     * Filter which MaterialSpecInspects to delete
     */
    where?: MaterialSpecInspectWhereInput
  }


  /**
   * MaterialSpecInspect without action
   */
  export type MaterialSpecInspectArgs = {
    /**
     * Select specific fields to fetch from the MaterialSpecInspect
     */
    select?: MaterialSpecInspectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MaterialSpecInspectInclude | null
  }



  /**
   * Model InProcessInspectRecord
   */


  export type AggregateInProcessInspectRecord = {
    _count: InProcessInspectRecordCountAggregateOutputType | null
    _avg: InProcessInspectRecordAvgAggregateOutputType | null
    _sum: InProcessInspectRecordSumAggregateOutputType | null
    _min: InProcessInspectRecordMinAggregateOutputType | null
    _max: InProcessInspectRecordMaxAggregateOutputType | null
  }

  export type InProcessInspectRecordAvgAggregateOutputType = {
    id: number | null
    materialId: number | null
    inspectorId: number | null
    reviewerId: number | null
  }

  export type InProcessInspectRecordSumAggregateOutputType = {
    id: number | null
    materialId: number | null
    inspectorId: number | null
    reviewerId: number | null
  }

  export type InProcessInspectRecordMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    lot: string | null
    description: string | null
    materialId: number | null
    inspectorId: number | null
    reviewerId: number | null
  }

  export type InProcessInspectRecordMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    lot: string | null
    description: string | null
    materialId: number | null
    inspectorId: number | null
    reviewerId: number | null
  }

  export type InProcessInspectRecordCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    isDeleted: number
    lot: number
    description: number
    materialId: number
    inspectorId: number
    reviewerId: number
    _all: number
  }


  export type InProcessInspectRecordAvgAggregateInputType = {
    id?: true
    materialId?: true
    inspectorId?: true
    reviewerId?: true
  }

  export type InProcessInspectRecordSumAggregateInputType = {
    id?: true
    materialId?: true
    inspectorId?: true
    reviewerId?: true
  }

  export type InProcessInspectRecordMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    lot?: true
    description?: true
    materialId?: true
    inspectorId?: true
    reviewerId?: true
  }

  export type InProcessInspectRecordMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    lot?: true
    description?: true
    materialId?: true
    inspectorId?: true
    reviewerId?: true
  }

  export type InProcessInspectRecordCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    lot?: true
    description?: true
    materialId?: true
    inspectorId?: true
    reviewerId?: true
    _all?: true
  }

  export type InProcessInspectRecordAggregateArgs = {
    /**
     * Filter which InProcessInspectRecord to aggregate.
     */
    where?: InProcessInspectRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InProcessInspectRecords to fetch.
     */
    orderBy?: Enumerable<InProcessInspectRecordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InProcessInspectRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InProcessInspectRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InProcessInspectRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InProcessInspectRecords
    **/
    _count?: true | InProcessInspectRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InProcessInspectRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InProcessInspectRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InProcessInspectRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InProcessInspectRecordMaxAggregateInputType
  }

  export type GetInProcessInspectRecordAggregateType<T extends InProcessInspectRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateInProcessInspectRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInProcessInspectRecord[P]>
      : GetScalarType<T[P], AggregateInProcessInspectRecord[P]>
  }




  export type InProcessInspectRecordGroupByArgs = {
    where?: InProcessInspectRecordWhereInput
    orderBy?: Enumerable<InProcessInspectRecordOrderByWithAggregationInput>
    by: InProcessInspectRecordScalarFieldEnum[]
    having?: InProcessInspectRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InProcessInspectRecordCountAggregateInputType | true
    _avg?: InProcessInspectRecordAvgAggregateInputType
    _sum?: InProcessInspectRecordSumAggregateInputType
    _min?: InProcessInspectRecordMinAggregateInputType
    _max?: InProcessInspectRecordMaxAggregateInputType
  }


  export type InProcessInspectRecordGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    isDeleted: boolean
    lot: string
    description: string | null
    materialId: number
    inspectorId: number
    reviewerId: number
    _count: InProcessInspectRecordCountAggregateOutputType | null
    _avg: InProcessInspectRecordAvgAggregateOutputType | null
    _sum: InProcessInspectRecordSumAggregateOutputType | null
    _min: InProcessInspectRecordMinAggregateOutputType | null
    _max: InProcessInspectRecordMaxAggregateOutputType | null
  }

  type GetInProcessInspectRecordGroupByPayload<T extends InProcessInspectRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<InProcessInspectRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InProcessInspectRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InProcessInspectRecordGroupByOutputType[P]>
            : GetScalarType<T[P], InProcessInspectRecordGroupByOutputType[P]>
        }
      >
    >


  export type InProcessInspectRecordSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    lot?: boolean
    description?: boolean
    materialId?: boolean
    inspectorId?: boolean
    reviewerId?: boolean
    material?: boolean | MaterialArgs
    inspector?: boolean | UserArgs
    reviewer?: boolean | UserArgs
  }


  export type InProcessInspectRecordInclude = {
    material?: boolean | MaterialArgs
    inspector?: boolean | UserArgs
    reviewer?: boolean | UserArgs
  }

  export type InProcessInspectRecordGetPayload<S extends boolean | null | undefined | InProcessInspectRecordArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? InProcessInspectRecord :
    S extends undefined ? never :
    S extends { include: any } & (InProcessInspectRecordArgs | InProcessInspectRecordFindManyArgs)
    ? InProcessInspectRecord  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'material' ? MaterialGetPayload<S['include'][P]> :
        P extends 'inspector' ? UserGetPayload<S['include'][P]> | null :
        P extends 'reviewer' ? UserGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (InProcessInspectRecordArgs | InProcessInspectRecordFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'material' ? MaterialGetPayload<S['select'][P]> :
        P extends 'inspector' ? UserGetPayload<S['select'][P]> | null :
        P extends 'reviewer' ? UserGetPayload<S['select'][P]> | null :  P extends keyof InProcessInspectRecord ? InProcessInspectRecord[P] : never
  } 
      : InProcessInspectRecord


  type InProcessInspectRecordCountArgs = 
    Omit<InProcessInspectRecordFindManyArgs, 'select' | 'include'> & {
      select?: InProcessInspectRecordCountAggregateInputType | true
    }

  export interface InProcessInspectRecordDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one InProcessInspectRecord that matches the filter.
     * @param {InProcessInspectRecordFindUniqueArgs} args - Arguments to find a InProcessInspectRecord
     * @example
     * // Get one InProcessInspectRecord
     * const inProcessInspectRecord = await prisma.inProcessInspectRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends InProcessInspectRecordFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, InProcessInspectRecordFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'InProcessInspectRecord'> extends True ? Prisma__InProcessInspectRecordClient<InProcessInspectRecordGetPayload<T>> : Prisma__InProcessInspectRecordClient<InProcessInspectRecordGetPayload<T> | null, null>

    /**
     * Find one InProcessInspectRecord that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {InProcessInspectRecordFindUniqueOrThrowArgs} args - Arguments to find a InProcessInspectRecord
     * @example
     * // Get one InProcessInspectRecord
     * const inProcessInspectRecord = await prisma.inProcessInspectRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends InProcessInspectRecordFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, InProcessInspectRecordFindUniqueOrThrowArgs>
    ): Prisma__InProcessInspectRecordClient<InProcessInspectRecordGetPayload<T>>

    /**
     * Find the first InProcessInspectRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InProcessInspectRecordFindFirstArgs} args - Arguments to find a InProcessInspectRecord
     * @example
     * // Get one InProcessInspectRecord
     * const inProcessInspectRecord = await prisma.inProcessInspectRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends InProcessInspectRecordFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, InProcessInspectRecordFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'InProcessInspectRecord'> extends True ? Prisma__InProcessInspectRecordClient<InProcessInspectRecordGetPayload<T>> : Prisma__InProcessInspectRecordClient<InProcessInspectRecordGetPayload<T> | null, null>

    /**
     * Find the first InProcessInspectRecord that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InProcessInspectRecordFindFirstOrThrowArgs} args - Arguments to find a InProcessInspectRecord
     * @example
     * // Get one InProcessInspectRecord
     * const inProcessInspectRecord = await prisma.inProcessInspectRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends InProcessInspectRecordFindFirstOrThrowArgs>(
      args?: SelectSubset<T, InProcessInspectRecordFindFirstOrThrowArgs>
    ): Prisma__InProcessInspectRecordClient<InProcessInspectRecordGetPayload<T>>

    /**
     * Find zero or more InProcessInspectRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InProcessInspectRecordFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InProcessInspectRecords
     * const inProcessInspectRecords = await prisma.inProcessInspectRecord.findMany()
     * 
     * // Get first 10 InProcessInspectRecords
     * const inProcessInspectRecords = await prisma.inProcessInspectRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inProcessInspectRecordWithIdOnly = await prisma.inProcessInspectRecord.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends InProcessInspectRecordFindManyArgs>(
      args?: SelectSubset<T, InProcessInspectRecordFindManyArgs>
    ): Prisma.PrismaPromise<Array<InProcessInspectRecordGetPayload<T>>>

    /**
     * Create a InProcessInspectRecord.
     * @param {InProcessInspectRecordCreateArgs} args - Arguments to create a InProcessInspectRecord.
     * @example
     * // Create one InProcessInspectRecord
     * const InProcessInspectRecord = await prisma.inProcessInspectRecord.create({
     *   data: {
     *     // ... data to create a InProcessInspectRecord
     *   }
     * })
     * 
    **/
    create<T extends InProcessInspectRecordCreateArgs>(
      args: SelectSubset<T, InProcessInspectRecordCreateArgs>
    ): Prisma__InProcessInspectRecordClient<InProcessInspectRecordGetPayload<T>>

    /**
     * Create many InProcessInspectRecords.
     *     @param {InProcessInspectRecordCreateManyArgs} args - Arguments to create many InProcessInspectRecords.
     *     @example
     *     // Create many InProcessInspectRecords
     *     const inProcessInspectRecord = await prisma.inProcessInspectRecord.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends InProcessInspectRecordCreateManyArgs>(
      args?: SelectSubset<T, InProcessInspectRecordCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a InProcessInspectRecord.
     * @param {InProcessInspectRecordDeleteArgs} args - Arguments to delete one InProcessInspectRecord.
     * @example
     * // Delete one InProcessInspectRecord
     * const InProcessInspectRecord = await prisma.inProcessInspectRecord.delete({
     *   where: {
     *     // ... filter to delete one InProcessInspectRecord
     *   }
     * })
     * 
    **/
    delete<T extends InProcessInspectRecordDeleteArgs>(
      args: SelectSubset<T, InProcessInspectRecordDeleteArgs>
    ): Prisma__InProcessInspectRecordClient<InProcessInspectRecordGetPayload<T>>

    /**
     * Update one InProcessInspectRecord.
     * @param {InProcessInspectRecordUpdateArgs} args - Arguments to update one InProcessInspectRecord.
     * @example
     * // Update one InProcessInspectRecord
     * const inProcessInspectRecord = await prisma.inProcessInspectRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends InProcessInspectRecordUpdateArgs>(
      args: SelectSubset<T, InProcessInspectRecordUpdateArgs>
    ): Prisma__InProcessInspectRecordClient<InProcessInspectRecordGetPayload<T>>

    /**
     * Delete zero or more InProcessInspectRecords.
     * @param {InProcessInspectRecordDeleteManyArgs} args - Arguments to filter InProcessInspectRecords to delete.
     * @example
     * // Delete a few InProcessInspectRecords
     * const { count } = await prisma.inProcessInspectRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends InProcessInspectRecordDeleteManyArgs>(
      args?: SelectSubset<T, InProcessInspectRecordDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InProcessInspectRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InProcessInspectRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InProcessInspectRecords
     * const inProcessInspectRecord = await prisma.inProcessInspectRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends InProcessInspectRecordUpdateManyArgs>(
      args: SelectSubset<T, InProcessInspectRecordUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InProcessInspectRecord.
     * @param {InProcessInspectRecordUpsertArgs} args - Arguments to update or create a InProcessInspectRecord.
     * @example
     * // Update or create a InProcessInspectRecord
     * const inProcessInspectRecord = await prisma.inProcessInspectRecord.upsert({
     *   create: {
     *     // ... data to create a InProcessInspectRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InProcessInspectRecord we want to update
     *   }
     * })
    **/
    upsert<T extends InProcessInspectRecordUpsertArgs>(
      args: SelectSubset<T, InProcessInspectRecordUpsertArgs>
    ): Prisma__InProcessInspectRecordClient<InProcessInspectRecordGetPayload<T>>

    /**
     * Count the number of InProcessInspectRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InProcessInspectRecordCountArgs} args - Arguments to filter InProcessInspectRecords to count.
     * @example
     * // Count the number of InProcessInspectRecords
     * const count = await prisma.inProcessInspectRecord.count({
     *   where: {
     *     // ... the filter for the InProcessInspectRecords we want to count
     *   }
     * })
    **/
    count<T extends InProcessInspectRecordCountArgs>(
      args?: Subset<T, InProcessInspectRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InProcessInspectRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InProcessInspectRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InProcessInspectRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InProcessInspectRecordAggregateArgs>(args: Subset<T, InProcessInspectRecordAggregateArgs>): Prisma.PrismaPromise<GetInProcessInspectRecordAggregateType<T>>

    /**
     * Group by InProcessInspectRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InProcessInspectRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InProcessInspectRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InProcessInspectRecordGroupByArgs['orderBy'] }
        : { orderBy?: InProcessInspectRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InProcessInspectRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInProcessInspectRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for InProcessInspectRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__InProcessInspectRecordClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    material<T extends MaterialArgs= {}>(args?: Subset<T, MaterialArgs>): Prisma__MaterialClient<MaterialGetPayload<T> | Null>;

    inspector<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    reviewer<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * InProcessInspectRecord base type for findUnique actions
   */
  export type InProcessInspectRecordFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the InProcessInspectRecord
     */
    select?: InProcessInspectRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InProcessInspectRecordInclude | null
    /**
     * Filter, which InProcessInspectRecord to fetch.
     */
    where: InProcessInspectRecordWhereUniqueInput
  }

  /**
   * InProcessInspectRecord findUnique
   */
  export interface InProcessInspectRecordFindUniqueArgs extends InProcessInspectRecordFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * InProcessInspectRecord findUniqueOrThrow
   */
  export type InProcessInspectRecordFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the InProcessInspectRecord
     */
    select?: InProcessInspectRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InProcessInspectRecordInclude | null
    /**
     * Filter, which InProcessInspectRecord to fetch.
     */
    where: InProcessInspectRecordWhereUniqueInput
  }


  /**
   * InProcessInspectRecord base type for findFirst actions
   */
  export type InProcessInspectRecordFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the InProcessInspectRecord
     */
    select?: InProcessInspectRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InProcessInspectRecordInclude | null
    /**
     * Filter, which InProcessInspectRecord to fetch.
     */
    where?: InProcessInspectRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InProcessInspectRecords to fetch.
     */
    orderBy?: Enumerable<InProcessInspectRecordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InProcessInspectRecords.
     */
    cursor?: InProcessInspectRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InProcessInspectRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InProcessInspectRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InProcessInspectRecords.
     */
    distinct?: Enumerable<InProcessInspectRecordScalarFieldEnum>
  }

  /**
   * InProcessInspectRecord findFirst
   */
  export interface InProcessInspectRecordFindFirstArgs extends InProcessInspectRecordFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * InProcessInspectRecord findFirstOrThrow
   */
  export type InProcessInspectRecordFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the InProcessInspectRecord
     */
    select?: InProcessInspectRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InProcessInspectRecordInclude | null
    /**
     * Filter, which InProcessInspectRecord to fetch.
     */
    where?: InProcessInspectRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InProcessInspectRecords to fetch.
     */
    orderBy?: Enumerable<InProcessInspectRecordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InProcessInspectRecords.
     */
    cursor?: InProcessInspectRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InProcessInspectRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InProcessInspectRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InProcessInspectRecords.
     */
    distinct?: Enumerable<InProcessInspectRecordScalarFieldEnum>
  }


  /**
   * InProcessInspectRecord findMany
   */
  export type InProcessInspectRecordFindManyArgs = {
    /**
     * Select specific fields to fetch from the InProcessInspectRecord
     */
    select?: InProcessInspectRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InProcessInspectRecordInclude | null
    /**
     * Filter, which InProcessInspectRecords to fetch.
     */
    where?: InProcessInspectRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InProcessInspectRecords to fetch.
     */
    orderBy?: Enumerable<InProcessInspectRecordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InProcessInspectRecords.
     */
    cursor?: InProcessInspectRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InProcessInspectRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InProcessInspectRecords.
     */
    skip?: number
    distinct?: Enumerable<InProcessInspectRecordScalarFieldEnum>
  }


  /**
   * InProcessInspectRecord create
   */
  export type InProcessInspectRecordCreateArgs = {
    /**
     * Select specific fields to fetch from the InProcessInspectRecord
     */
    select?: InProcessInspectRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InProcessInspectRecordInclude | null
    /**
     * The data needed to create a InProcessInspectRecord.
     */
    data: XOR<InProcessInspectRecordCreateInput, InProcessInspectRecordUncheckedCreateInput>
  }


  /**
   * InProcessInspectRecord createMany
   */
  export type InProcessInspectRecordCreateManyArgs = {
    /**
     * The data used to create many InProcessInspectRecords.
     */
    data: Enumerable<InProcessInspectRecordCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * InProcessInspectRecord update
   */
  export type InProcessInspectRecordUpdateArgs = {
    /**
     * Select specific fields to fetch from the InProcessInspectRecord
     */
    select?: InProcessInspectRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InProcessInspectRecordInclude | null
    /**
     * The data needed to update a InProcessInspectRecord.
     */
    data: XOR<InProcessInspectRecordUpdateInput, InProcessInspectRecordUncheckedUpdateInput>
    /**
     * Choose, which InProcessInspectRecord to update.
     */
    where: InProcessInspectRecordWhereUniqueInput
  }


  /**
   * InProcessInspectRecord updateMany
   */
  export type InProcessInspectRecordUpdateManyArgs = {
    /**
     * The data used to update InProcessInspectRecords.
     */
    data: XOR<InProcessInspectRecordUpdateManyMutationInput, InProcessInspectRecordUncheckedUpdateManyInput>
    /**
     * Filter which InProcessInspectRecords to update
     */
    where?: InProcessInspectRecordWhereInput
  }


  /**
   * InProcessInspectRecord upsert
   */
  export type InProcessInspectRecordUpsertArgs = {
    /**
     * Select specific fields to fetch from the InProcessInspectRecord
     */
    select?: InProcessInspectRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InProcessInspectRecordInclude | null
    /**
     * The filter to search for the InProcessInspectRecord to update in case it exists.
     */
    where: InProcessInspectRecordWhereUniqueInput
    /**
     * In case the InProcessInspectRecord found by the `where` argument doesn't exist, create a new InProcessInspectRecord with this data.
     */
    create: XOR<InProcessInspectRecordCreateInput, InProcessInspectRecordUncheckedCreateInput>
    /**
     * In case the InProcessInspectRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InProcessInspectRecordUpdateInput, InProcessInspectRecordUncheckedUpdateInput>
  }


  /**
   * InProcessInspectRecord delete
   */
  export type InProcessInspectRecordDeleteArgs = {
    /**
     * Select specific fields to fetch from the InProcessInspectRecord
     */
    select?: InProcessInspectRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InProcessInspectRecordInclude | null
    /**
     * Filter which InProcessInspectRecord to delete.
     */
    where: InProcessInspectRecordWhereUniqueInput
  }


  /**
   * InProcessInspectRecord deleteMany
   */
  export type InProcessInspectRecordDeleteManyArgs = {
    /**
     * Filter which InProcessInspectRecords to delete
     */
    where?: InProcessInspectRecordWhereInput
  }


  /**
   * InProcessInspectRecord without action
   */
  export type InProcessInspectRecordArgs = {
    /**
     * Select specific fields to fetch from the InProcessInspectRecord
     */
    select?: InProcessInspectRecordSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InProcessInspectRecordInclude | null
  }



  /**
   * Model OperationSpecInspect
   */


  export type AggregateOperationSpecInspect = {
    _count: OperationSpecInspectCountAggregateOutputType | null
    _avg: OperationSpecInspectAvgAggregateOutputType | null
    _sum: OperationSpecInspectSumAggregateOutputType | null
    _min: OperationSpecInspectMinAggregateOutputType | null
    _max: OperationSpecInspectMaxAggregateOutputType | null
  }

  export type OperationSpecInspectAvgAggregateOutputType = {
    id: number | null
    specId: number | null
  }

  export type OperationSpecInspectSumAggregateOutputType = {
    id: number | null
    specId: number | null
  }

  export type OperationSpecInspectMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    specId: number | null
    first: string | null
    inProcess: string | null
    final: string | null
  }

  export type OperationSpecInspectMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    specId: number | null
    first: string | null
    inProcess: string | null
    final: string | null
  }

  export type OperationSpecInspectCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    isDeleted: number
    specId: number
    first: number
    inProcess: number
    final: number
    _all: number
  }


  export type OperationSpecInspectAvgAggregateInputType = {
    id?: true
    specId?: true
  }

  export type OperationSpecInspectSumAggregateInputType = {
    id?: true
    specId?: true
  }

  export type OperationSpecInspectMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    specId?: true
    first?: true
    inProcess?: true
    final?: true
  }

  export type OperationSpecInspectMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    specId?: true
    first?: true
    inProcess?: true
    final?: true
  }

  export type OperationSpecInspectCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    specId?: true
    first?: true
    inProcess?: true
    final?: true
    _all?: true
  }

  export type OperationSpecInspectAggregateArgs = {
    /**
     * Filter which OperationSpecInspect to aggregate.
     */
    where?: OperationSpecInspectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperationSpecInspects to fetch.
     */
    orderBy?: Enumerable<OperationSpecInspectOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OperationSpecInspectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperationSpecInspects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperationSpecInspects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OperationSpecInspects
    **/
    _count?: true | OperationSpecInspectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OperationSpecInspectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OperationSpecInspectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OperationSpecInspectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OperationSpecInspectMaxAggregateInputType
  }

  export type GetOperationSpecInspectAggregateType<T extends OperationSpecInspectAggregateArgs> = {
        [P in keyof T & keyof AggregateOperationSpecInspect]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOperationSpecInspect[P]>
      : GetScalarType<T[P], AggregateOperationSpecInspect[P]>
  }




  export type OperationSpecInspectGroupByArgs = {
    where?: OperationSpecInspectWhereInput
    orderBy?: Enumerable<OperationSpecInspectOrderByWithAggregationInput>
    by: OperationSpecInspectScalarFieldEnum[]
    having?: OperationSpecInspectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OperationSpecInspectCountAggregateInputType | true
    _avg?: OperationSpecInspectAvgAggregateInputType
    _sum?: OperationSpecInspectSumAggregateInputType
    _min?: OperationSpecInspectMinAggregateInputType
    _max?: OperationSpecInspectMaxAggregateInputType
  }


  export type OperationSpecInspectGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    isDeleted: boolean
    specId: number
    first: string
    inProcess: string
    final: string
    _count: OperationSpecInspectCountAggregateOutputType | null
    _avg: OperationSpecInspectAvgAggregateOutputType | null
    _sum: OperationSpecInspectSumAggregateOutputType | null
    _min: OperationSpecInspectMinAggregateOutputType | null
    _max: OperationSpecInspectMaxAggregateOutputType | null
  }

  type GetOperationSpecInspectGroupByPayload<T extends OperationSpecInspectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<OperationSpecInspectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OperationSpecInspectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OperationSpecInspectGroupByOutputType[P]>
            : GetScalarType<T[P], OperationSpecInspectGroupByOutputType[P]>
        }
      >
    >


  export type OperationSpecInspectSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    specId?: boolean
    first?: boolean
    inProcess?: boolean
    final?: boolean
    spec?: boolean | OperationSpecArgs
  }


  export type OperationSpecInspectInclude = {
    spec?: boolean | OperationSpecArgs
  }

  export type OperationSpecInspectGetPayload<S extends boolean | null | undefined | OperationSpecInspectArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? OperationSpecInspect :
    S extends undefined ? never :
    S extends { include: any } & (OperationSpecInspectArgs | OperationSpecInspectFindManyArgs)
    ? OperationSpecInspect  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'spec' ? OperationSpecGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (OperationSpecInspectArgs | OperationSpecInspectFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'spec' ? OperationSpecGetPayload<S['select'][P]> :  P extends keyof OperationSpecInspect ? OperationSpecInspect[P] : never
  } 
      : OperationSpecInspect


  type OperationSpecInspectCountArgs = 
    Omit<OperationSpecInspectFindManyArgs, 'select' | 'include'> & {
      select?: OperationSpecInspectCountAggregateInputType | true
    }

  export interface OperationSpecInspectDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one OperationSpecInspect that matches the filter.
     * @param {OperationSpecInspectFindUniqueArgs} args - Arguments to find a OperationSpecInspect
     * @example
     * // Get one OperationSpecInspect
     * const operationSpecInspect = await prisma.operationSpecInspect.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OperationSpecInspectFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OperationSpecInspectFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'OperationSpecInspect'> extends True ? Prisma__OperationSpecInspectClient<OperationSpecInspectGetPayload<T>> : Prisma__OperationSpecInspectClient<OperationSpecInspectGetPayload<T> | null, null>

    /**
     * Find one OperationSpecInspect that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OperationSpecInspectFindUniqueOrThrowArgs} args - Arguments to find a OperationSpecInspect
     * @example
     * // Get one OperationSpecInspect
     * const operationSpecInspect = await prisma.operationSpecInspect.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OperationSpecInspectFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, OperationSpecInspectFindUniqueOrThrowArgs>
    ): Prisma__OperationSpecInspectClient<OperationSpecInspectGetPayload<T>>

    /**
     * Find the first OperationSpecInspect that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationSpecInspectFindFirstArgs} args - Arguments to find a OperationSpecInspect
     * @example
     * // Get one OperationSpecInspect
     * const operationSpecInspect = await prisma.operationSpecInspect.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OperationSpecInspectFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OperationSpecInspectFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'OperationSpecInspect'> extends True ? Prisma__OperationSpecInspectClient<OperationSpecInspectGetPayload<T>> : Prisma__OperationSpecInspectClient<OperationSpecInspectGetPayload<T> | null, null>

    /**
     * Find the first OperationSpecInspect that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationSpecInspectFindFirstOrThrowArgs} args - Arguments to find a OperationSpecInspect
     * @example
     * // Get one OperationSpecInspect
     * const operationSpecInspect = await prisma.operationSpecInspect.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OperationSpecInspectFindFirstOrThrowArgs>(
      args?: SelectSubset<T, OperationSpecInspectFindFirstOrThrowArgs>
    ): Prisma__OperationSpecInspectClient<OperationSpecInspectGetPayload<T>>

    /**
     * Find zero or more OperationSpecInspects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationSpecInspectFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OperationSpecInspects
     * const operationSpecInspects = await prisma.operationSpecInspect.findMany()
     * 
     * // Get first 10 OperationSpecInspects
     * const operationSpecInspects = await prisma.operationSpecInspect.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const operationSpecInspectWithIdOnly = await prisma.operationSpecInspect.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OperationSpecInspectFindManyArgs>(
      args?: SelectSubset<T, OperationSpecInspectFindManyArgs>
    ): Prisma.PrismaPromise<Array<OperationSpecInspectGetPayload<T>>>

    /**
     * Create a OperationSpecInspect.
     * @param {OperationSpecInspectCreateArgs} args - Arguments to create a OperationSpecInspect.
     * @example
     * // Create one OperationSpecInspect
     * const OperationSpecInspect = await prisma.operationSpecInspect.create({
     *   data: {
     *     // ... data to create a OperationSpecInspect
     *   }
     * })
     * 
    **/
    create<T extends OperationSpecInspectCreateArgs>(
      args: SelectSubset<T, OperationSpecInspectCreateArgs>
    ): Prisma__OperationSpecInspectClient<OperationSpecInspectGetPayload<T>>

    /**
     * Create many OperationSpecInspects.
     *     @param {OperationSpecInspectCreateManyArgs} args - Arguments to create many OperationSpecInspects.
     *     @example
     *     // Create many OperationSpecInspects
     *     const operationSpecInspect = await prisma.operationSpecInspect.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OperationSpecInspectCreateManyArgs>(
      args?: SelectSubset<T, OperationSpecInspectCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OperationSpecInspect.
     * @param {OperationSpecInspectDeleteArgs} args - Arguments to delete one OperationSpecInspect.
     * @example
     * // Delete one OperationSpecInspect
     * const OperationSpecInspect = await prisma.operationSpecInspect.delete({
     *   where: {
     *     // ... filter to delete one OperationSpecInspect
     *   }
     * })
     * 
    **/
    delete<T extends OperationSpecInspectDeleteArgs>(
      args: SelectSubset<T, OperationSpecInspectDeleteArgs>
    ): Prisma__OperationSpecInspectClient<OperationSpecInspectGetPayload<T>>

    /**
     * Update one OperationSpecInspect.
     * @param {OperationSpecInspectUpdateArgs} args - Arguments to update one OperationSpecInspect.
     * @example
     * // Update one OperationSpecInspect
     * const operationSpecInspect = await prisma.operationSpecInspect.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OperationSpecInspectUpdateArgs>(
      args: SelectSubset<T, OperationSpecInspectUpdateArgs>
    ): Prisma__OperationSpecInspectClient<OperationSpecInspectGetPayload<T>>

    /**
     * Delete zero or more OperationSpecInspects.
     * @param {OperationSpecInspectDeleteManyArgs} args - Arguments to filter OperationSpecInspects to delete.
     * @example
     * // Delete a few OperationSpecInspects
     * const { count } = await prisma.operationSpecInspect.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OperationSpecInspectDeleteManyArgs>(
      args?: SelectSubset<T, OperationSpecInspectDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OperationSpecInspects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationSpecInspectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OperationSpecInspects
     * const operationSpecInspect = await prisma.operationSpecInspect.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OperationSpecInspectUpdateManyArgs>(
      args: SelectSubset<T, OperationSpecInspectUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OperationSpecInspect.
     * @param {OperationSpecInspectUpsertArgs} args - Arguments to update or create a OperationSpecInspect.
     * @example
     * // Update or create a OperationSpecInspect
     * const operationSpecInspect = await prisma.operationSpecInspect.upsert({
     *   create: {
     *     // ... data to create a OperationSpecInspect
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OperationSpecInspect we want to update
     *   }
     * })
    **/
    upsert<T extends OperationSpecInspectUpsertArgs>(
      args: SelectSubset<T, OperationSpecInspectUpsertArgs>
    ): Prisma__OperationSpecInspectClient<OperationSpecInspectGetPayload<T>>

    /**
     * Count the number of OperationSpecInspects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationSpecInspectCountArgs} args - Arguments to filter OperationSpecInspects to count.
     * @example
     * // Count the number of OperationSpecInspects
     * const count = await prisma.operationSpecInspect.count({
     *   where: {
     *     // ... the filter for the OperationSpecInspects we want to count
     *   }
     * })
    **/
    count<T extends OperationSpecInspectCountArgs>(
      args?: Subset<T, OperationSpecInspectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OperationSpecInspectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OperationSpecInspect.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationSpecInspectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OperationSpecInspectAggregateArgs>(args: Subset<T, OperationSpecInspectAggregateArgs>): Prisma.PrismaPromise<GetOperationSpecInspectAggregateType<T>>

    /**
     * Group by OperationSpecInspect.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationSpecInspectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OperationSpecInspectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OperationSpecInspectGroupByArgs['orderBy'] }
        : { orderBy?: OperationSpecInspectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OperationSpecInspectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOperationSpecInspectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for OperationSpecInspect.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OperationSpecInspectClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    spec<T extends OperationSpecArgs= {}>(args?: Subset<T, OperationSpecArgs>): Prisma__OperationSpecClient<OperationSpecGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * OperationSpecInspect base type for findUnique actions
   */
  export type OperationSpecInspectFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the OperationSpecInspect
     */
    select?: OperationSpecInspectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OperationSpecInspectInclude | null
    /**
     * Filter, which OperationSpecInspect to fetch.
     */
    where: OperationSpecInspectWhereUniqueInput
  }

  /**
   * OperationSpecInspect findUnique
   */
  export interface OperationSpecInspectFindUniqueArgs extends OperationSpecInspectFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * OperationSpecInspect findUniqueOrThrow
   */
  export type OperationSpecInspectFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the OperationSpecInspect
     */
    select?: OperationSpecInspectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OperationSpecInspectInclude | null
    /**
     * Filter, which OperationSpecInspect to fetch.
     */
    where: OperationSpecInspectWhereUniqueInput
  }


  /**
   * OperationSpecInspect base type for findFirst actions
   */
  export type OperationSpecInspectFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the OperationSpecInspect
     */
    select?: OperationSpecInspectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OperationSpecInspectInclude | null
    /**
     * Filter, which OperationSpecInspect to fetch.
     */
    where?: OperationSpecInspectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperationSpecInspects to fetch.
     */
    orderBy?: Enumerable<OperationSpecInspectOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OperationSpecInspects.
     */
    cursor?: OperationSpecInspectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperationSpecInspects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperationSpecInspects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OperationSpecInspects.
     */
    distinct?: Enumerable<OperationSpecInspectScalarFieldEnum>
  }

  /**
   * OperationSpecInspect findFirst
   */
  export interface OperationSpecInspectFindFirstArgs extends OperationSpecInspectFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * OperationSpecInspect findFirstOrThrow
   */
  export type OperationSpecInspectFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the OperationSpecInspect
     */
    select?: OperationSpecInspectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OperationSpecInspectInclude | null
    /**
     * Filter, which OperationSpecInspect to fetch.
     */
    where?: OperationSpecInspectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperationSpecInspects to fetch.
     */
    orderBy?: Enumerable<OperationSpecInspectOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OperationSpecInspects.
     */
    cursor?: OperationSpecInspectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperationSpecInspects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperationSpecInspects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OperationSpecInspects.
     */
    distinct?: Enumerable<OperationSpecInspectScalarFieldEnum>
  }


  /**
   * OperationSpecInspect findMany
   */
  export type OperationSpecInspectFindManyArgs = {
    /**
     * Select specific fields to fetch from the OperationSpecInspect
     */
    select?: OperationSpecInspectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OperationSpecInspectInclude | null
    /**
     * Filter, which OperationSpecInspects to fetch.
     */
    where?: OperationSpecInspectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperationSpecInspects to fetch.
     */
    orderBy?: Enumerable<OperationSpecInspectOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OperationSpecInspects.
     */
    cursor?: OperationSpecInspectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperationSpecInspects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperationSpecInspects.
     */
    skip?: number
    distinct?: Enumerable<OperationSpecInspectScalarFieldEnum>
  }


  /**
   * OperationSpecInspect create
   */
  export type OperationSpecInspectCreateArgs = {
    /**
     * Select specific fields to fetch from the OperationSpecInspect
     */
    select?: OperationSpecInspectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OperationSpecInspectInclude | null
    /**
     * The data needed to create a OperationSpecInspect.
     */
    data: XOR<OperationSpecInspectCreateInput, OperationSpecInspectUncheckedCreateInput>
  }


  /**
   * OperationSpecInspect createMany
   */
  export type OperationSpecInspectCreateManyArgs = {
    /**
     * The data used to create many OperationSpecInspects.
     */
    data: Enumerable<OperationSpecInspectCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * OperationSpecInspect update
   */
  export type OperationSpecInspectUpdateArgs = {
    /**
     * Select specific fields to fetch from the OperationSpecInspect
     */
    select?: OperationSpecInspectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OperationSpecInspectInclude | null
    /**
     * The data needed to update a OperationSpecInspect.
     */
    data: XOR<OperationSpecInspectUpdateInput, OperationSpecInspectUncheckedUpdateInput>
    /**
     * Choose, which OperationSpecInspect to update.
     */
    where: OperationSpecInspectWhereUniqueInput
  }


  /**
   * OperationSpecInspect updateMany
   */
  export type OperationSpecInspectUpdateManyArgs = {
    /**
     * The data used to update OperationSpecInspects.
     */
    data: XOR<OperationSpecInspectUpdateManyMutationInput, OperationSpecInspectUncheckedUpdateManyInput>
    /**
     * Filter which OperationSpecInspects to update
     */
    where?: OperationSpecInspectWhereInput
  }


  /**
   * OperationSpecInspect upsert
   */
  export type OperationSpecInspectUpsertArgs = {
    /**
     * Select specific fields to fetch from the OperationSpecInspect
     */
    select?: OperationSpecInspectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OperationSpecInspectInclude | null
    /**
     * The filter to search for the OperationSpecInspect to update in case it exists.
     */
    where: OperationSpecInspectWhereUniqueInput
    /**
     * In case the OperationSpecInspect found by the `where` argument doesn't exist, create a new OperationSpecInspect with this data.
     */
    create: XOR<OperationSpecInspectCreateInput, OperationSpecInspectUncheckedCreateInput>
    /**
     * In case the OperationSpecInspect was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OperationSpecInspectUpdateInput, OperationSpecInspectUncheckedUpdateInput>
  }


  /**
   * OperationSpecInspect delete
   */
  export type OperationSpecInspectDeleteArgs = {
    /**
     * Select specific fields to fetch from the OperationSpecInspect
     */
    select?: OperationSpecInspectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OperationSpecInspectInclude | null
    /**
     * Filter which OperationSpecInspect to delete.
     */
    where: OperationSpecInspectWhereUniqueInput
  }


  /**
   * OperationSpecInspect deleteMany
   */
  export type OperationSpecInspectDeleteManyArgs = {
    /**
     * Filter which OperationSpecInspects to delete
     */
    where?: OperationSpecInspectWhereInput
  }


  /**
   * OperationSpecInspect without action
   */
  export type OperationSpecInspectArgs = {
    /**
     * Select specific fields to fetch from the OperationSpecInspect
     */
    select?: OperationSpecInspectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OperationSpecInspectInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const EquipmentScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isDeleted: 'isDeleted',
    name: 'name',
    description: 'description',
    purchaseDate: 'purchaseDate',
    productLineId: 'productLineId'
  };

  export type EquipmentScalarFieldEnum = (typeof EquipmentScalarFieldEnum)[keyof typeof EquipmentScalarFieldEnum]


  export const InProcessInspectRecordScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isDeleted: 'isDeleted',
    lot: 'lot',
    description: 'description',
    materialId: 'materialId',
    inspectorId: 'inspectorId',
    reviewerId: 'reviewerId'
  };

  export type InProcessInspectRecordScalarFieldEnum = (typeof InProcessInspectRecordScalarFieldEnum)[keyof typeof InProcessInspectRecordScalarFieldEnum]


  export const IncomingInspectRecordScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isDeleted: 'isDeleted',
    lot: 'lot',
    materialId: 'materialId',
    description: 'description',
    inspectorId: 'inspectorId',
    reviewerId: 'reviewerId',
    result: 'result'
  };

  export type IncomingInspectRecordScalarFieldEnum = (typeof IncomingInspectRecordScalarFieldEnum)[keyof typeof IncomingInspectRecordScalarFieldEnum]


  export const MaterialScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isDeleted: 'isDeleted',
    name: 'name',
    description: 'description'
  };

  export type MaterialScalarFieldEnum = (typeof MaterialScalarFieldEnum)[keyof typeof MaterialScalarFieldEnum]


  export const MaterialSpecInspectScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isDeleted: 'isDeleted',
    recordId: 'recordId',
    specId: 'specId',
    description: 'description',
    result: 'result'
  };

  export type MaterialSpecInspectScalarFieldEnum = (typeof MaterialSpecInspectScalarFieldEnum)[keyof typeof MaterialSpecInspectScalarFieldEnum]


  export const MaterialSpecScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isDeleted: 'isDeleted',
    name: 'name',
    description: 'description',
    materialId: 'materialId'
  };

  export type MaterialSpecScalarFieldEnum = (typeof MaterialSpecScalarFieldEnum)[keyof typeof MaterialSpecScalarFieldEnum]


  export const OperationScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isDeleted: 'isDeleted',
    name: 'name',
    description: 'description',
    materialId: 'materialId'
  };

  export type OperationScalarFieldEnum = (typeof OperationScalarFieldEnum)[keyof typeof OperationScalarFieldEnum]


  export const OperationSpecInspectScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isDeleted: 'isDeleted',
    specId: 'specId',
    first: 'first',
    inProcess: 'inProcess',
    final: 'final'
  };

  export type OperationSpecInspectScalarFieldEnum = (typeof OperationSpecInspectScalarFieldEnum)[keyof typeof OperationSpecInspectScalarFieldEnum]


  export const OperationSpecScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isDeleted: 'isDeleted',
    name: 'name',
    description: 'description',
    operationId: 'operationId'
  };

  export type OperationSpecScalarFieldEnum = (typeof OperationSpecScalarFieldEnum)[keyof typeof OperationSpecScalarFieldEnum]


  export const ProductLineScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isDeleted: 'isDeleted',
    name: 'name',
    description: 'description'
  };

  export type ProductLineScalarFieldEnum = (typeof ProductLineScalarFieldEnum)[keyof typeof ProductLineScalarFieldEnum]


  export const RepairMaterialInventoryScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isDeleted: 'isDeleted',
    materialId: 'materialId',
    quantity: 'quantity'
  };

  export type RepairMaterialInventoryScalarFieldEnum = (typeof RepairMaterialInventoryScalarFieldEnum)[keyof typeof RepairMaterialInventoryScalarFieldEnum]


  export const RepairMaterialScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isDeleted: 'isDeleted',
    name: 'name',
    description: 'description'
  };

  export type RepairMaterialScalarFieldEnum = (typeof RepairMaterialScalarFieldEnum)[keyof typeof RepairMaterialScalarFieldEnum]


  export const RepairPlanScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isDeleted: 'isDeleted',
    description: 'description',
    equimentId: 'equimentId'
  };

  export type RepairPlanScalarFieldEnum = (typeof RepairPlanScalarFieldEnum)[keyof typeof RepairPlanScalarFieldEnum]


  export const RepairRecordScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isDeleted: 'isDeleted',
    equimentId: 'equimentId',
    description: 'description',
    status: 'status',
    type: 'type'
  };

  export type RepairRecordScalarFieldEnum = (typeof RepairRecordScalarFieldEnum)[keyof typeof RepairRecordScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const TaskFormRelationScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isDeleted: 'isDeleted',
    taskDefinitionKey: 'taskDefinitionKey',
    formKey: 'formKey'
  };

  export type TaskFormRelationScalarFieldEnum = (typeof TaskFormRelationScalarFieldEnum)[keyof typeof TaskFormRelationScalarFieldEnum]


  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserProfileScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isDeleted: 'isDeleted',
    userId: 'userId',
    fullName: 'fullName'
  };

  export type UserProfileScalarFieldEnum = (typeof UserProfileScalarFieldEnum)[keyof typeof UserProfileScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isDeleted: 'isDeleted',
    username: 'username',
    hashedPassword: 'hashedPassword',
    hashedRefreshToken: 'hashedRefreshToken',
    status: 'status',
    role: 'role'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  /**
   * Deep Input Types
   */


  export type TaskFormRelationWhereInput = {
    AND?: Enumerable<TaskFormRelationWhereInput>
    OR?: Enumerable<TaskFormRelationWhereInput>
    NOT?: Enumerable<TaskFormRelationWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    taskDefinitionKey?: StringFilter | string
    formKey?: StringFilter | string
  }

  export type TaskFormRelationOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    taskDefinitionKey?: SortOrder
    formKey?: SortOrder
  }

  export type TaskFormRelationWhereUniqueInput = {
    id?: number
    taskDefinitionKey?: string
  }

  export type TaskFormRelationOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    taskDefinitionKey?: SortOrder
    formKey?: SortOrder
    _count?: TaskFormRelationCountOrderByAggregateInput
    _avg?: TaskFormRelationAvgOrderByAggregateInput
    _max?: TaskFormRelationMaxOrderByAggregateInput
    _min?: TaskFormRelationMinOrderByAggregateInput
    _sum?: TaskFormRelationSumOrderByAggregateInput
  }

  export type TaskFormRelationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TaskFormRelationScalarWhereWithAggregatesInput>
    OR?: Enumerable<TaskFormRelationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TaskFormRelationScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    isDeleted?: BoolWithAggregatesFilter | boolean
    taskDefinitionKey?: StringWithAggregatesFilter | string
    formKey?: StringWithAggregatesFilter | string
  }

  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    username?: StringFilter | string
    hashedPassword?: StringNullableFilter | string | null
    hashedRefreshToken?: StringNullableFilter | string | null
    status?: EnumUserStatusFilter | UserStatus
    role?: EnumUserGroupFilter | UserGroup
    profile?: XOR<UserProfileRelationFilter, UserProfileWhereInput> | null
    incomingInspectedRecords?: IncomingInspectRecordListRelationFilter
    incomingReviewedRecords?: IncomingInspectRecordListRelationFilter
    inProcessInspectedRecord?: InProcessInspectRecordListRelationFilter
    inProcessReviewedRecord?: InProcessInspectRecordListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    username?: SortOrder
    hashedPassword?: SortOrder
    hashedRefreshToken?: SortOrder
    status?: SortOrder
    role?: SortOrder
    profile?: UserProfileOrderByWithRelationInput
    incomingInspectedRecords?: IncomingInspectRecordOrderByRelationAggregateInput
    incomingReviewedRecords?: IncomingInspectRecordOrderByRelationAggregateInput
    inProcessInspectedRecord?: InProcessInspectRecordOrderByRelationAggregateInput
    inProcessReviewedRecord?: InProcessInspectRecordOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = {
    id?: number
  }

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    username?: SortOrder
    hashedPassword?: SortOrder
    hashedRefreshToken?: SortOrder
    status?: SortOrder
    role?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    isDeleted?: BoolWithAggregatesFilter | boolean
    username?: StringWithAggregatesFilter | string
    hashedPassword?: StringNullableWithAggregatesFilter | string | null
    hashedRefreshToken?: StringNullableWithAggregatesFilter | string | null
    status?: EnumUserStatusWithAggregatesFilter | UserStatus
    role?: EnumUserGroupWithAggregatesFilter | UserGroup
  }

  export type UserProfileWhereInput = {
    AND?: Enumerable<UserProfileWhereInput>
    OR?: Enumerable<UserProfileWhereInput>
    NOT?: Enumerable<UserProfileWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    userId?: IntFilter | number
    fullName?: StringFilter | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserProfileOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    userId?: SortOrder
    fullName?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserProfileWhereUniqueInput = {
    id?: number
    userId?: number
  }

  export type UserProfileOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    userId?: SortOrder
    fullName?: SortOrder
    _count?: UserProfileCountOrderByAggregateInput
    _avg?: UserProfileAvgOrderByAggregateInput
    _max?: UserProfileMaxOrderByAggregateInput
    _min?: UserProfileMinOrderByAggregateInput
    _sum?: UserProfileSumOrderByAggregateInput
  }

  export type UserProfileScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserProfileScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserProfileScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserProfileScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    isDeleted?: BoolWithAggregatesFilter | boolean
    userId?: IntWithAggregatesFilter | number
    fullName?: StringWithAggregatesFilter | string
  }

  export type ProductLineWhereInput = {
    AND?: Enumerable<ProductLineWhereInput>
    OR?: Enumerable<ProductLineWhereInput>
    NOT?: Enumerable<ProductLineWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    name?: StringFilter | string
    description?: StringNullableFilter | string | null
    equipment?: EquipmentListRelationFilter
  }

  export type ProductLineOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
    description?: SortOrder
    equipment?: EquipmentOrderByRelationAggregateInput
  }

  export type ProductLineWhereUniqueInput = {
    id?: number
  }

  export type ProductLineOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
    description?: SortOrder
    _count?: ProductLineCountOrderByAggregateInput
    _avg?: ProductLineAvgOrderByAggregateInput
    _max?: ProductLineMaxOrderByAggregateInput
    _min?: ProductLineMinOrderByAggregateInput
    _sum?: ProductLineSumOrderByAggregateInput
  }

  export type ProductLineScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProductLineScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProductLineScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProductLineScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    isDeleted?: BoolWithAggregatesFilter | boolean
    name?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
  }

  export type EquipmentWhereInput = {
    AND?: Enumerable<EquipmentWhereInput>
    OR?: Enumerable<EquipmentWhereInput>
    NOT?: Enumerable<EquipmentWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    name?: StringFilter | string
    description?: StringNullableFilter | string | null
    purchaseDate?: DateTimeFilter | Date | string
    productLineId?: IntNullableFilter | number | null
    plan?: XOR<RepairPlanRelationFilter, RepairPlanWhereInput> | null
    records?: RepairRecordListRelationFilter
    productLine?: XOR<ProductLineRelationFilter, ProductLineWhereInput> | null
  }

  export type EquipmentOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
    description?: SortOrder
    purchaseDate?: SortOrder
    productLineId?: SortOrder
    plan?: RepairPlanOrderByWithRelationInput
    records?: RepairRecordOrderByRelationAggregateInput
    productLine?: ProductLineOrderByWithRelationInput
  }

  export type EquipmentWhereUniqueInput = {
    id?: number
  }

  export type EquipmentOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
    description?: SortOrder
    purchaseDate?: SortOrder
    productLineId?: SortOrder
    _count?: EquipmentCountOrderByAggregateInput
    _avg?: EquipmentAvgOrderByAggregateInput
    _max?: EquipmentMaxOrderByAggregateInput
    _min?: EquipmentMinOrderByAggregateInput
    _sum?: EquipmentSumOrderByAggregateInput
  }

  export type EquipmentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<EquipmentScalarWhereWithAggregatesInput>
    OR?: Enumerable<EquipmentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<EquipmentScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    isDeleted?: BoolWithAggregatesFilter | boolean
    name?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
    purchaseDate?: DateTimeWithAggregatesFilter | Date | string
    productLineId?: IntNullableWithAggregatesFilter | number | null
  }

  export type RepairMaterialWhereInput = {
    AND?: Enumerable<RepairMaterialWhereInput>
    OR?: Enumerable<RepairMaterialWhereInput>
    NOT?: Enumerable<RepairMaterialWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    name?: StringFilter | string
    description?: StringNullableFilter | string | null
    inventory?: XOR<RepairMaterialInventoryRelationFilter, RepairMaterialInventoryWhereInput> | null
  }

  export type RepairMaterialOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
    description?: SortOrder
    inventory?: RepairMaterialInventoryOrderByWithRelationInput
  }

  export type RepairMaterialWhereUniqueInput = {
    id?: number
  }

  export type RepairMaterialOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
    description?: SortOrder
    _count?: RepairMaterialCountOrderByAggregateInput
    _avg?: RepairMaterialAvgOrderByAggregateInput
    _max?: RepairMaterialMaxOrderByAggregateInput
    _min?: RepairMaterialMinOrderByAggregateInput
    _sum?: RepairMaterialSumOrderByAggregateInput
  }

  export type RepairMaterialScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RepairMaterialScalarWhereWithAggregatesInput>
    OR?: Enumerable<RepairMaterialScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RepairMaterialScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    isDeleted?: BoolWithAggregatesFilter | boolean
    name?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
  }

  export type RepairPlanWhereInput = {
    AND?: Enumerable<RepairPlanWhereInput>
    OR?: Enumerable<RepairPlanWhereInput>
    NOT?: Enumerable<RepairPlanWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    description?: StringNullableFilter | string | null
    equimentId?: IntFilter | number
    equipment?: XOR<EquipmentRelationFilter, EquipmentWhereInput>
  }

  export type RepairPlanOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    description?: SortOrder
    equimentId?: SortOrder
    equipment?: EquipmentOrderByWithRelationInput
  }

  export type RepairPlanWhereUniqueInput = {
    id?: number
    equimentId?: number
  }

  export type RepairPlanOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    description?: SortOrder
    equimentId?: SortOrder
    _count?: RepairPlanCountOrderByAggregateInput
    _avg?: RepairPlanAvgOrderByAggregateInput
    _max?: RepairPlanMaxOrderByAggregateInput
    _min?: RepairPlanMinOrderByAggregateInput
    _sum?: RepairPlanSumOrderByAggregateInput
  }

  export type RepairPlanScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RepairPlanScalarWhereWithAggregatesInput>
    OR?: Enumerable<RepairPlanScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RepairPlanScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    isDeleted?: BoolWithAggregatesFilter | boolean
    description?: StringNullableWithAggregatesFilter | string | null
    equimentId?: IntWithAggregatesFilter | number
  }

  export type RepairMaterialInventoryWhereInput = {
    AND?: Enumerable<RepairMaterialInventoryWhereInput>
    OR?: Enumerable<RepairMaterialInventoryWhereInput>
    NOT?: Enumerable<RepairMaterialInventoryWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    materialId?: IntFilter | number
    quantity?: IntFilter | number
    repairMaterial?: XOR<RepairMaterialRelationFilter, RepairMaterialWhereInput>
  }

  export type RepairMaterialInventoryOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    materialId?: SortOrder
    quantity?: SortOrder
    repairMaterial?: RepairMaterialOrderByWithRelationInput
  }

  export type RepairMaterialInventoryWhereUniqueInput = {
    id?: number
    materialId?: number
  }

  export type RepairMaterialInventoryOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    materialId?: SortOrder
    quantity?: SortOrder
    _count?: RepairMaterialInventoryCountOrderByAggregateInput
    _avg?: RepairMaterialInventoryAvgOrderByAggregateInput
    _max?: RepairMaterialInventoryMaxOrderByAggregateInput
    _min?: RepairMaterialInventoryMinOrderByAggregateInput
    _sum?: RepairMaterialInventorySumOrderByAggregateInput
  }

  export type RepairMaterialInventoryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RepairMaterialInventoryScalarWhereWithAggregatesInput>
    OR?: Enumerable<RepairMaterialInventoryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RepairMaterialInventoryScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    isDeleted?: BoolWithAggregatesFilter | boolean
    materialId?: IntWithAggregatesFilter | number
    quantity?: IntWithAggregatesFilter | number
  }

  export type RepairRecordWhereInput = {
    AND?: Enumerable<RepairRecordWhereInput>
    OR?: Enumerable<RepairRecordWhereInput>
    NOT?: Enumerable<RepairRecordWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    equimentId?: IntFilter | number
    description?: StringNullableFilter | string | null
    status?: EnumRepairRecordStatusNullableFilter | RepairRecordStatus | null
    type?: EnumRepairTypeFilter | RepairType
    equipment?: XOR<EquipmentRelationFilter, EquipmentWhereInput>
  }

  export type RepairRecordOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    equimentId?: SortOrder
    description?: SortOrder
    status?: SortOrder
    type?: SortOrder
    equipment?: EquipmentOrderByWithRelationInput
  }

  export type RepairRecordWhereUniqueInput = {
    id?: number
  }

  export type RepairRecordOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    equimentId?: SortOrder
    description?: SortOrder
    status?: SortOrder
    type?: SortOrder
    _count?: RepairRecordCountOrderByAggregateInput
    _avg?: RepairRecordAvgOrderByAggregateInput
    _max?: RepairRecordMaxOrderByAggregateInput
    _min?: RepairRecordMinOrderByAggregateInput
    _sum?: RepairRecordSumOrderByAggregateInput
  }

  export type RepairRecordScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RepairRecordScalarWhereWithAggregatesInput>
    OR?: Enumerable<RepairRecordScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RepairRecordScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    isDeleted?: BoolWithAggregatesFilter | boolean
    equimentId?: IntWithAggregatesFilter | number
    description?: StringNullableWithAggregatesFilter | string | null
    status?: EnumRepairRecordStatusNullableWithAggregatesFilter | RepairRecordStatus | null
    type?: EnumRepairTypeWithAggregatesFilter | RepairType
  }

  export type MaterialWhereInput = {
    AND?: Enumerable<MaterialWhereInput>
    OR?: Enumerable<MaterialWhereInput>
    NOT?: Enumerable<MaterialWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    name?: StringFilter | string
    description?: StringNullableFilter | string | null
    specs?: MaterialSpecListRelationFilter
    operations?: OperationListRelationFilter
    incomingInspectRecord?: IncomingInspectRecordListRelationFilter
    inProcessInspectRecord?: InProcessInspectRecordListRelationFilter
  }

  export type MaterialOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
    description?: SortOrder
    specs?: MaterialSpecOrderByRelationAggregateInput
    operations?: OperationOrderByRelationAggregateInput
    incomingInspectRecord?: IncomingInspectRecordOrderByRelationAggregateInput
    inProcessInspectRecord?: InProcessInspectRecordOrderByRelationAggregateInput
  }

  export type MaterialWhereUniqueInput = {
    id?: number
  }

  export type MaterialOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
    description?: SortOrder
    _count?: MaterialCountOrderByAggregateInput
    _avg?: MaterialAvgOrderByAggregateInput
    _max?: MaterialMaxOrderByAggregateInput
    _min?: MaterialMinOrderByAggregateInput
    _sum?: MaterialSumOrderByAggregateInput
  }

  export type MaterialScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MaterialScalarWhereWithAggregatesInput>
    OR?: Enumerable<MaterialScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MaterialScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    isDeleted?: BoolWithAggregatesFilter | boolean
    name?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
  }

  export type MaterialSpecWhereInput = {
    AND?: Enumerable<MaterialSpecWhereInput>
    OR?: Enumerable<MaterialSpecWhereInput>
    NOT?: Enumerable<MaterialSpecWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    name?: StringFilter | string
    description?: StringNullableFilter | string | null
    materialId?: IntFilter | number
    material?: XOR<MaterialRelationFilter, MaterialWhereInput>
    inspects?: MaterialSpecInspectListRelationFilter
  }

  export type MaterialSpecOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
    description?: SortOrder
    materialId?: SortOrder
    material?: MaterialOrderByWithRelationInput
    inspects?: MaterialSpecInspectOrderByRelationAggregateInput
  }

  export type MaterialSpecWhereUniqueInput = {
    id?: number
  }

  export type MaterialSpecOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
    description?: SortOrder
    materialId?: SortOrder
    _count?: MaterialSpecCountOrderByAggregateInput
    _avg?: MaterialSpecAvgOrderByAggregateInput
    _max?: MaterialSpecMaxOrderByAggregateInput
    _min?: MaterialSpecMinOrderByAggregateInput
    _sum?: MaterialSpecSumOrderByAggregateInput
  }

  export type MaterialSpecScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MaterialSpecScalarWhereWithAggregatesInput>
    OR?: Enumerable<MaterialSpecScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MaterialSpecScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    isDeleted?: BoolWithAggregatesFilter | boolean
    name?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
    materialId?: IntWithAggregatesFilter | number
  }

  export type OperationWhereInput = {
    AND?: Enumerable<OperationWhereInput>
    OR?: Enumerable<OperationWhereInput>
    NOT?: Enumerable<OperationWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    name?: StringFilter | string
    description?: StringNullableFilter | string | null
    materialId?: IntFilter | number
    material?: XOR<MaterialRelationFilter, MaterialWhereInput>
    specs?: OperationSpecListRelationFilter
  }

  export type OperationOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
    description?: SortOrder
    materialId?: SortOrder
    material?: MaterialOrderByWithRelationInput
    specs?: OperationSpecOrderByRelationAggregateInput
  }

  export type OperationWhereUniqueInput = {
    id?: number
  }

  export type OperationOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
    description?: SortOrder
    materialId?: SortOrder
    _count?: OperationCountOrderByAggregateInput
    _avg?: OperationAvgOrderByAggregateInput
    _max?: OperationMaxOrderByAggregateInput
    _min?: OperationMinOrderByAggregateInput
    _sum?: OperationSumOrderByAggregateInput
  }

  export type OperationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OperationScalarWhereWithAggregatesInput>
    OR?: Enumerable<OperationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OperationScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    isDeleted?: BoolWithAggregatesFilter | boolean
    name?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
    materialId?: IntWithAggregatesFilter | number
  }

  export type OperationSpecWhereInput = {
    AND?: Enumerable<OperationSpecWhereInput>
    OR?: Enumerable<OperationSpecWhereInput>
    NOT?: Enumerable<OperationSpecWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    name?: StringFilter | string
    description?: StringNullableFilter | string | null
    operationId?: IntFilter | number
    operation?: XOR<OperationRelationFilter, OperationWhereInput>
    inspect?: OperationSpecInspectListRelationFilter
  }

  export type OperationSpecOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
    description?: SortOrder
    operationId?: SortOrder
    operation?: OperationOrderByWithRelationInput
    inspect?: OperationSpecInspectOrderByRelationAggregateInput
  }

  export type OperationSpecWhereUniqueInput = {
    id?: number
  }

  export type OperationSpecOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
    description?: SortOrder
    operationId?: SortOrder
    _count?: OperationSpecCountOrderByAggregateInput
    _avg?: OperationSpecAvgOrderByAggregateInput
    _max?: OperationSpecMaxOrderByAggregateInput
    _min?: OperationSpecMinOrderByAggregateInput
    _sum?: OperationSpecSumOrderByAggregateInput
  }

  export type OperationSpecScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OperationSpecScalarWhereWithAggregatesInput>
    OR?: Enumerable<OperationSpecScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OperationSpecScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    isDeleted?: BoolWithAggregatesFilter | boolean
    name?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
    operationId?: IntWithAggregatesFilter | number
  }

  export type IncomingInspectRecordWhereInput = {
    AND?: Enumerable<IncomingInspectRecordWhereInput>
    OR?: Enumerable<IncomingInspectRecordWhereInput>
    NOT?: Enumerable<IncomingInspectRecordWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    lot?: StringFilter | string
    materialId?: IntFilter | number
    description?: StringNullableFilter | string | null
    inspectorId?: IntFilter | number
    reviewerId?: IntFilter | number
    result?: EnumIncomingInspectResultFilter | IncomingInspectResult
    material?: XOR<MaterialRelationFilter, MaterialWhereInput>
    details?: MaterialSpecInspectListRelationFilter
    inspector?: XOR<UserRelationFilter, UserWhereInput> | null
    reviewer?: XOR<UserRelationFilter, UserWhereInput> | null
  }

  export type IncomingInspectRecordOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    lot?: SortOrder
    materialId?: SortOrder
    description?: SortOrder
    inspectorId?: SortOrder
    reviewerId?: SortOrder
    result?: SortOrder
    material?: MaterialOrderByWithRelationInput
    details?: MaterialSpecInspectOrderByRelationAggregateInput
    inspector?: UserOrderByWithRelationInput
    reviewer?: UserOrderByWithRelationInput
  }

  export type IncomingInspectRecordWhereUniqueInput = {
    id?: number
    lot?: string
  }

  export type IncomingInspectRecordOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    lot?: SortOrder
    materialId?: SortOrder
    description?: SortOrder
    inspectorId?: SortOrder
    reviewerId?: SortOrder
    result?: SortOrder
    _count?: IncomingInspectRecordCountOrderByAggregateInput
    _avg?: IncomingInspectRecordAvgOrderByAggregateInput
    _max?: IncomingInspectRecordMaxOrderByAggregateInput
    _min?: IncomingInspectRecordMinOrderByAggregateInput
    _sum?: IncomingInspectRecordSumOrderByAggregateInput
  }

  export type IncomingInspectRecordScalarWhereWithAggregatesInput = {
    AND?: Enumerable<IncomingInspectRecordScalarWhereWithAggregatesInput>
    OR?: Enumerable<IncomingInspectRecordScalarWhereWithAggregatesInput>
    NOT?: Enumerable<IncomingInspectRecordScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    isDeleted?: BoolWithAggregatesFilter | boolean
    lot?: StringWithAggregatesFilter | string
    materialId?: IntWithAggregatesFilter | number
    description?: StringNullableWithAggregatesFilter | string | null
    inspectorId?: IntWithAggregatesFilter | number
    reviewerId?: IntWithAggregatesFilter | number
    result?: EnumIncomingInspectResultWithAggregatesFilter | IncomingInspectResult
  }

  export type MaterialSpecInspectWhereInput = {
    AND?: Enumerable<MaterialSpecInspectWhereInput>
    OR?: Enumerable<MaterialSpecInspectWhereInput>
    NOT?: Enumerable<MaterialSpecInspectWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    recordId?: IntFilter | number
    specId?: IntFilter | number
    description?: StringNullableFilter | string | null
    result?: BoolFilter | boolean
    record?: XOR<IncomingInspectRecordRelationFilter, IncomingInspectRecordWhereInput>
    spec?: XOR<MaterialSpecRelationFilter, MaterialSpecWhereInput>
  }

  export type MaterialSpecInspectOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    recordId?: SortOrder
    specId?: SortOrder
    description?: SortOrder
    result?: SortOrder
    record?: IncomingInspectRecordOrderByWithRelationInput
    spec?: MaterialSpecOrderByWithRelationInput
  }

  export type MaterialSpecInspectWhereUniqueInput = {
    id?: number
  }

  export type MaterialSpecInspectOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    recordId?: SortOrder
    specId?: SortOrder
    description?: SortOrder
    result?: SortOrder
    _count?: MaterialSpecInspectCountOrderByAggregateInput
    _avg?: MaterialSpecInspectAvgOrderByAggregateInput
    _max?: MaterialSpecInspectMaxOrderByAggregateInput
    _min?: MaterialSpecInspectMinOrderByAggregateInput
    _sum?: MaterialSpecInspectSumOrderByAggregateInput
  }

  export type MaterialSpecInspectScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MaterialSpecInspectScalarWhereWithAggregatesInput>
    OR?: Enumerable<MaterialSpecInspectScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MaterialSpecInspectScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    isDeleted?: BoolWithAggregatesFilter | boolean
    recordId?: IntWithAggregatesFilter | number
    specId?: IntWithAggregatesFilter | number
    description?: StringNullableWithAggregatesFilter | string | null
    result?: BoolWithAggregatesFilter | boolean
  }

  export type InProcessInspectRecordWhereInput = {
    AND?: Enumerable<InProcessInspectRecordWhereInput>
    OR?: Enumerable<InProcessInspectRecordWhereInput>
    NOT?: Enumerable<InProcessInspectRecordWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    lot?: StringFilter | string
    description?: StringNullableFilter | string | null
    materialId?: IntFilter | number
    inspectorId?: IntFilter | number
    reviewerId?: IntFilter | number
    material?: XOR<MaterialRelationFilter, MaterialWhereInput>
    inspector?: XOR<UserRelationFilter, UserWhereInput> | null
    reviewer?: XOR<UserRelationFilter, UserWhereInput> | null
  }

  export type InProcessInspectRecordOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    lot?: SortOrder
    description?: SortOrder
    materialId?: SortOrder
    inspectorId?: SortOrder
    reviewerId?: SortOrder
    material?: MaterialOrderByWithRelationInput
    inspector?: UserOrderByWithRelationInput
    reviewer?: UserOrderByWithRelationInput
  }

  export type InProcessInspectRecordWhereUniqueInput = {
    id?: number
    lot?: string
  }

  export type InProcessInspectRecordOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    lot?: SortOrder
    description?: SortOrder
    materialId?: SortOrder
    inspectorId?: SortOrder
    reviewerId?: SortOrder
    _count?: InProcessInspectRecordCountOrderByAggregateInput
    _avg?: InProcessInspectRecordAvgOrderByAggregateInput
    _max?: InProcessInspectRecordMaxOrderByAggregateInput
    _min?: InProcessInspectRecordMinOrderByAggregateInput
    _sum?: InProcessInspectRecordSumOrderByAggregateInput
  }

  export type InProcessInspectRecordScalarWhereWithAggregatesInput = {
    AND?: Enumerable<InProcessInspectRecordScalarWhereWithAggregatesInput>
    OR?: Enumerable<InProcessInspectRecordScalarWhereWithAggregatesInput>
    NOT?: Enumerable<InProcessInspectRecordScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    isDeleted?: BoolWithAggregatesFilter | boolean
    lot?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
    materialId?: IntWithAggregatesFilter | number
    inspectorId?: IntWithAggregatesFilter | number
    reviewerId?: IntWithAggregatesFilter | number
  }

  export type OperationSpecInspectWhereInput = {
    AND?: Enumerable<OperationSpecInspectWhereInput>
    OR?: Enumerable<OperationSpecInspectWhereInput>
    NOT?: Enumerable<OperationSpecInspectWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    specId?: IntFilter | number
    first?: StringFilter | string
    inProcess?: StringFilter | string
    final?: StringFilter | string
    spec?: XOR<OperationSpecRelationFilter, OperationSpecWhereInput>
  }

  export type OperationSpecInspectOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    specId?: SortOrder
    first?: SortOrder
    inProcess?: SortOrder
    final?: SortOrder
    spec?: OperationSpecOrderByWithRelationInput
  }

  export type OperationSpecInspectWhereUniqueInput = {
    id?: number
  }

  export type OperationSpecInspectOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    specId?: SortOrder
    first?: SortOrder
    inProcess?: SortOrder
    final?: SortOrder
    _count?: OperationSpecInspectCountOrderByAggregateInput
    _avg?: OperationSpecInspectAvgOrderByAggregateInput
    _max?: OperationSpecInspectMaxOrderByAggregateInput
    _min?: OperationSpecInspectMinOrderByAggregateInput
    _sum?: OperationSpecInspectSumOrderByAggregateInput
  }

  export type OperationSpecInspectScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OperationSpecInspectScalarWhereWithAggregatesInput>
    OR?: Enumerable<OperationSpecInspectScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OperationSpecInspectScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    isDeleted?: BoolWithAggregatesFilter | boolean
    specId?: IntWithAggregatesFilter | number
    first?: StringWithAggregatesFilter | string
    inProcess?: StringWithAggregatesFilter | string
    final?: StringWithAggregatesFilter | string
  }

  export type TaskFormRelationCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    taskDefinitionKey: string
    formKey: string
  }

  export type TaskFormRelationUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    taskDefinitionKey: string
    formKey: string
  }

  export type TaskFormRelationUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    taskDefinitionKey?: StringFieldUpdateOperationsInput | string
    formKey?: StringFieldUpdateOperationsInput | string
  }

  export type TaskFormRelationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    taskDefinitionKey?: StringFieldUpdateOperationsInput | string
    formKey?: StringFieldUpdateOperationsInput | string
  }

  export type TaskFormRelationCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    taskDefinitionKey: string
    formKey: string
  }

  export type TaskFormRelationUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    taskDefinitionKey?: StringFieldUpdateOperationsInput | string
    formKey?: StringFieldUpdateOperationsInput | string
  }

  export type TaskFormRelationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    taskDefinitionKey?: StringFieldUpdateOperationsInput | string
    formKey?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    username: string
    hashedPassword?: string | null
    hashedRefreshToken?: string | null
    status: UserStatus
    role?: UserGroup
    profile?: UserProfileCreateNestedOneWithoutUserInput
    incomingInspectedRecords?: IncomingInspectRecordCreateNestedManyWithoutInspectorInput
    incomingReviewedRecords?: IncomingInspectRecordCreateNestedManyWithoutReviewerInput
    inProcessInspectedRecord?: InProcessInspectRecordCreateNestedManyWithoutInspectorInput
    inProcessReviewedRecord?: InProcessInspectRecordCreateNestedManyWithoutReviewerInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    username: string
    hashedPassword?: string | null
    hashedRefreshToken?: string | null
    status: UserStatus
    role?: UserGroup
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    incomingInspectedRecords?: IncomingInspectRecordUncheckedCreateNestedManyWithoutInspectorInput
    incomingReviewedRecords?: IncomingInspectRecordUncheckedCreateNestedManyWithoutReviewerInput
    inProcessInspectedRecord?: InProcessInspectRecordUncheckedCreateNestedManyWithoutInspectorInput
    inProcessReviewedRecord?: InProcessInspectRecordUncheckedCreateNestedManyWithoutReviewerInput
  }

  export type UserUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    username?: StringFieldUpdateOperationsInput | string
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    hashedRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | UserStatus
    role?: EnumUserGroupFieldUpdateOperationsInput | UserGroup
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    incomingInspectedRecords?: IncomingInspectRecordUpdateManyWithoutInspectorNestedInput
    incomingReviewedRecords?: IncomingInspectRecordUpdateManyWithoutReviewerNestedInput
    inProcessInspectedRecord?: InProcessInspectRecordUpdateManyWithoutInspectorNestedInput
    inProcessReviewedRecord?: InProcessInspectRecordUpdateManyWithoutReviewerNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    username?: StringFieldUpdateOperationsInput | string
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    hashedRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | UserStatus
    role?: EnumUserGroupFieldUpdateOperationsInput | UserGroup
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    incomingInspectedRecords?: IncomingInspectRecordUncheckedUpdateManyWithoutInspectorNestedInput
    incomingReviewedRecords?: IncomingInspectRecordUncheckedUpdateManyWithoutReviewerNestedInput
    inProcessInspectedRecord?: InProcessInspectRecordUncheckedUpdateManyWithoutInspectorNestedInput
    inProcessReviewedRecord?: InProcessInspectRecordUncheckedUpdateManyWithoutReviewerNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    username: string
    hashedPassword?: string | null
    hashedRefreshToken?: string | null
    status: UserStatus
    role?: UserGroup
  }

  export type UserUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    username?: StringFieldUpdateOperationsInput | string
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    hashedRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | UserStatus
    role?: EnumUserGroupFieldUpdateOperationsInput | UserGroup
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    username?: StringFieldUpdateOperationsInput | string
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    hashedRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | UserStatus
    role?: EnumUserGroupFieldUpdateOperationsInput | UserGroup
  }

  export type UserProfileCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    fullName: string
    user: UserCreateNestedOneWithoutProfileInput
  }

  export type UserProfileUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    userId: number
    fullName: string
  }

  export type UserProfileUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    fullName?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutProfileNestedInput
  }

  export type UserProfileUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
  }

  export type UserProfileCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    userId: number
    fullName: string
  }

  export type UserProfileUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    fullName?: StringFieldUpdateOperationsInput | string
  }

  export type UserProfileUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
  }

  export type ProductLineCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    description?: string | null
    equipment?: EquipmentCreateNestedManyWithoutProductLineInput
  }

  export type ProductLineUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    description?: string | null
    equipment?: EquipmentUncheckedCreateNestedManyWithoutProductLineInput
  }

  export type ProductLineUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    equipment?: EquipmentUpdateManyWithoutProductLineNestedInput
  }

  export type ProductLineUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    equipment?: EquipmentUncheckedUpdateManyWithoutProductLineNestedInput
  }

  export type ProductLineCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    description?: string | null
  }

  export type ProductLineUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductLineUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EquipmentCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    description?: string | null
    purchaseDate: Date | string
    plan?: RepairPlanCreateNestedOneWithoutEquipmentInput
    records?: RepairRecordCreateNestedManyWithoutEquipmentInput
    productLine?: ProductLineCreateNestedOneWithoutEquipmentInput
  }

  export type EquipmentUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    description?: string | null
    purchaseDate: Date | string
    productLineId?: number | null
    plan?: RepairPlanUncheckedCreateNestedOneWithoutEquipmentInput
    records?: RepairRecordUncheckedCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: RepairPlanUpdateOneWithoutEquipmentNestedInput
    records?: RepairRecordUpdateManyWithoutEquipmentNestedInput
    productLine?: ProductLineUpdateOneWithoutEquipmentNestedInput
  }

  export type EquipmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    productLineId?: NullableIntFieldUpdateOperationsInput | number | null
    plan?: RepairPlanUncheckedUpdateOneWithoutEquipmentNestedInput
    records?: RepairRecordUncheckedUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    description?: string | null
    purchaseDate: Date | string
    productLineId?: number | null
  }

  export type EquipmentUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    productLineId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RepairMaterialCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    description?: string | null
    inventory?: RepairMaterialInventoryCreateNestedOneWithoutRepairMaterialInput
  }

  export type RepairMaterialUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    description?: string | null
    inventory?: RepairMaterialInventoryUncheckedCreateNestedOneWithoutRepairMaterialInput
  }

  export type RepairMaterialUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    inventory?: RepairMaterialInventoryUpdateOneWithoutRepairMaterialNestedInput
  }

  export type RepairMaterialUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    inventory?: RepairMaterialInventoryUncheckedUpdateOneWithoutRepairMaterialNestedInput
  }

  export type RepairMaterialCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    description?: string | null
  }

  export type RepairMaterialUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RepairMaterialUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RepairPlanCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    description?: string | null
    equipment: EquipmentCreateNestedOneWithoutPlanInput
  }

  export type RepairPlanUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    description?: string | null
    equimentId: number
  }

  export type RepairPlanUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    equipment?: EquipmentUpdateOneRequiredWithoutPlanNestedInput
  }

  export type RepairPlanUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    equimentId?: IntFieldUpdateOperationsInput | number
  }

  export type RepairPlanCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    description?: string | null
    equimentId: number
  }

  export type RepairPlanUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RepairPlanUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    equimentId?: IntFieldUpdateOperationsInput | number
  }

  export type RepairMaterialInventoryCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    quantity: number
    repairMaterial: RepairMaterialCreateNestedOneWithoutInventoryInput
  }

  export type RepairMaterialInventoryUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    materialId: number
    quantity: number
  }

  export type RepairMaterialInventoryUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
    repairMaterial?: RepairMaterialUpdateOneRequiredWithoutInventoryNestedInput
  }

  export type RepairMaterialInventoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    materialId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type RepairMaterialInventoryCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    materialId: number
    quantity: number
  }

  export type RepairMaterialInventoryUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type RepairMaterialInventoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    materialId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type RepairRecordCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    description?: string | null
    status?: RepairRecordStatus | null
    type: RepairType
    equipment: EquipmentCreateNestedOneWithoutRecordsInput
  }

  export type RepairRecordUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    equimentId: number
    description?: string | null
    status?: RepairRecordStatus | null
    type: RepairType
  }

  export type RepairRecordUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumRepairRecordStatusFieldUpdateOperationsInput | RepairRecordStatus | null
    type?: EnumRepairTypeFieldUpdateOperationsInput | RepairType
    equipment?: EquipmentUpdateOneRequiredWithoutRecordsNestedInput
  }

  export type RepairRecordUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    equimentId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumRepairRecordStatusFieldUpdateOperationsInput | RepairRecordStatus | null
    type?: EnumRepairTypeFieldUpdateOperationsInput | RepairType
  }

  export type RepairRecordCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    equimentId: number
    description?: string | null
    status?: RepairRecordStatus | null
    type: RepairType
  }

  export type RepairRecordUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumRepairRecordStatusFieldUpdateOperationsInput | RepairRecordStatus | null
    type?: EnumRepairTypeFieldUpdateOperationsInput | RepairType
  }

  export type RepairRecordUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    equimentId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumRepairRecordStatusFieldUpdateOperationsInput | RepairRecordStatus | null
    type?: EnumRepairTypeFieldUpdateOperationsInput | RepairType
  }

  export type MaterialCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    description?: string | null
    specs?: MaterialSpecCreateNestedManyWithoutMaterialInput
    operations?: OperationCreateNestedManyWithoutMaterialInput
    incomingInspectRecord?: IncomingInspectRecordCreateNestedManyWithoutMaterialInput
    inProcessInspectRecord?: InProcessInspectRecordCreateNestedManyWithoutMaterialInput
  }

  export type MaterialUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    description?: string | null
    specs?: MaterialSpecUncheckedCreateNestedManyWithoutMaterialInput
    operations?: OperationUncheckedCreateNestedManyWithoutMaterialInput
    incomingInspectRecord?: IncomingInspectRecordUncheckedCreateNestedManyWithoutMaterialInput
    inProcessInspectRecord?: InProcessInspectRecordUncheckedCreateNestedManyWithoutMaterialInput
  }

  export type MaterialUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    specs?: MaterialSpecUpdateManyWithoutMaterialNestedInput
    operations?: OperationUpdateManyWithoutMaterialNestedInput
    incomingInspectRecord?: IncomingInspectRecordUpdateManyWithoutMaterialNestedInput
    inProcessInspectRecord?: InProcessInspectRecordUpdateManyWithoutMaterialNestedInput
  }

  export type MaterialUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    specs?: MaterialSpecUncheckedUpdateManyWithoutMaterialNestedInput
    operations?: OperationUncheckedUpdateManyWithoutMaterialNestedInput
    incomingInspectRecord?: IncomingInspectRecordUncheckedUpdateManyWithoutMaterialNestedInput
    inProcessInspectRecord?: InProcessInspectRecordUncheckedUpdateManyWithoutMaterialNestedInput
  }

  export type MaterialCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    description?: string | null
  }

  export type MaterialUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MaterialUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MaterialSpecCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    description?: string | null
    material: MaterialCreateNestedOneWithoutSpecsInput
    inspects?: MaterialSpecInspectCreateNestedManyWithoutSpecInput
  }

  export type MaterialSpecUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    description?: string | null
    materialId: number
    inspects?: MaterialSpecInspectUncheckedCreateNestedManyWithoutSpecInput
  }

  export type MaterialSpecUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    material?: MaterialUpdateOneRequiredWithoutSpecsNestedInput
    inspects?: MaterialSpecInspectUpdateManyWithoutSpecNestedInput
  }

  export type MaterialSpecUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    materialId?: IntFieldUpdateOperationsInput | number
    inspects?: MaterialSpecInspectUncheckedUpdateManyWithoutSpecNestedInput
  }

  export type MaterialSpecCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    description?: string | null
    materialId: number
  }

  export type MaterialSpecUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MaterialSpecUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    materialId?: IntFieldUpdateOperationsInput | number
  }

  export type OperationCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    description?: string | null
    material: MaterialCreateNestedOneWithoutOperationsInput
    specs?: OperationSpecCreateNestedManyWithoutOperationInput
  }

  export type OperationUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    description?: string | null
    materialId: number
    specs?: OperationSpecUncheckedCreateNestedManyWithoutOperationInput
  }

  export type OperationUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    material?: MaterialUpdateOneRequiredWithoutOperationsNestedInput
    specs?: OperationSpecUpdateManyWithoutOperationNestedInput
  }

  export type OperationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    materialId?: IntFieldUpdateOperationsInput | number
    specs?: OperationSpecUncheckedUpdateManyWithoutOperationNestedInput
  }

  export type OperationCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    description?: string | null
    materialId: number
  }

  export type OperationUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OperationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    materialId?: IntFieldUpdateOperationsInput | number
  }

  export type OperationSpecCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    description?: string | null
    operation: OperationCreateNestedOneWithoutSpecsInput
    inspect?: OperationSpecInspectCreateNestedManyWithoutSpecInput
  }

  export type OperationSpecUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    description?: string | null
    operationId: number
    inspect?: OperationSpecInspectUncheckedCreateNestedManyWithoutSpecInput
  }

  export type OperationSpecUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    operation?: OperationUpdateOneRequiredWithoutSpecsNestedInput
    inspect?: OperationSpecInspectUpdateManyWithoutSpecNestedInput
  }

  export type OperationSpecUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    operationId?: IntFieldUpdateOperationsInput | number
    inspect?: OperationSpecInspectUncheckedUpdateManyWithoutSpecNestedInput
  }

  export type OperationSpecCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    description?: string | null
    operationId: number
  }

  export type OperationSpecUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OperationSpecUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    operationId?: IntFieldUpdateOperationsInput | number
  }

  export type IncomingInspectRecordCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    lot: string
    description?: string | null
    result: IncomingInspectResult
    material: MaterialCreateNestedOneWithoutIncomingInspectRecordInput
    details?: MaterialSpecInspectCreateNestedManyWithoutRecordInput
    inspector?: UserCreateNestedOneWithoutIncomingInspectedRecordsInput
    reviewer?: UserCreateNestedOneWithoutIncomingReviewedRecordsInput
  }

  export type IncomingInspectRecordUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    lot: string
    materialId: number
    description?: string | null
    inspectorId: number
    reviewerId: number
    result: IncomingInspectResult
    details?: MaterialSpecInspectUncheckedCreateNestedManyWithoutRecordInput
  }

  export type IncomingInspectRecordUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    lot?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    result?: EnumIncomingInspectResultFieldUpdateOperationsInput | IncomingInspectResult
    material?: MaterialUpdateOneRequiredWithoutIncomingInspectRecordNestedInput
    details?: MaterialSpecInspectUpdateManyWithoutRecordNestedInput
    inspector?: UserUpdateOneWithoutIncomingInspectedRecordsNestedInput
    reviewer?: UserUpdateOneWithoutIncomingReviewedRecordsNestedInput
  }

  export type IncomingInspectRecordUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    lot?: StringFieldUpdateOperationsInput | string
    materialId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    inspectorId?: IntFieldUpdateOperationsInput | number
    reviewerId?: IntFieldUpdateOperationsInput | number
    result?: EnumIncomingInspectResultFieldUpdateOperationsInput | IncomingInspectResult
    details?: MaterialSpecInspectUncheckedUpdateManyWithoutRecordNestedInput
  }

  export type IncomingInspectRecordCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    lot: string
    materialId: number
    description?: string | null
    inspectorId: number
    reviewerId: number
    result: IncomingInspectResult
  }

  export type IncomingInspectRecordUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    lot?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    result?: EnumIncomingInspectResultFieldUpdateOperationsInput | IncomingInspectResult
  }

  export type IncomingInspectRecordUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    lot?: StringFieldUpdateOperationsInput | string
    materialId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    inspectorId?: IntFieldUpdateOperationsInput | number
    reviewerId?: IntFieldUpdateOperationsInput | number
    result?: EnumIncomingInspectResultFieldUpdateOperationsInput | IncomingInspectResult
  }

  export type MaterialSpecInspectCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    description?: string | null
    result: boolean
    record: IncomingInspectRecordCreateNestedOneWithoutDetailsInput
    spec: MaterialSpecCreateNestedOneWithoutInspectsInput
  }

  export type MaterialSpecInspectUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    recordId: number
    specId: number
    description?: string | null
    result: boolean
  }

  export type MaterialSpecInspectUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    result?: BoolFieldUpdateOperationsInput | boolean
    record?: IncomingInspectRecordUpdateOneRequiredWithoutDetailsNestedInput
    spec?: MaterialSpecUpdateOneRequiredWithoutInspectsNestedInput
  }

  export type MaterialSpecInspectUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    recordId?: IntFieldUpdateOperationsInput | number
    specId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    result?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MaterialSpecInspectCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    recordId: number
    specId: number
    description?: string | null
    result: boolean
  }

  export type MaterialSpecInspectUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    result?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MaterialSpecInspectUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    recordId?: IntFieldUpdateOperationsInput | number
    specId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    result?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InProcessInspectRecordCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    lot: string
    description?: string | null
    material: MaterialCreateNestedOneWithoutInProcessInspectRecordInput
    inspector?: UserCreateNestedOneWithoutInProcessInspectedRecordInput
    reviewer?: UserCreateNestedOneWithoutInProcessReviewedRecordInput
  }

  export type InProcessInspectRecordUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    lot: string
    description?: string | null
    materialId: number
    inspectorId: number
    reviewerId: number
  }

  export type InProcessInspectRecordUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    lot?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    material?: MaterialUpdateOneRequiredWithoutInProcessInspectRecordNestedInput
    inspector?: UserUpdateOneWithoutInProcessInspectedRecordNestedInput
    reviewer?: UserUpdateOneWithoutInProcessReviewedRecordNestedInput
  }

  export type InProcessInspectRecordUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    lot?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    materialId?: IntFieldUpdateOperationsInput | number
    inspectorId?: IntFieldUpdateOperationsInput | number
    reviewerId?: IntFieldUpdateOperationsInput | number
  }

  export type InProcessInspectRecordCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    lot: string
    description?: string | null
    materialId: number
    inspectorId: number
    reviewerId: number
  }

  export type InProcessInspectRecordUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    lot?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InProcessInspectRecordUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    lot?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    materialId?: IntFieldUpdateOperationsInput | number
    inspectorId?: IntFieldUpdateOperationsInput | number
    reviewerId?: IntFieldUpdateOperationsInput | number
  }

  export type OperationSpecInspectCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    first: string
    inProcess: string
    final: string
    spec: OperationSpecCreateNestedOneWithoutInspectInput
  }

  export type OperationSpecInspectUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    specId: number
    first: string
    inProcess: string
    final: string
  }

  export type OperationSpecInspectUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    first?: StringFieldUpdateOperationsInput | string
    inProcess?: StringFieldUpdateOperationsInput | string
    final?: StringFieldUpdateOperationsInput | string
    spec?: OperationSpecUpdateOneRequiredWithoutInspectNestedInput
  }

  export type OperationSpecInspectUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    specId?: IntFieldUpdateOperationsInput | number
    first?: StringFieldUpdateOperationsInput | string
    inProcess?: StringFieldUpdateOperationsInput | string
    final?: StringFieldUpdateOperationsInput | string
  }

  export type OperationSpecInspectCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    specId: number
    first: string
    inProcess: string
    final: string
  }

  export type OperationSpecInspectUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    first?: StringFieldUpdateOperationsInput | string
    inProcess?: StringFieldUpdateOperationsInput | string
    final?: StringFieldUpdateOperationsInput | string
  }

  export type OperationSpecInspectUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    specId?: IntFieldUpdateOperationsInput | number
    first?: StringFieldUpdateOperationsInput | string
    inProcess?: StringFieldUpdateOperationsInput | string
    final?: StringFieldUpdateOperationsInput | string
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type TaskFormRelationCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    taskDefinitionKey?: SortOrder
    formKey?: SortOrder
  }

  export type TaskFormRelationAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TaskFormRelationMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    taskDefinitionKey?: SortOrder
    formKey?: SortOrder
  }

  export type TaskFormRelationMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    taskDefinitionKey?: SortOrder
    formKey?: SortOrder
  }

  export type TaskFormRelationSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type EnumUserStatusFilter = {
    equals?: UserStatus
    in?: Enumerable<UserStatus>
    notIn?: Enumerable<UserStatus>
    not?: NestedEnumUserStatusFilter | UserStatus
  }

  export type EnumUserGroupFilter = {
    equals?: UserGroup
    in?: Enumerable<UserGroup>
    notIn?: Enumerable<UserGroup>
    not?: NestedEnumUserGroupFilter | UserGroup
  }

  export type UserProfileRelationFilter = {
    is?: UserProfileWhereInput | null
    isNot?: UserProfileWhereInput | null
  }

  export type IncomingInspectRecordListRelationFilter = {
    every?: IncomingInspectRecordWhereInput
    some?: IncomingInspectRecordWhereInput
    none?: IncomingInspectRecordWhereInput
  }

  export type InProcessInspectRecordListRelationFilter = {
    every?: InProcessInspectRecordWhereInput
    some?: InProcessInspectRecordWhereInput
    none?: InProcessInspectRecordWhereInput
  }

  export type IncomingInspectRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InProcessInspectRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    username?: SortOrder
    hashedPassword?: SortOrder
    hashedRefreshToken?: SortOrder
    status?: SortOrder
    role?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    username?: SortOrder
    hashedPassword?: SortOrder
    hashedRefreshToken?: SortOrder
    status?: SortOrder
    role?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    username?: SortOrder
    hashedPassword?: SortOrder
    hashedRefreshToken?: SortOrder
    status?: SortOrder
    role?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type EnumUserStatusWithAggregatesFilter = {
    equals?: UserStatus
    in?: Enumerable<UserStatus>
    notIn?: Enumerable<UserStatus>
    not?: NestedEnumUserStatusWithAggregatesFilter | UserStatus
    _count?: NestedIntFilter
    _min?: NestedEnumUserStatusFilter
    _max?: NestedEnumUserStatusFilter
  }

  export type EnumUserGroupWithAggregatesFilter = {
    equals?: UserGroup
    in?: Enumerable<UserGroup>
    notIn?: Enumerable<UserGroup>
    not?: NestedEnumUserGroupWithAggregatesFilter | UserGroup
    _count?: NestedIntFilter
    _min?: NestedEnumUserGroupFilter
    _max?: NestedEnumUserGroupFilter
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type UserProfileCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    userId?: SortOrder
    fullName?: SortOrder
  }

  export type UserProfileAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type UserProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    userId?: SortOrder
    fullName?: SortOrder
  }

  export type UserProfileMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    userId?: SortOrder
    fullName?: SortOrder
  }

  export type UserProfileSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type EquipmentListRelationFilter = {
    every?: EquipmentWhereInput
    some?: EquipmentWhereInput
    none?: EquipmentWhereInput
  }

  export type EquipmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductLineCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type ProductLineAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ProductLineMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type ProductLineMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type ProductLineSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type RepairPlanRelationFilter = {
    is?: RepairPlanWhereInput | null
    isNot?: RepairPlanWhereInput | null
  }

  export type RepairRecordListRelationFilter = {
    every?: RepairRecordWhereInput
    some?: RepairRecordWhereInput
    none?: RepairRecordWhereInput
  }

  export type ProductLineRelationFilter = {
    is?: ProductLineWhereInput | null
    isNot?: ProductLineWhereInput | null
  }

  export type RepairRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EquipmentCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
    description?: SortOrder
    purchaseDate?: SortOrder
    productLineId?: SortOrder
  }

  export type EquipmentAvgOrderByAggregateInput = {
    id?: SortOrder
    productLineId?: SortOrder
  }

  export type EquipmentMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
    description?: SortOrder
    purchaseDate?: SortOrder
    productLineId?: SortOrder
  }

  export type EquipmentMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
    description?: SortOrder
    purchaseDate?: SortOrder
    productLineId?: SortOrder
  }

  export type EquipmentSumOrderByAggregateInput = {
    id?: SortOrder
    productLineId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type RepairMaterialInventoryRelationFilter = {
    is?: RepairMaterialInventoryWhereInput | null
    isNot?: RepairMaterialInventoryWhereInput | null
  }

  export type RepairMaterialCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type RepairMaterialAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RepairMaterialMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type RepairMaterialMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type RepairMaterialSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EquipmentRelationFilter = {
    is?: EquipmentWhereInput
    isNot?: EquipmentWhereInput
  }

  export type RepairPlanCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    description?: SortOrder
    equimentId?: SortOrder
  }

  export type RepairPlanAvgOrderByAggregateInput = {
    id?: SortOrder
    equimentId?: SortOrder
  }

  export type RepairPlanMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    description?: SortOrder
    equimentId?: SortOrder
  }

  export type RepairPlanMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    description?: SortOrder
    equimentId?: SortOrder
  }

  export type RepairPlanSumOrderByAggregateInput = {
    id?: SortOrder
    equimentId?: SortOrder
  }

  export type RepairMaterialRelationFilter = {
    is?: RepairMaterialWhereInput
    isNot?: RepairMaterialWhereInput
  }

  export type RepairMaterialInventoryCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    materialId?: SortOrder
    quantity?: SortOrder
  }

  export type RepairMaterialInventoryAvgOrderByAggregateInput = {
    id?: SortOrder
    materialId?: SortOrder
    quantity?: SortOrder
  }

  export type RepairMaterialInventoryMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    materialId?: SortOrder
    quantity?: SortOrder
  }

  export type RepairMaterialInventoryMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    materialId?: SortOrder
    quantity?: SortOrder
  }

  export type RepairMaterialInventorySumOrderByAggregateInput = {
    id?: SortOrder
    materialId?: SortOrder
    quantity?: SortOrder
  }

  export type EnumRepairRecordStatusNullableFilter = {
    equals?: RepairRecordStatus | null
    in?: Enumerable<RepairRecordStatus> | null
    notIn?: Enumerable<RepairRecordStatus> | null
    not?: NestedEnumRepairRecordStatusNullableFilter | RepairRecordStatus | null
  }

  export type EnumRepairTypeFilter = {
    equals?: RepairType
    in?: Enumerable<RepairType>
    notIn?: Enumerable<RepairType>
    not?: NestedEnumRepairTypeFilter | RepairType
  }

  export type RepairRecordCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    equimentId?: SortOrder
    description?: SortOrder
    status?: SortOrder
    type?: SortOrder
  }

  export type RepairRecordAvgOrderByAggregateInput = {
    id?: SortOrder
    equimentId?: SortOrder
  }

  export type RepairRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    equimentId?: SortOrder
    description?: SortOrder
    status?: SortOrder
    type?: SortOrder
  }

  export type RepairRecordMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    equimentId?: SortOrder
    description?: SortOrder
    status?: SortOrder
    type?: SortOrder
  }

  export type RepairRecordSumOrderByAggregateInput = {
    id?: SortOrder
    equimentId?: SortOrder
  }

  export type EnumRepairRecordStatusNullableWithAggregatesFilter = {
    equals?: RepairRecordStatus | null
    in?: Enumerable<RepairRecordStatus> | null
    notIn?: Enumerable<RepairRecordStatus> | null
    not?: NestedEnumRepairRecordStatusNullableWithAggregatesFilter | RepairRecordStatus | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumRepairRecordStatusNullableFilter
    _max?: NestedEnumRepairRecordStatusNullableFilter
  }

  export type EnumRepairTypeWithAggregatesFilter = {
    equals?: RepairType
    in?: Enumerable<RepairType>
    notIn?: Enumerable<RepairType>
    not?: NestedEnumRepairTypeWithAggregatesFilter | RepairType
    _count?: NestedIntFilter
    _min?: NestedEnumRepairTypeFilter
    _max?: NestedEnumRepairTypeFilter
  }

  export type MaterialSpecListRelationFilter = {
    every?: MaterialSpecWhereInput
    some?: MaterialSpecWhereInput
    none?: MaterialSpecWhereInput
  }

  export type OperationListRelationFilter = {
    every?: OperationWhereInput
    some?: OperationWhereInput
    none?: OperationWhereInput
  }

  export type MaterialSpecOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OperationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MaterialCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type MaterialAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MaterialMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type MaterialMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type MaterialSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MaterialRelationFilter = {
    is?: MaterialWhereInput
    isNot?: MaterialWhereInput
  }

  export type MaterialSpecInspectListRelationFilter = {
    every?: MaterialSpecInspectWhereInput
    some?: MaterialSpecInspectWhereInput
    none?: MaterialSpecInspectWhereInput
  }

  export type MaterialSpecInspectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MaterialSpecCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
    description?: SortOrder
    materialId?: SortOrder
  }

  export type MaterialSpecAvgOrderByAggregateInput = {
    id?: SortOrder
    materialId?: SortOrder
  }

  export type MaterialSpecMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
    description?: SortOrder
    materialId?: SortOrder
  }

  export type MaterialSpecMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
    description?: SortOrder
    materialId?: SortOrder
  }

  export type MaterialSpecSumOrderByAggregateInput = {
    id?: SortOrder
    materialId?: SortOrder
  }

  export type OperationSpecListRelationFilter = {
    every?: OperationSpecWhereInput
    some?: OperationSpecWhereInput
    none?: OperationSpecWhereInput
  }

  export type OperationSpecOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OperationCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
    description?: SortOrder
    materialId?: SortOrder
  }

  export type OperationAvgOrderByAggregateInput = {
    id?: SortOrder
    materialId?: SortOrder
  }

  export type OperationMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
    description?: SortOrder
    materialId?: SortOrder
  }

  export type OperationMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
    description?: SortOrder
    materialId?: SortOrder
  }

  export type OperationSumOrderByAggregateInput = {
    id?: SortOrder
    materialId?: SortOrder
  }

  export type OperationRelationFilter = {
    is?: OperationWhereInput
    isNot?: OperationWhereInput
  }

  export type OperationSpecInspectListRelationFilter = {
    every?: OperationSpecInspectWhereInput
    some?: OperationSpecInspectWhereInput
    none?: OperationSpecInspectWhereInput
  }

  export type OperationSpecInspectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OperationSpecCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
    description?: SortOrder
    operationId?: SortOrder
  }

  export type OperationSpecAvgOrderByAggregateInput = {
    id?: SortOrder
    operationId?: SortOrder
  }

  export type OperationSpecMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
    description?: SortOrder
    operationId?: SortOrder
  }

  export type OperationSpecMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    name?: SortOrder
    description?: SortOrder
    operationId?: SortOrder
  }

  export type OperationSpecSumOrderByAggregateInput = {
    id?: SortOrder
    operationId?: SortOrder
  }

  export type EnumIncomingInspectResultFilter = {
    equals?: IncomingInspectResult
    in?: Enumerable<IncomingInspectResult>
    notIn?: Enumerable<IncomingInspectResult>
    not?: NestedEnumIncomingInspectResultFilter | IncomingInspectResult
  }

  export type IncomingInspectRecordCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    lot?: SortOrder
    materialId?: SortOrder
    description?: SortOrder
    inspectorId?: SortOrder
    reviewerId?: SortOrder
    result?: SortOrder
  }

  export type IncomingInspectRecordAvgOrderByAggregateInput = {
    id?: SortOrder
    materialId?: SortOrder
    inspectorId?: SortOrder
    reviewerId?: SortOrder
  }

  export type IncomingInspectRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    lot?: SortOrder
    materialId?: SortOrder
    description?: SortOrder
    inspectorId?: SortOrder
    reviewerId?: SortOrder
    result?: SortOrder
  }

  export type IncomingInspectRecordMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    lot?: SortOrder
    materialId?: SortOrder
    description?: SortOrder
    inspectorId?: SortOrder
    reviewerId?: SortOrder
    result?: SortOrder
  }

  export type IncomingInspectRecordSumOrderByAggregateInput = {
    id?: SortOrder
    materialId?: SortOrder
    inspectorId?: SortOrder
    reviewerId?: SortOrder
  }

  export type EnumIncomingInspectResultWithAggregatesFilter = {
    equals?: IncomingInspectResult
    in?: Enumerable<IncomingInspectResult>
    notIn?: Enumerable<IncomingInspectResult>
    not?: NestedEnumIncomingInspectResultWithAggregatesFilter | IncomingInspectResult
    _count?: NestedIntFilter
    _min?: NestedEnumIncomingInspectResultFilter
    _max?: NestedEnumIncomingInspectResultFilter
  }

  export type IncomingInspectRecordRelationFilter = {
    is?: IncomingInspectRecordWhereInput
    isNot?: IncomingInspectRecordWhereInput
  }

  export type MaterialSpecRelationFilter = {
    is?: MaterialSpecWhereInput
    isNot?: MaterialSpecWhereInput
  }

  export type MaterialSpecInspectCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    recordId?: SortOrder
    specId?: SortOrder
    description?: SortOrder
    result?: SortOrder
  }

  export type MaterialSpecInspectAvgOrderByAggregateInput = {
    id?: SortOrder
    recordId?: SortOrder
    specId?: SortOrder
  }

  export type MaterialSpecInspectMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    recordId?: SortOrder
    specId?: SortOrder
    description?: SortOrder
    result?: SortOrder
  }

  export type MaterialSpecInspectMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    recordId?: SortOrder
    specId?: SortOrder
    description?: SortOrder
    result?: SortOrder
  }

  export type MaterialSpecInspectSumOrderByAggregateInput = {
    id?: SortOrder
    recordId?: SortOrder
    specId?: SortOrder
  }

  export type InProcessInspectRecordCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    lot?: SortOrder
    description?: SortOrder
    materialId?: SortOrder
    inspectorId?: SortOrder
    reviewerId?: SortOrder
  }

  export type InProcessInspectRecordAvgOrderByAggregateInput = {
    id?: SortOrder
    materialId?: SortOrder
    inspectorId?: SortOrder
    reviewerId?: SortOrder
  }

  export type InProcessInspectRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    lot?: SortOrder
    description?: SortOrder
    materialId?: SortOrder
    inspectorId?: SortOrder
    reviewerId?: SortOrder
  }

  export type InProcessInspectRecordMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    lot?: SortOrder
    description?: SortOrder
    materialId?: SortOrder
    inspectorId?: SortOrder
    reviewerId?: SortOrder
  }

  export type InProcessInspectRecordSumOrderByAggregateInput = {
    id?: SortOrder
    materialId?: SortOrder
    inspectorId?: SortOrder
    reviewerId?: SortOrder
  }

  export type OperationSpecRelationFilter = {
    is?: OperationSpecWhereInput
    isNot?: OperationSpecWhereInput
  }

  export type OperationSpecInspectCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    specId?: SortOrder
    first?: SortOrder
    inProcess?: SortOrder
    final?: SortOrder
  }

  export type OperationSpecInspectAvgOrderByAggregateInput = {
    id?: SortOrder
    specId?: SortOrder
  }

  export type OperationSpecInspectMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    specId?: SortOrder
    first?: SortOrder
    inProcess?: SortOrder
    final?: SortOrder
  }

  export type OperationSpecInspectMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    specId?: SortOrder
    first?: SortOrder
    inProcess?: SortOrder
    final?: SortOrder
  }

  export type OperationSpecInspectSumOrderByAggregateInput = {
    id?: SortOrder
    specId?: SortOrder
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutUserInput
    connect?: UserProfileWhereUniqueInput
  }

  export type IncomingInspectRecordCreateNestedManyWithoutInspectorInput = {
    create?: XOR<Enumerable<IncomingInspectRecordCreateWithoutInspectorInput>, Enumerable<IncomingInspectRecordUncheckedCreateWithoutInspectorInput>>
    connectOrCreate?: Enumerable<IncomingInspectRecordCreateOrConnectWithoutInspectorInput>
    createMany?: IncomingInspectRecordCreateManyInspectorInputEnvelope
    connect?: Enumerable<IncomingInspectRecordWhereUniqueInput>
  }

  export type IncomingInspectRecordCreateNestedManyWithoutReviewerInput = {
    create?: XOR<Enumerable<IncomingInspectRecordCreateWithoutReviewerInput>, Enumerable<IncomingInspectRecordUncheckedCreateWithoutReviewerInput>>
    connectOrCreate?: Enumerable<IncomingInspectRecordCreateOrConnectWithoutReviewerInput>
    createMany?: IncomingInspectRecordCreateManyReviewerInputEnvelope
    connect?: Enumerable<IncomingInspectRecordWhereUniqueInput>
  }

  export type InProcessInspectRecordCreateNestedManyWithoutInspectorInput = {
    create?: XOR<Enumerable<InProcessInspectRecordCreateWithoutInspectorInput>, Enumerable<InProcessInspectRecordUncheckedCreateWithoutInspectorInput>>
    connectOrCreate?: Enumerable<InProcessInspectRecordCreateOrConnectWithoutInspectorInput>
    createMany?: InProcessInspectRecordCreateManyInspectorInputEnvelope
    connect?: Enumerable<InProcessInspectRecordWhereUniqueInput>
  }

  export type InProcessInspectRecordCreateNestedManyWithoutReviewerInput = {
    create?: XOR<Enumerable<InProcessInspectRecordCreateWithoutReviewerInput>, Enumerable<InProcessInspectRecordUncheckedCreateWithoutReviewerInput>>
    connectOrCreate?: Enumerable<InProcessInspectRecordCreateOrConnectWithoutReviewerInput>
    createMany?: InProcessInspectRecordCreateManyReviewerInputEnvelope
    connect?: Enumerable<InProcessInspectRecordWhereUniqueInput>
  }

  export type UserProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutUserInput
    connect?: UserProfileWhereUniqueInput
  }

  export type IncomingInspectRecordUncheckedCreateNestedManyWithoutInspectorInput = {
    create?: XOR<Enumerable<IncomingInspectRecordCreateWithoutInspectorInput>, Enumerable<IncomingInspectRecordUncheckedCreateWithoutInspectorInput>>
    connectOrCreate?: Enumerable<IncomingInspectRecordCreateOrConnectWithoutInspectorInput>
    createMany?: IncomingInspectRecordCreateManyInspectorInputEnvelope
    connect?: Enumerable<IncomingInspectRecordWhereUniqueInput>
  }

  export type IncomingInspectRecordUncheckedCreateNestedManyWithoutReviewerInput = {
    create?: XOR<Enumerable<IncomingInspectRecordCreateWithoutReviewerInput>, Enumerable<IncomingInspectRecordUncheckedCreateWithoutReviewerInput>>
    connectOrCreate?: Enumerable<IncomingInspectRecordCreateOrConnectWithoutReviewerInput>
    createMany?: IncomingInspectRecordCreateManyReviewerInputEnvelope
    connect?: Enumerable<IncomingInspectRecordWhereUniqueInput>
  }

  export type InProcessInspectRecordUncheckedCreateNestedManyWithoutInspectorInput = {
    create?: XOR<Enumerable<InProcessInspectRecordCreateWithoutInspectorInput>, Enumerable<InProcessInspectRecordUncheckedCreateWithoutInspectorInput>>
    connectOrCreate?: Enumerable<InProcessInspectRecordCreateOrConnectWithoutInspectorInput>
    createMany?: InProcessInspectRecordCreateManyInspectorInputEnvelope
    connect?: Enumerable<InProcessInspectRecordWhereUniqueInput>
  }

  export type InProcessInspectRecordUncheckedCreateNestedManyWithoutReviewerInput = {
    create?: XOR<Enumerable<InProcessInspectRecordCreateWithoutReviewerInput>, Enumerable<InProcessInspectRecordUncheckedCreateWithoutReviewerInput>>
    connectOrCreate?: Enumerable<InProcessInspectRecordCreateOrConnectWithoutReviewerInput>
    createMany?: InProcessInspectRecordCreateManyReviewerInputEnvelope
    connect?: Enumerable<InProcessInspectRecordWhereUniqueInput>
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumUserStatusFieldUpdateOperationsInput = {
    set?: UserStatus
  }

  export type EnumUserGroupFieldUpdateOperationsInput = {
    set?: UserGroup
  }

  export type UserProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutUserInput
    upsert?: UserProfileUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserProfileWhereUniqueInput
    update?: XOR<UserProfileUpdateWithoutUserInput, UserProfileUncheckedUpdateWithoutUserInput>
  }

  export type IncomingInspectRecordUpdateManyWithoutInspectorNestedInput = {
    create?: XOR<Enumerable<IncomingInspectRecordCreateWithoutInspectorInput>, Enumerable<IncomingInspectRecordUncheckedCreateWithoutInspectorInput>>
    connectOrCreate?: Enumerable<IncomingInspectRecordCreateOrConnectWithoutInspectorInput>
    upsert?: Enumerable<IncomingInspectRecordUpsertWithWhereUniqueWithoutInspectorInput>
    createMany?: IncomingInspectRecordCreateManyInspectorInputEnvelope
    set?: Enumerable<IncomingInspectRecordWhereUniqueInput>
    disconnect?: Enumerable<IncomingInspectRecordWhereUniqueInput>
    delete?: Enumerable<IncomingInspectRecordWhereUniqueInput>
    connect?: Enumerable<IncomingInspectRecordWhereUniqueInput>
    update?: Enumerable<IncomingInspectRecordUpdateWithWhereUniqueWithoutInspectorInput>
    updateMany?: Enumerable<IncomingInspectRecordUpdateManyWithWhereWithoutInspectorInput>
    deleteMany?: Enumerable<IncomingInspectRecordScalarWhereInput>
  }

  export type IncomingInspectRecordUpdateManyWithoutReviewerNestedInput = {
    create?: XOR<Enumerable<IncomingInspectRecordCreateWithoutReviewerInput>, Enumerable<IncomingInspectRecordUncheckedCreateWithoutReviewerInput>>
    connectOrCreate?: Enumerable<IncomingInspectRecordCreateOrConnectWithoutReviewerInput>
    upsert?: Enumerable<IncomingInspectRecordUpsertWithWhereUniqueWithoutReviewerInput>
    createMany?: IncomingInspectRecordCreateManyReviewerInputEnvelope
    set?: Enumerable<IncomingInspectRecordWhereUniqueInput>
    disconnect?: Enumerable<IncomingInspectRecordWhereUniqueInput>
    delete?: Enumerable<IncomingInspectRecordWhereUniqueInput>
    connect?: Enumerable<IncomingInspectRecordWhereUniqueInput>
    update?: Enumerable<IncomingInspectRecordUpdateWithWhereUniqueWithoutReviewerInput>
    updateMany?: Enumerable<IncomingInspectRecordUpdateManyWithWhereWithoutReviewerInput>
    deleteMany?: Enumerable<IncomingInspectRecordScalarWhereInput>
  }

  export type InProcessInspectRecordUpdateManyWithoutInspectorNestedInput = {
    create?: XOR<Enumerable<InProcessInspectRecordCreateWithoutInspectorInput>, Enumerable<InProcessInspectRecordUncheckedCreateWithoutInspectorInput>>
    connectOrCreate?: Enumerable<InProcessInspectRecordCreateOrConnectWithoutInspectorInput>
    upsert?: Enumerable<InProcessInspectRecordUpsertWithWhereUniqueWithoutInspectorInput>
    createMany?: InProcessInspectRecordCreateManyInspectorInputEnvelope
    set?: Enumerable<InProcessInspectRecordWhereUniqueInput>
    disconnect?: Enumerable<InProcessInspectRecordWhereUniqueInput>
    delete?: Enumerable<InProcessInspectRecordWhereUniqueInput>
    connect?: Enumerable<InProcessInspectRecordWhereUniqueInput>
    update?: Enumerable<InProcessInspectRecordUpdateWithWhereUniqueWithoutInspectorInput>
    updateMany?: Enumerable<InProcessInspectRecordUpdateManyWithWhereWithoutInspectorInput>
    deleteMany?: Enumerable<InProcessInspectRecordScalarWhereInput>
  }

  export type InProcessInspectRecordUpdateManyWithoutReviewerNestedInput = {
    create?: XOR<Enumerable<InProcessInspectRecordCreateWithoutReviewerInput>, Enumerable<InProcessInspectRecordUncheckedCreateWithoutReviewerInput>>
    connectOrCreate?: Enumerable<InProcessInspectRecordCreateOrConnectWithoutReviewerInput>
    upsert?: Enumerable<InProcessInspectRecordUpsertWithWhereUniqueWithoutReviewerInput>
    createMany?: InProcessInspectRecordCreateManyReviewerInputEnvelope
    set?: Enumerable<InProcessInspectRecordWhereUniqueInput>
    disconnect?: Enumerable<InProcessInspectRecordWhereUniqueInput>
    delete?: Enumerable<InProcessInspectRecordWhereUniqueInput>
    connect?: Enumerable<InProcessInspectRecordWhereUniqueInput>
    update?: Enumerable<InProcessInspectRecordUpdateWithWhereUniqueWithoutReviewerInput>
    updateMany?: Enumerable<InProcessInspectRecordUpdateManyWithWhereWithoutReviewerInput>
    deleteMany?: Enumerable<InProcessInspectRecordScalarWhereInput>
  }

  export type UserProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutUserInput
    upsert?: UserProfileUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserProfileWhereUniqueInput
    update?: XOR<UserProfileUpdateWithoutUserInput, UserProfileUncheckedUpdateWithoutUserInput>
  }

  export type IncomingInspectRecordUncheckedUpdateManyWithoutInspectorNestedInput = {
    create?: XOR<Enumerable<IncomingInspectRecordCreateWithoutInspectorInput>, Enumerable<IncomingInspectRecordUncheckedCreateWithoutInspectorInput>>
    connectOrCreate?: Enumerable<IncomingInspectRecordCreateOrConnectWithoutInspectorInput>
    upsert?: Enumerable<IncomingInspectRecordUpsertWithWhereUniqueWithoutInspectorInput>
    createMany?: IncomingInspectRecordCreateManyInspectorInputEnvelope
    set?: Enumerable<IncomingInspectRecordWhereUniqueInput>
    disconnect?: Enumerable<IncomingInspectRecordWhereUniqueInput>
    delete?: Enumerable<IncomingInspectRecordWhereUniqueInput>
    connect?: Enumerable<IncomingInspectRecordWhereUniqueInput>
    update?: Enumerable<IncomingInspectRecordUpdateWithWhereUniqueWithoutInspectorInput>
    updateMany?: Enumerable<IncomingInspectRecordUpdateManyWithWhereWithoutInspectorInput>
    deleteMany?: Enumerable<IncomingInspectRecordScalarWhereInput>
  }

  export type IncomingInspectRecordUncheckedUpdateManyWithoutReviewerNestedInput = {
    create?: XOR<Enumerable<IncomingInspectRecordCreateWithoutReviewerInput>, Enumerable<IncomingInspectRecordUncheckedCreateWithoutReviewerInput>>
    connectOrCreate?: Enumerable<IncomingInspectRecordCreateOrConnectWithoutReviewerInput>
    upsert?: Enumerable<IncomingInspectRecordUpsertWithWhereUniqueWithoutReviewerInput>
    createMany?: IncomingInspectRecordCreateManyReviewerInputEnvelope
    set?: Enumerable<IncomingInspectRecordWhereUniqueInput>
    disconnect?: Enumerable<IncomingInspectRecordWhereUniqueInput>
    delete?: Enumerable<IncomingInspectRecordWhereUniqueInput>
    connect?: Enumerable<IncomingInspectRecordWhereUniqueInput>
    update?: Enumerable<IncomingInspectRecordUpdateWithWhereUniqueWithoutReviewerInput>
    updateMany?: Enumerable<IncomingInspectRecordUpdateManyWithWhereWithoutReviewerInput>
    deleteMany?: Enumerable<IncomingInspectRecordScalarWhereInput>
  }

  export type InProcessInspectRecordUncheckedUpdateManyWithoutInspectorNestedInput = {
    create?: XOR<Enumerable<InProcessInspectRecordCreateWithoutInspectorInput>, Enumerable<InProcessInspectRecordUncheckedCreateWithoutInspectorInput>>
    connectOrCreate?: Enumerable<InProcessInspectRecordCreateOrConnectWithoutInspectorInput>
    upsert?: Enumerable<InProcessInspectRecordUpsertWithWhereUniqueWithoutInspectorInput>
    createMany?: InProcessInspectRecordCreateManyInspectorInputEnvelope
    set?: Enumerable<InProcessInspectRecordWhereUniqueInput>
    disconnect?: Enumerable<InProcessInspectRecordWhereUniqueInput>
    delete?: Enumerable<InProcessInspectRecordWhereUniqueInput>
    connect?: Enumerable<InProcessInspectRecordWhereUniqueInput>
    update?: Enumerable<InProcessInspectRecordUpdateWithWhereUniqueWithoutInspectorInput>
    updateMany?: Enumerable<InProcessInspectRecordUpdateManyWithWhereWithoutInspectorInput>
    deleteMany?: Enumerable<InProcessInspectRecordScalarWhereInput>
  }

  export type InProcessInspectRecordUncheckedUpdateManyWithoutReviewerNestedInput = {
    create?: XOR<Enumerable<InProcessInspectRecordCreateWithoutReviewerInput>, Enumerable<InProcessInspectRecordUncheckedCreateWithoutReviewerInput>>
    connectOrCreate?: Enumerable<InProcessInspectRecordCreateOrConnectWithoutReviewerInput>
    upsert?: Enumerable<InProcessInspectRecordUpsertWithWhereUniqueWithoutReviewerInput>
    createMany?: InProcessInspectRecordCreateManyReviewerInputEnvelope
    set?: Enumerable<InProcessInspectRecordWhereUniqueInput>
    disconnect?: Enumerable<InProcessInspectRecordWhereUniqueInput>
    delete?: Enumerable<InProcessInspectRecordWhereUniqueInput>
    connect?: Enumerable<InProcessInspectRecordWhereUniqueInput>
    update?: Enumerable<InProcessInspectRecordUpdateWithWhereUniqueWithoutReviewerInput>
    updateMany?: Enumerable<InProcessInspectRecordUpdateManyWithWhereWithoutReviewerInput>
    deleteMany?: Enumerable<InProcessInspectRecordScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutProfileInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutProfileNestedInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    upsert?: UserUpsertWithoutProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
  }

  export type EquipmentCreateNestedManyWithoutProductLineInput = {
    create?: XOR<Enumerable<EquipmentCreateWithoutProductLineInput>, Enumerable<EquipmentUncheckedCreateWithoutProductLineInput>>
    connectOrCreate?: Enumerable<EquipmentCreateOrConnectWithoutProductLineInput>
    createMany?: EquipmentCreateManyProductLineInputEnvelope
    connect?: Enumerable<EquipmentWhereUniqueInput>
  }

  export type EquipmentUncheckedCreateNestedManyWithoutProductLineInput = {
    create?: XOR<Enumerable<EquipmentCreateWithoutProductLineInput>, Enumerable<EquipmentUncheckedCreateWithoutProductLineInput>>
    connectOrCreate?: Enumerable<EquipmentCreateOrConnectWithoutProductLineInput>
    createMany?: EquipmentCreateManyProductLineInputEnvelope
    connect?: Enumerable<EquipmentWhereUniqueInput>
  }

  export type EquipmentUpdateManyWithoutProductLineNestedInput = {
    create?: XOR<Enumerable<EquipmentCreateWithoutProductLineInput>, Enumerable<EquipmentUncheckedCreateWithoutProductLineInput>>
    connectOrCreate?: Enumerable<EquipmentCreateOrConnectWithoutProductLineInput>
    upsert?: Enumerable<EquipmentUpsertWithWhereUniqueWithoutProductLineInput>
    createMany?: EquipmentCreateManyProductLineInputEnvelope
    set?: Enumerable<EquipmentWhereUniqueInput>
    disconnect?: Enumerable<EquipmentWhereUniqueInput>
    delete?: Enumerable<EquipmentWhereUniqueInput>
    connect?: Enumerable<EquipmentWhereUniqueInput>
    update?: Enumerable<EquipmentUpdateWithWhereUniqueWithoutProductLineInput>
    updateMany?: Enumerable<EquipmentUpdateManyWithWhereWithoutProductLineInput>
    deleteMany?: Enumerable<EquipmentScalarWhereInput>
  }

  export type EquipmentUncheckedUpdateManyWithoutProductLineNestedInput = {
    create?: XOR<Enumerable<EquipmentCreateWithoutProductLineInput>, Enumerable<EquipmentUncheckedCreateWithoutProductLineInput>>
    connectOrCreate?: Enumerable<EquipmentCreateOrConnectWithoutProductLineInput>
    upsert?: Enumerable<EquipmentUpsertWithWhereUniqueWithoutProductLineInput>
    createMany?: EquipmentCreateManyProductLineInputEnvelope
    set?: Enumerable<EquipmentWhereUniqueInput>
    disconnect?: Enumerable<EquipmentWhereUniqueInput>
    delete?: Enumerable<EquipmentWhereUniqueInput>
    connect?: Enumerable<EquipmentWhereUniqueInput>
    update?: Enumerable<EquipmentUpdateWithWhereUniqueWithoutProductLineInput>
    updateMany?: Enumerable<EquipmentUpdateManyWithWhereWithoutProductLineInput>
    deleteMany?: Enumerable<EquipmentScalarWhereInput>
  }

  export type RepairPlanCreateNestedOneWithoutEquipmentInput = {
    create?: XOR<RepairPlanCreateWithoutEquipmentInput, RepairPlanUncheckedCreateWithoutEquipmentInput>
    connectOrCreate?: RepairPlanCreateOrConnectWithoutEquipmentInput
    connect?: RepairPlanWhereUniqueInput
  }

  export type RepairRecordCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<Enumerable<RepairRecordCreateWithoutEquipmentInput>, Enumerable<RepairRecordUncheckedCreateWithoutEquipmentInput>>
    connectOrCreate?: Enumerable<RepairRecordCreateOrConnectWithoutEquipmentInput>
    createMany?: RepairRecordCreateManyEquipmentInputEnvelope
    connect?: Enumerable<RepairRecordWhereUniqueInput>
  }

  export type ProductLineCreateNestedOneWithoutEquipmentInput = {
    create?: XOR<ProductLineCreateWithoutEquipmentInput, ProductLineUncheckedCreateWithoutEquipmentInput>
    connectOrCreate?: ProductLineCreateOrConnectWithoutEquipmentInput
    connect?: ProductLineWhereUniqueInput
  }

  export type RepairPlanUncheckedCreateNestedOneWithoutEquipmentInput = {
    create?: XOR<RepairPlanCreateWithoutEquipmentInput, RepairPlanUncheckedCreateWithoutEquipmentInput>
    connectOrCreate?: RepairPlanCreateOrConnectWithoutEquipmentInput
    connect?: RepairPlanWhereUniqueInput
  }

  export type RepairRecordUncheckedCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<Enumerable<RepairRecordCreateWithoutEquipmentInput>, Enumerable<RepairRecordUncheckedCreateWithoutEquipmentInput>>
    connectOrCreate?: Enumerable<RepairRecordCreateOrConnectWithoutEquipmentInput>
    createMany?: RepairRecordCreateManyEquipmentInputEnvelope
    connect?: Enumerable<RepairRecordWhereUniqueInput>
  }

  export type RepairPlanUpdateOneWithoutEquipmentNestedInput = {
    create?: XOR<RepairPlanCreateWithoutEquipmentInput, RepairPlanUncheckedCreateWithoutEquipmentInput>
    connectOrCreate?: RepairPlanCreateOrConnectWithoutEquipmentInput
    upsert?: RepairPlanUpsertWithoutEquipmentInput
    disconnect?: boolean
    delete?: boolean
    connect?: RepairPlanWhereUniqueInput
    update?: XOR<RepairPlanUpdateWithoutEquipmentInput, RepairPlanUncheckedUpdateWithoutEquipmentInput>
  }

  export type RepairRecordUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<Enumerable<RepairRecordCreateWithoutEquipmentInput>, Enumerable<RepairRecordUncheckedCreateWithoutEquipmentInput>>
    connectOrCreate?: Enumerable<RepairRecordCreateOrConnectWithoutEquipmentInput>
    upsert?: Enumerable<RepairRecordUpsertWithWhereUniqueWithoutEquipmentInput>
    createMany?: RepairRecordCreateManyEquipmentInputEnvelope
    set?: Enumerable<RepairRecordWhereUniqueInput>
    disconnect?: Enumerable<RepairRecordWhereUniqueInput>
    delete?: Enumerable<RepairRecordWhereUniqueInput>
    connect?: Enumerable<RepairRecordWhereUniqueInput>
    update?: Enumerable<RepairRecordUpdateWithWhereUniqueWithoutEquipmentInput>
    updateMany?: Enumerable<RepairRecordUpdateManyWithWhereWithoutEquipmentInput>
    deleteMany?: Enumerable<RepairRecordScalarWhereInput>
  }

  export type ProductLineUpdateOneWithoutEquipmentNestedInput = {
    create?: XOR<ProductLineCreateWithoutEquipmentInput, ProductLineUncheckedCreateWithoutEquipmentInput>
    connectOrCreate?: ProductLineCreateOrConnectWithoutEquipmentInput
    upsert?: ProductLineUpsertWithoutEquipmentInput
    disconnect?: boolean
    delete?: boolean
    connect?: ProductLineWhereUniqueInput
    update?: XOR<ProductLineUpdateWithoutEquipmentInput, ProductLineUncheckedUpdateWithoutEquipmentInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type RepairPlanUncheckedUpdateOneWithoutEquipmentNestedInput = {
    create?: XOR<RepairPlanCreateWithoutEquipmentInput, RepairPlanUncheckedCreateWithoutEquipmentInput>
    connectOrCreate?: RepairPlanCreateOrConnectWithoutEquipmentInput
    upsert?: RepairPlanUpsertWithoutEquipmentInput
    disconnect?: boolean
    delete?: boolean
    connect?: RepairPlanWhereUniqueInput
    update?: XOR<RepairPlanUpdateWithoutEquipmentInput, RepairPlanUncheckedUpdateWithoutEquipmentInput>
  }

  export type RepairRecordUncheckedUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<Enumerable<RepairRecordCreateWithoutEquipmentInput>, Enumerable<RepairRecordUncheckedCreateWithoutEquipmentInput>>
    connectOrCreate?: Enumerable<RepairRecordCreateOrConnectWithoutEquipmentInput>
    upsert?: Enumerable<RepairRecordUpsertWithWhereUniqueWithoutEquipmentInput>
    createMany?: RepairRecordCreateManyEquipmentInputEnvelope
    set?: Enumerable<RepairRecordWhereUniqueInput>
    disconnect?: Enumerable<RepairRecordWhereUniqueInput>
    delete?: Enumerable<RepairRecordWhereUniqueInput>
    connect?: Enumerable<RepairRecordWhereUniqueInput>
    update?: Enumerable<RepairRecordUpdateWithWhereUniqueWithoutEquipmentInput>
    updateMany?: Enumerable<RepairRecordUpdateManyWithWhereWithoutEquipmentInput>
    deleteMany?: Enumerable<RepairRecordScalarWhereInput>
  }

  export type RepairMaterialInventoryCreateNestedOneWithoutRepairMaterialInput = {
    create?: XOR<RepairMaterialInventoryCreateWithoutRepairMaterialInput, RepairMaterialInventoryUncheckedCreateWithoutRepairMaterialInput>
    connectOrCreate?: RepairMaterialInventoryCreateOrConnectWithoutRepairMaterialInput
    connect?: RepairMaterialInventoryWhereUniqueInput
  }

  export type RepairMaterialInventoryUncheckedCreateNestedOneWithoutRepairMaterialInput = {
    create?: XOR<RepairMaterialInventoryCreateWithoutRepairMaterialInput, RepairMaterialInventoryUncheckedCreateWithoutRepairMaterialInput>
    connectOrCreate?: RepairMaterialInventoryCreateOrConnectWithoutRepairMaterialInput
    connect?: RepairMaterialInventoryWhereUniqueInput
  }

  export type RepairMaterialInventoryUpdateOneWithoutRepairMaterialNestedInput = {
    create?: XOR<RepairMaterialInventoryCreateWithoutRepairMaterialInput, RepairMaterialInventoryUncheckedCreateWithoutRepairMaterialInput>
    connectOrCreate?: RepairMaterialInventoryCreateOrConnectWithoutRepairMaterialInput
    upsert?: RepairMaterialInventoryUpsertWithoutRepairMaterialInput
    disconnect?: boolean
    delete?: boolean
    connect?: RepairMaterialInventoryWhereUniqueInput
    update?: XOR<RepairMaterialInventoryUpdateWithoutRepairMaterialInput, RepairMaterialInventoryUncheckedUpdateWithoutRepairMaterialInput>
  }

  export type RepairMaterialInventoryUncheckedUpdateOneWithoutRepairMaterialNestedInput = {
    create?: XOR<RepairMaterialInventoryCreateWithoutRepairMaterialInput, RepairMaterialInventoryUncheckedCreateWithoutRepairMaterialInput>
    connectOrCreate?: RepairMaterialInventoryCreateOrConnectWithoutRepairMaterialInput
    upsert?: RepairMaterialInventoryUpsertWithoutRepairMaterialInput
    disconnect?: boolean
    delete?: boolean
    connect?: RepairMaterialInventoryWhereUniqueInput
    update?: XOR<RepairMaterialInventoryUpdateWithoutRepairMaterialInput, RepairMaterialInventoryUncheckedUpdateWithoutRepairMaterialInput>
  }

  export type EquipmentCreateNestedOneWithoutPlanInput = {
    create?: XOR<EquipmentCreateWithoutPlanInput, EquipmentUncheckedCreateWithoutPlanInput>
    connectOrCreate?: EquipmentCreateOrConnectWithoutPlanInput
    connect?: EquipmentWhereUniqueInput
  }

  export type EquipmentUpdateOneRequiredWithoutPlanNestedInput = {
    create?: XOR<EquipmentCreateWithoutPlanInput, EquipmentUncheckedCreateWithoutPlanInput>
    connectOrCreate?: EquipmentCreateOrConnectWithoutPlanInput
    upsert?: EquipmentUpsertWithoutPlanInput
    connect?: EquipmentWhereUniqueInput
    update?: XOR<EquipmentUpdateWithoutPlanInput, EquipmentUncheckedUpdateWithoutPlanInput>
  }

  export type RepairMaterialCreateNestedOneWithoutInventoryInput = {
    create?: XOR<RepairMaterialCreateWithoutInventoryInput, RepairMaterialUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: RepairMaterialCreateOrConnectWithoutInventoryInput
    connect?: RepairMaterialWhereUniqueInput
  }

  export type RepairMaterialUpdateOneRequiredWithoutInventoryNestedInput = {
    create?: XOR<RepairMaterialCreateWithoutInventoryInput, RepairMaterialUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: RepairMaterialCreateOrConnectWithoutInventoryInput
    upsert?: RepairMaterialUpsertWithoutInventoryInput
    connect?: RepairMaterialWhereUniqueInput
    update?: XOR<RepairMaterialUpdateWithoutInventoryInput, RepairMaterialUncheckedUpdateWithoutInventoryInput>
  }

  export type EquipmentCreateNestedOneWithoutRecordsInput = {
    create?: XOR<EquipmentCreateWithoutRecordsInput, EquipmentUncheckedCreateWithoutRecordsInput>
    connectOrCreate?: EquipmentCreateOrConnectWithoutRecordsInput
    connect?: EquipmentWhereUniqueInput
  }

  export type NullableEnumRepairRecordStatusFieldUpdateOperationsInput = {
    set?: RepairRecordStatus | null
  }

  export type EnumRepairTypeFieldUpdateOperationsInput = {
    set?: RepairType
  }

  export type EquipmentUpdateOneRequiredWithoutRecordsNestedInput = {
    create?: XOR<EquipmentCreateWithoutRecordsInput, EquipmentUncheckedCreateWithoutRecordsInput>
    connectOrCreate?: EquipmentCreateOrConnectWithoutRecordsInput
    upsert?: EquipmentUpsertWithoutRecordsInput
    connect?: EquipmentWhereUniqueInput
    update?: XOR<EquipmentUpdateWithoutRecordsInput, EquipmentUncheckedUpdateWithoutRecordsInput>
  }

  export type MaterialSpecCreateNestedManyWithoutMaterialInput = {
    create?: XOR<Enumerable<MaterialSpecCreateWithoutMaterialInput>, Enumerable<MaterialSpecUncheckedCreateWithoutMaterialInput>>
    connectOrCreate?: Enumerable<MaterialSpecCreateOrConnectWithoutMaterialInput>
    createMany?: MaterialSpecCreateManyMaterialInputEnvelope
    connect?: Enumerable<MaterialSpecWhereUniqueInput>
  }

  export type OperationCreateNestedManyWithoutMaterialInput = {
    create?: XOR<Enumerable<OperationCreateWithoutMaterialInput>, Enumerable<OperationUncheckedCreateWithoutMaterialInput>>
    connectOrCreate?: Enumerable<OperationCreateOrConnectWithoutMaterialInput>
    createMany?: OperationCreateManyMaterialInputEnvelope
    connect?: Enumerable<OperationWhereUniqueInput>
  }

  export type IncomingInspectRecordCreateNestedManyWithoutMaterialInput = {
    create?: XOR<Enumerable<IncomingInspectRecordCreateWithoutMaterialInput>, Enumerable<IncomingInspectRecordUncheckedCreateWithoutMaterialInput>>
    connectOrCreate?: Enumerable<IncomingInspectRecordCreateOrConnectWithoutMaterialInput>
    createMany?: IncomingInspectRecordCreateManyMaterialInputEnvelope
    connect?: Enumerable<IncomingInspectRecordWhereUniqueInput>
  }

  export type InProcessInspectRecordCreateNestedManyWithoutMaterialInput = {
    create?: XOR<Enumerable<InProcessInspectRecordCreateWithoutMaterialInput>, Enumerable<InProcessInspectRecordUncheckedCreateWithoutMaterialInput>>
    connectOrCreate?: Enumerable<InProcessInspectRecordCreateOrConnectWithoutMaterialInput>
    createMany?: InProcessInspectRecordCreateManyMaterialInputEnvelope
    connect?: Enumerable<InProcessInspectRecordWhereUniqueInput>
  }

  export type MaterialSpecUncheckedCreateNestedManyWithoutMaterialInput = {
    create?: XOR<Enumerable<MaterialSpecCreateWithoutMaterialInput>, Enumerable<MaterialSpecUncheckedCreateWithoutMaterialInput>>
    connectOrCreate?: Enumerable<MaterialSpecCreateOrConnectWithoutMaterialInput>
    createMany?: MaterialSpecCreateManyMaterialInputEnvelope
    connect?: Enumerable<MaterialSpecWhereUniqueInput>
  }

  export type OperationUncheckedCreateNestedManyWithoutMaterialInput = {
    create?: XOR<Enumerable<OperationCreateWithoutMaterialInput>, Enumerable<OperationUncheckedCreateWithoutMaterialInput>>
    connectOrCreate?: Enumerable<OperationCreateOrConnectWithoutMaterialInput>
    createMany?: OperationCreateManyMaterialInputEnvelope
    connect?: Enumerable<OperationWhereUniqueInput>
  }

  export type IncomingInspectRecordUncheckedCreateNestedManyWithoutMaterialInput = {
    create?: XOR<Enumerable<IncomingInspectRecordCreateWithoutMaterialInput>, Enumerable<IncomingInspectRecordUncheckedCreateWithoutMaterialInput>>
    connectOrCreate?: Enumerable<IncomingInspectRecordCreateOrConnectWithoutMaterialInput>
    createMany?: IncomingInspectRecordCreateManyMaterialInputEnvelope
    connect?: Enumerable<IncomingInspectRecordWhereUniqueInput>
  }

  export type InProcessInspectRecordUncheckedCreateNestedManyWithoutMaterialInput = {
    create?: XOR<Enumerable<InProcessInspectRecordCreateWithoutMaterialInput>, Enumerable<InProcessInspectRecordUncheckedCreateWithoutMaterialInput>>
    connectOrCreate?: Enumerable<InProcessInspectRecordCreateOrConnectWithoutMaterialInput>
    createMany?: InProcessInspectRecordCreateManyMaterialInputEnvelope
    connect?: Enumerable<InProcessInspectRecordWhereUniqueInput>
  }

  export type MaterialSpecUpdateManyWithoutMaterialNestedInput = {
    create?: XOR<Enumerable<MaterialSpecCreateWithoutMaterialInput>, Enumerable<MaterialSpecUncheckedCreateWithoutMaterialInput>>
    connectOrCreate?: Enumerable<MaterialSpecCreateOrConnectWithoutMaterialInput>
    upsert?: Enumerable<MaterialSpecUpsertWithWhereUniqueWithoutMaterialInput>
    createMany?: MaterialSpecCreateManyMaterialInputEnvelope
    set?: Enumerable<MaterialSpecWhereUniqueInput>
    disconnect?: Enumerable<MaterialSpecWhereUniqueInput>
    delete?: Enumerable<MaterialSpecWhereUniqueInput>
    connect?: Enumerable<MaterialSpecWhereUniqueInput>
    update?: Enumerable<MaterialSpecUpdateWithWhereUniqueWithoutMaterialInput>
    updateMany?: Enumerable<MaterialSpecUpdateManyWithWhereWithoutMaterialInput>
    deleteMany?: Enumerable<MaterialSpecScalarWhereInput>
  }

  export type OperationUpdateManyWithoutMaterialNestedInput = {
    create?: XOR<Enumerable<OperationCreateWithoutMaterialInput>, Enumerable<OperationUncheckedCreateWithoutMaterialInput>>
    connectOrCreate?: Enumerable<OperationCreateOrConnectWithoutMaterialInput>
    upsert?: Enumerable<OperationUpsertWithWhereUniqueWithoutMaterialInput>
    createMany?: OperationCreateManyMaterialInputEnvelope
    set?: Enumerable<OperationWhereUniqueInput>
    disconnect?: Enumerable<OperationWhereUniqueInput>
    delete?: Enumerable<OperationWhereUniqueInput>
    connect?: Enumerable<OperationWhereUniqueInput>
    update?: Enumerable<OperationUpdateWithWhereUniqueWithoutMaterialInput>
    updateMany?: Enumerable<OperationUpdateManyWithWhereWithoutMaterialInput>
    deleteMany?: Enumerable<OperationScalarWhereInput>
  }

  export type IncomingInspectRecordUpdateManyWithoutMaterialNestedInput = {
    create?: XOR<Enumerable<IncomingInspectRecordCreateWithoutMaterialInput>, Enumerable<IncomingInspectRecordUncheckedCreateWithoutMaterialInput>>
    connectOrCreate?: Enumerable<IncomingInspectRecordCreateOrConnectWithoutMaterialInput>
    upsert?: Enumerable<IncomingInspectRecordUpsertWithWhereUniqueWithoutMaterialInput>
    createMany?: IncomingInspectRecordCreateManyMaterialInputEnvelope
    set?: Enumerable<IncomingInspectRecordWhereUniqueInput>
    disconnect?: Enumerable<IncomingInspectRecordWhereUniqueInput>
    delete?: Enumerable<IncomingInspectRecordWhereUniqueInput>
    connect?: Enumerable<IncomingInspectRecordWhereUniqueInput>
    update?: Enumerable<IncomingInspectRecordUpdateWithWhereUniqueWithoutMaterialInput>
    updateMany?: Enumerable<IncomingInspectRecordUpdateManyWithWhereWithoutMaterialInput>
    deleteMany?: Enumerable<IncomingInspectRecordScalarWhereInput>
  }

  export type InProcessInspectRecordUpdateManyWithoutMaterialNestedInput = {
    create?: XOR<Enumerable<InProcessInspectRecordCreateWithoutMaterialInput>, Enumerable<InProcessInspectRecordUncheckedCreateWithoutMaterialInput>>
    connectOrCreate?: Enumerable<InProcessInspectRecordCreateOrConnectWithoutMaterialInput>
    upsert?: Enumerable<InProcessInspectRecordUpsertWithWhereUniqueWithoutMaterialInput>
    createMany?: InProcessInspectRecordCreateManyMaterialInputEnvelope
    set?: Enumerable<InProcessInspectRecordWhereUniqueInput>
    disconnect?: Enumerable<InProcessInspectRecordWhereUniqueInput>
    delete?: Enumerable<InProcessInspectRecordWhereUniqueInput>
    connect?: Enumerable<InProcessInspectRecordWhereUniqueInput>
    update?: Enumerable<InProcessInspectRecordUpdateWithWhereUniqueWithoutMaterialInput>
    updateMany?: Enumerable<InProcessInspectRecordUpdateManyWithWhereWithoutMaterialInput>
    deleteMany?: Enumerable<InProcessInspectRecordScalarWhereInput>
  }

  export type MaterialSpecUncheckedUpdateManyWithoutMaterialNestedInput = {
    create?: XOR<Enumerable<MaterialSpecCreateWithoutMaterialInput>, Enumerable<MaterialSpecUncheckedCreateWithoutMaterialInput>>
    connectOrCreate?: Enumerable<MaterialSpecCreateOrConnectWithoutMaterialInput>
    upsert?: Enumerable<MaterialSpecUpsertWithWhereUniqueWithoutMaterialInput>
    createMany?: MaterialSpecCreateManyMaterialInputEnvelope
    set?: Enumerable<MaterialSpecWhereUniqueInput>
    disconnect?: Enumerable<MaterialSpecWhereUniqueInput>
    delete?: Enumerable<MaterialSpecWhereUniqueInput>
    connect?: Enumerable<MaterialSpecWhereUniqueInput>
    update?: Enumerable<MaterialSpecUpdateWithWhereUniqueWithoutMaterialInput>
    updateMany?: Enumerable<MaterialSpecUpdateManyWithWhereWithoutMaterialInput>
    deleteMany?: Enumerable<MaterialSpecScalarWhereInput>
  }

  export type OperationUncheckedUpdateManyWithoutMaterialNestedInput = {
    create?: XOR<Enumerable<OperationCreateWithoutMaterialInput>, Enumerable<OperationUncheckedCreateWithoutMaterialInput>>
    connectOrCreate?: Enumerable<OperationCreateOrConnectWithoutMaterialInput>
    upsert?: Enumerable<OperationUpsertWithWhereUniqueWithoutMaterialInput>
    createMany?: OperationCreateManyMaterialInputEnvelope
    set?: Enumerable<OperationWhereUniqueInput>
    disconnect?: Enumerable<OperationWhereUniqueInput>
    delete?: Enumerable<OperationWhereUniqueInput>
    connect?: Enumerable<OperationWhereUniqueInput>
    update?: Enumerable<OperationUpdateWithWhereUniqueWithoutMaterialInput>
    updateMany?: Enumerable<OperationUpdateManyWithWhereWithoutMaterialInput>
    deleteMany?: Enumerable<OperationScalarWhereInput>
  }

  export type IncomingInspectRecordUncheckedUpdateManyWithoutMaterialNestedInput = {
    create?: XOR<Enumerable<IncomingInspectRecordCreateWithoutMaterialInput>, Enumerable<IncomingInspectRecordUncheckedCreateWithoutMaterialInput>>
    connectOrCreate?: Enumerable<IncomingInspectRecordCreateOrConnectWithoutMaterialInput>
    upsert?: Enumerable<IncomingInspectRecordUpsertWithWhereUniqueWithoutMaterialInput>
    createMany?: IncomingInspectRecordCreateManyMaterialInputEnvelope
    set?: Enumerable<IncomingInspectRecordWhereUniqueInput>
    disconnect?: Enumerable<IncomingInspectRecordWhereUniqueInput>
    delete?: Enumerable<IncomingInspectRecordWhereUniqueInput>
    connect?: Enumerable<IncomingInspectRecordWhereUniqueInput>
    update?: Enumerable<IncomingInspectRecordUpdateWithWhereUniqueWithoutMaterialInput>
    updateMany?: Enumerable<IncomingInspectRecordUpdateManyWithWhereWithoutMaterialInput>
    deleteMany?: Enumerable<IncomingInspectRecordScalarWhereInput>
  }

  export type InProcessInspectRecordUncheckedUpdateManyWithoutMaterialNestedInput = {
    create?: XOR<Enumerable<InProcessInspectRecordCreateWithoutMaterialInput>, Enumerable<InProcessInspectRecordUncheckedCreateWithoutMaterialInput>>
    connectOrCreate?: Enumerable<InProcessInspectRecordCreateOrConnectWithoutMaterialInput>
    upsert?: Enumerable<InProcessInspectRecordUpsertWithWhereUniqueWithoutMaterialInput>
    createMany?: InProcessInspectRecordCreateManyMaterialInputEnvelope
    set?: Enumerable<InProcessInspectRecordWhereUniqueInput>
    disconnect?: Enumerable<InProcessInspectRecordWhereUniqueInput>
    delete?: Enumerable<InProcessInspectRecordWhereUniqueInput>
    connect?: Enumerable<InProcessInspectRecordWhereUniqueInput>
    update?: Enumerable<InProcessInspectRecordUpdateWithWhereUniqueWithoutMaterialInput>
    updateMany?: Enumerable<InProcessInspectRecordUpdateManyWithWhereWithoutMaterialInput>
    deleteMany?: Enumerable<InProcessInspectRecordScalarWhereInput>
  }

  export type MaterialCreateNestedOneWithoutSpecsInput = {
    create?: XOR<MaterialCreateWithoutSpecsInput, MaterialUncheckedCreateWithoutSpecsInput>
    connectOrCreate?: MaterialCreateOrConnectWithoutSpecsInput
    connect?: MaterialWhereUniqueInput
  }

  export type MaterialSpecInspectCreateNestedManyWithoutSpecInput = {
    create?: XOR<Enumerable<MaterialSpecInspectCreateWithoutSpecInput>, Enumerable<MaterialSpecInspectUncheckedCreateWithoutSpecInput>>
    connectOrCreate?: Enumerable<MaterialSpecInspectCreateOrConnectWithoutSpecInput>
    createMany?: MaterialSpecInspectCreateManySpecInputEnvelope
    connect?: Enumerable<MaterialSpecInspectWhereUniqueInput>
  }

  export type MaterialSpecInspectUncheckedCreateNestedManyWithoutSpecInput = {
    create?: XOR<Enumerable<MaterialSpecInspectCreateWithoutSpecInput>, Enumerable<MaterialSpecInspectUncheckedCreateWithoutSpecInput>>
    connectOrCreate?: Enumerable<MaterialSpecInspectCreateOrConnectWithoutSpecInput>
    createMany?: MaterialSpecInspectCreateManySpecInputEnvelope
    connect?: Enumerable<MaterialSpecInspectWhereUniqueInput>
  }

  export type MaterialUpdateOneRequiredWithoutSpecsNestedInput = {
    create?: XOR<MaterialCreateWithoutSpecsInput, MaterialUncheckedCreateWithoutSpecsInput>
    connectOrCreate?: MaterialCreateOrConnectWithoutSpecsInput
    upsert?: MaterialUpsertWithoutSpecsInput
    connect?: MaterialWhereUniqueInput
    update?: XOR<MaterialUpdateWithoutSpecsInput, MaterialUncheckedUpdateWithoutSpecsInput>
  }

  export type MaterialSpecInspectUpdateManyWithoutSpecNestedInput = {
    create?: XOR<Enumerable<MaterialSpecInspectCreateWithoutSpecInput>, Enumerable<MaterialSpecInspectUncheckedCreateWithoutSpecInput>>
    connectOrCreate?: Enumerable<MaterialSpecInspectCreateOrConnectWithoutSpecInput>
    upsert?: Enumerable<MaterialSpecInspectUpsertWithWhereUniqueWithoutSpecInput>
    createMany?: MaterialSpecInspectCreateManySpecInputEnvelope
    set?: Enumerable<MaterialSpecInspectWhereUniqueInput>
    disconnect?: Enumerable<MaterialSpecInspectWhereUniqueInput>
    delete?: Enumerable<MaterialSpecInspectWhereUniqueInput>
    connect?: Enumerable<MaterialSpecInspectWhereUniqueInput>
    update?: Enumerable<MaterialSpecInspectUpdateWithWhereUniqueWithoutSpecInput>
    updateMany?: Enumerable<MaterialSpecInspectUpdateManyWithWhereWithoutSpecInput>
    deleteMany?: Enumerable<MaterialSpecInspectScalarWhereInput>
  }

  export type MaterialSpecInspectUncheckedUpdateManyWithoutSpecNestedInput = {
    create?: XOR<Enumerable<MaterialSpecInspectCreateWithoutSpecInput>, Enumerable<MaterialSpecInspectUncheckedCreateWithoutSpecInput>>
    connectOrCreate?: Enumerable<MaterialSpecInspectCreateOrConnectWithoutSpecInput>
    upsert?: Enumerable<MaterialSpecInspectUpsertWithWhereUniqueWithoutSpecInput>
    createMany?: MaterialSpecInspectCreateManySpecInputEnvelope
    set?: Enumerable<MaterialSpecInspectWhereUniqueInput>
    disconnect?: Enumerable<MaterialSpecInspectWhereUniqueInput>
    delete?: Enumerable<MaterialSpecInspectWhereUniqueInput>
    connect?: Enumerable<MaterialSpecInspectWhereUniqueInput>
    update?: Enumerable<MaterialSpecInspectUpdateWithWhereUniqueWithoutSpecInput>
    updateMany?: Enumerable<MaterialSpecInspectUpdateManyWithWhereWithoutSpecInput>
    deleteMany?: Enumerable<MaterialSpecInspectScalarWhereInput>
  }

  export type MaterialCreateNestedOneWithoutOperationsInput = {
    create?: XOR<MaterialCreateWithoutOperationsInput, MaterialUncheckedCreateWithoutOperationsInput>
    connectOrCreate?: MaterialCreateOrConnectWithoutOperationsInput
    connect?: MaterialWhereUniqueInput
  }

  export type OperationSpecCreateNestedManyWithoutOperationInput = {
    create?: XOR<Enumerable<OperationSpecCreateWithoutOperationInput>, Enumerable<OperationSpecUncheckedCreateWithoutOperationInput>>
    connectOrCreate?: Enumerable<OperationSpecCreateOrConnectWithoutOperationInput>
    createMany?: OperationSpecCreateManyOperationInputEnvelope
    connect?: Enumerable<OperationSpecWhereUniqueInput>
  }

  export type OperationSpecUncheckedCreateNestedManyWithoutOperationInput = {
    create?: XOR<Enumerable<OperationSpecCreateWithoutOperationInput>, Enumerable<OperationSpecUncheckedCreateWithoutOperationInput>>
    connectOrCreate?: Enumerable<OperationSpecCreateOrConnectWithoutOperationInput>
    createMany?: OperationSpecCreateManyOperationInputEnvelope
    connect?: Enumerable<OperationSpecWhereUniqueInput>
  }

  export type MaterialUpdateOneRequiredWithoutOperationsNestedInput = {
    create?: XOR<MaterialCreateWithoutOperationsInput, MaterialUncheckedCreateWithoutOperationsInput>
    connectOrCreate?: MaterialCreateOrConnectWithoutOperationsInput
    upsert?: MaterialUpsertWithoutOperationsInput
    connect?: MaterialWhereUniqueInput
    update?: XOR<MaterialUpdateWithoutOperationsInput, MaterialUncheckedUpdateWithoutOperationsInput>
  }

  export type OperationSpecUpdateManyWithoutOperationNestedInput = {
    create?: XOR<Enumerable<OperationSpecCreateWithoutOperationInput>, Enumerable<OperationSpecUncheckedCreateWithoutOperationInput>>
    connectOrCreate?: Enumerable<OperationSpecCreateOrConnectWithoutOperationInput>
    upsert?: Enumerable<OperationSpecUpsertWithWhereUniqueWithoutOperationInput>
    createMany?: OperationSpecCreateManyOperationInputEnvelope
    set?: Enumerable<OperationSpecWhereUniqueInput>
    disconnect?: Enumerable<OperationSpecWhereUniqueInput>
    delete?: Enumerable<OperationSpecWhereUniqueInput>
    connect?: Enumerable<OperationSpecWhereUniqueInput>
    update?: Enumerable<OperationSpecUpdateWithWhereUniqueWithoutOperationInput>
    updateMany?: Enumerable<OperationSpecUpdateManyWithWhereWithoutOperationInput>
    deleteMany?: Enumerable<OperationSpecScalarWhereInput>
  }

  export type OperationSpecUncheckedUpdateManyWithoutOperationNestedInput = {
    create?: XOR<Enumerable<OperationSpecCreateWithoutOperationInput>, Enumerable<OperationSpecUncheckedCreateWithoutOperationInput>>
    connectOrCreate?: Enumerable<OperationSpecCreateOrConnectWithoutOperationInput>
    upsert?: Enumerable<OperationSpecUpsertWithWhereUniqueWithoutOperationInput>
    createMany?: OperationSpecCreateManyOperationInputEnvelope
    set?: Enumerable<OperationSpecWhereUniqueInput>
    disconnect?: Enumerable<OperationSpecWhereUniqueInput>
    delete?: Enumerable<OperationSpecWhereUniqueInput>
    connect?: Enumerable<OperationSpecWhereUniqueInput>
    update?: Enumerable<OperationSpecUpdateWithWhereUniqueWithoutOperationInput>
    updateMany?: Enumerable<OperationSpecUpdateManyWithWhereWithoutOperationInput>
    deleteMany?: Enumerable<OperationSpecScalarWhereInput>
  }

  export type OperationCreateNestedOneWithoutSpecsInput = {
    create?: XOR<OperationCreateWithoutSpecsInput, OperationUncheckedCreateWithoutSpecsInput>
    connectOrCreate?: OperationCreateOrConnectWithoutSpecsInput
    connect?: OperationWhereUniqueInput
  }

  export type OperationSpecInspectCreateNestedManyWithoutSpecInput = {
    create?: XOR<Enumerable<OperationSpecInspectCreateWithoutSpecInput>, Enumerable<OperationSpecInspectUncheckedCreateWithoutSpecInput>>
    connectOrCreate?: Enumerable<OperationSpecInspectCreateOrConnectWithoutSpecInput>
    createMany?: OperationSpecInspectCreateManySpecInputEnvelope
    connect?: Enumerable<OperationSpecInspectWhereUniqueInput>
  }

  export type OperationSpecInspectUncheckedCreateNestedManyWithoutSpecInput = {
    create?: XOR<Enumerable<OperationSpecInspectCreateWithoutSpecInput>, Enumerable<OperationSpecInspectUncheckedCreateWithoutSpecInput>>
    connectOrCreate?: Enumerable<OperationSpecInspectCreateOrConnectWithoutSpecInput>
    createMany?: OperationSpecInspectCreateManySpecInputEnvelope
    connect?: Enumerable<OperationSpecInspectWhereUniqueInput>
  }

  export type OperationUpdateOneRequiredWithoutSpecsNestedInput = {
    create?: XOR<OperationCreateWithoutSpecsInput, OperationUncheckedCreateWithoutSpecsInput>
    connectOrCreate?: OperationCreateOrConnectWithoutSpecsInput
    upsert?: OperationUpsertWithoutSpecsInput
    connect?: OperationWhereUniqueInput
    update?: XOR<OperationUpdateWithoutSpecsInput, OperationUncheckedUpdateWithoutSpecsInput>
  }

  export type OperationSpecInspectUpdateManyWithoutSpecNestedInput = {
    create?: XOR<Enumerable<OperationSpecInspectCreateWithoutSpecInput>, Enumerable<OperationSpecInspectUncheckedCreateWithoutSpecInput>>
    connectOrCreate?: Enumerable<OperationSpecInspectCreateOrConnectWithoutSpecInput>
    upsert?: Enumerable<OperationSpecInspectUpsertWithWhereUniqueWithoutSpecInput>
    createMany?: OperationSpecInspectCreateManySpecInputEnvelope
    set?: Enumerable<OperationSpecInspectWhereUniqueInput>
    disconnect?: Enumerable<OperationSpecInspectWhereUniqueInput>
    delete?: Enumerable<OperationSpecInspectWhereUniqueInput>
    connect?: Enumerable<OperationSpecInspectWhereUniqueInput>
    update?: Enumerable<OperationSpecInspectUpdateWithWhereUniqueWithoutSpecInput>
    updateMany?: Enumerable<OperationSpecInspectUpdateManyWithWhereWithoutSpecInput>
    deleteMany?: Enumerable<OperationSpecInspectScalarWhereInput>
  }

  export type OperationSpecInspectUncheckedUpdateManyWithoutSpecNestedInput = {
    create?: XOR<Enumerable<OperationSpecInspectCreateWithoutSpecInput>, Enumerable<OperationSpecInspectUncheckedCreateWithoutSpecInput>>
    connectOrCreate?: Enumerable<OperationSpecInspectCreateOrConnectWithoutSpecInput>
    upsert?: Enumerable<OperationSpecInspectUpsertWithWhereUniqueWithoutSpecInput>
    createMany?: OperationSpecInspectCreateManySpecInputEnvelope
    set?: Enumerable<OperationSpecInspectWhereUniqueInput>
    disconnect?: Enumerable<OperationSpecInspectWhereUniqueInput>
    delete?: Enumerable<OperationSpecInspectWhereUniqueInput>
    connect?: Enumerable<OperationSpecInspectWhereUniqueInput>
    update?: Enumerable<OperationSpecInspectUpdateWithWhereUniqueWithoutSpecInput>
    updateMany?: Enumerable<OperationSpecInspectUpdateManyWithWhereWithoutSpecInput>
    deleteMany?: Enumerable<OperationSpecInspectScalarWhereInput>
  }

  export type MaterialCreateNestedOneWithoutIncomingInspectRecordInput = {
    create?: XOR<MaterialCreateWithoutIncomingInspectRecordInput, MaterialUncheckedCreateWithoutIncomingInspectRecordInput>
    connectOrCreate?: MaterialCreateOrConnectWithoutIncomingInspectRecordInput
    connect?: MaterialWhereUniqueInput
  }

  export type MaterialSpecInspectCreateNestedManyWithoutRecordInput = {
    create?: XOR<Enumerable<MaterialSpecInspectCreateWithoutRecordInput>, Enumerable<MaterialSpecInspectUncheckedCreateWithoutRecordInput>>
    connectOrCreate?: Enumerable<MaterialSpecInspectCreateOrConnectWithoutRecordInput>
    createMany?: MaterialSpecInspectCreateManyRecordInputEnvelope
    connect?: Enumerable<MaterialSpecInspectWhereUniqueInput>
  }

  export type UserCreateNestedOneWithoutIncomingInspectedRecordsInput = {
    create?: XOR<UserCreateWithoutIncomingInspectedRecordsInput, UserUncheckedCreateWithoutIncomingInspectedRecordsInput>
    connectOrCreate?: UserCreateOrConnectWithoutIncomingInspectedRecordsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutIncomingReviewedRecordsInput = {
    create?: XOR<UserCreateWithoutIncomingReviewedRecordsInput, UserUncheckedCreateWithoutIncomingReviewedRecordsInput>
    connectOrCreate?: UserCreateOrConnectWithoutIncomingReviewedRecordsInput
    connect?: UserWhereUniqueInput
  }

  export type MaterialSpecInspectUncheckedCreateNestedManyWithoutRecordInput = {
    create?: XOR<Enumerable<MaterialSpecInspectCreateWithoutRecordInput>, Enumerable<MaterialSpecInspectUncheckedCreateWithoutRecordInput>>
    connectOrCreate?: Enumerable<MaterialSpecInspectCreateOrConnectWithoutRecordInput>
    createMany?: MaterialSpecInspectCreateManyRecordInputEnvelope
    connect?: Enumerable<MaterialSpecInspectWhereUniqueInput>
  }

  export type EnumIncomingInspectResultFieldUpdateOperationsInput = {
    set?: IncomingInspectResult
  }

  export type MaterialUpdateOneRequiredWithoutIncomingInspectRecordNestedInput = {
    create?: XOR<MaterialCreateWithoutIncomingInspectRecordInput, MaterialUncheckedCreateWithoutIncomingInspectRecordInput>
    connectOrCreate?: MaterialCreateOrConnectWithoutIncomingInspectRecordInput
    upsert?: MaterialUpsertWithoutIncomingInspectRecordInput
    connect?: MaterialWhereUniqueInput
    update?: XOR<MaterialUpdateWithoutIncomingInspectRecordInput, MaterialUncheckedUpdateWithoutIncomingInspectRecordInput>
  }

  export type MaterialSpecInspectUpdateManyWithoutRecordNestedInput = {
    create?: XOR<Enumerable<MaterialSpecInspectCreateWithoutRecordInput>, Enumerable<MaterialSpecInspectUncheckedCreateWithoutRecordInput>>
    connectOrCreate?: Enumerable<MaterialSpecInspectCreateOrConnectWithoutRecordInput>
    upsert?: Enumerable<MaterialSpecInspectUpsertWithWhereUniqueWithoutRecordInput>
    createMany?: MaterialSpecInspectCreateManyRecordInputEnvelope
    set?: Enumerable<MaterialSpecInspectWhereUniqueInput>
    disconnect?: Enumerable<MaterialSpecInspectWhereUniqueInput>
    delete?: Enumerable<MaterialSpecInspectWhereUniqueInput>
    connect?: Enumerable<MaterialSpecInspectWhereUniqueInput>
    update?: Enumerable<MaterialSpecInspectUpdateWithWhereUniqueWithoutRecordInput>
    updateMany?: Enumerable<MaterialSpecInspectUpdateManyWithWhereWithoutRecordInput>
    deleteMany?: Enumerable<MaterialSpecInspectScalarWhereInput>
  }

  export type UserUpdateOneWithoutIncomingInspectedRecordsNestedInput = {
    create?: XOR<UserCreateWithoutIncomingInspectedRecordsInput, UserUncheckedCreateWithoutIncomingInspectedRecordsInput>
    connectOrCreate?: UserCreateOrConnectWithoutIncomingInspectedRecordsInput
    upsert?: UserUpsertWithoutIncomingInspectedRecordsInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutIncomingInspectedRecordsInput, UserUncheckedUpdateWithoutIncomingInspectedRecordsInput>
  }

  export type UserUpdateOneWithoutIncomingReviewedRecordsNestedInput = {
    create?: XOR<UserCreateWithoutIncomingReviewedRecordsInput, UserUncheckedCreateWithoutIncomingReviewedRecordsInput>
    connectOrCreate?: UserCreateOrConnectWithoutIncomingReviewedRecordsInput
    upsert?: UserUpsertWithoutIncomingReviewedRecordsInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutIncomingReviewedRecordsInput, UserUncheckedUpdateWithoutIncomingReviewedRecordsInput>
  }

  export type MaterialSpecInspectUncheckedUpdateManyWithoutRecordNestedInput = {
    create?: XOR<Enumerable<MaterialSpecInspectCreateWithoutRecordInput>, Enumerable<MaterialSpecInspectUncheckedCreateWithoutRecordInput>>
    connectOrCreate?: Enumerable<MaterialSpecInspectCreateOrConnectWithoutRecordInput>
    upsert?: Enumerable<MaterialSpecInspectUpsertWithWhereUniqueWithoutRecordInput>
    createMany?: MaterialSpecInspectCreateManyRecordInputEnvelope
    set?: Enumerable<MaterialSpecInspectWhereUniqueInput>
    disconnect?: Enumerable<MaterialSpecInspectWhereUniqueInput>
    delete?: Enumerable<MaterialSpecInspectWhereUniqueInput>
    connect?: Enumerable<MaterialSpecInspectWhereUniqueInput>
    update?: Enumerable<MaterialSpecInspectUpdateWithWhereUniqueWithoutRecordInput>
    updateMany?: Enumerable<MaterialSpecInspectUpdateManyWithWhereWithoutRecordInput>
    deleteMany?: Enumerable<MaterialSpecInspectScalarWhereInput>
  }

  export type IncomingInspectRecordCreateNestedOneWithoutDetailsInput = {
    create?: XOR<IncomingInspectRecordCreateWithoutDetailsInput, IncomingInspectRecordUncheckedCreateWithoutDetailsInput>
    connectOrCreate?: IncomingInspectRecordCreateOrConnectWithoutDetailsInput
    connect?: IncomingInspectRecordWhereUniqueInput
  }

  export type MaterialSpecCreateNestedOneWithoutInspectsInput = {
    create?: XOR<MaterialSpecCreateWithoutInspectsInput, MaterialSpecUncheckedCreateWithoutInspectsInput>
    connectOrCreate?: MaterialSpecCreateOrConnectWithoutInspectsInput
    connect?: MaterialSpecWhereUniqueInput
  }

  export type IncomingInspectRecordUpdateOneRequiredWithoutDetailsNestedInput = {
    create?: XOR<IncomingInspectRecordCreateWithoutDetailsInput, IncomingInspectRecordUncheckedCreateWithoutDetailsInput>
    connectOrCreate?: IncomingInspectRecordCreateOrConnectWithoutDetailsInput
    upsert?: IncomingInspectRecordUpsertWithoutDetailsInput
    connect?: IncomingInspectRecordWhereUniqueInput
    update?: XOR<IncomingInspectRecordUpdateWithoutDetailsInput, IncomingInspectRecordUncheckedUpdateWithoutDetailsInput>
  }

  export type MaterialSpecUpdateOneRequiredWithoutInspectsNestedInput = {
    create?: XOR<MaterialSpecCreateWithoutInspectsInput, MaterialSpecUncheckedCreateWithoutInspectsInput>
    connectOrCreate?: MaterialSpecCreateOrConnectWithoutInspectsInput
    upsert?: MaterialSpecUpsertWithoutInspectsInput
    connect?: MaterialSpecWhereUniqueInput
    update?: XOR<MaterialSpecUpdateWithoutInspectsInput, MaterialSpecUncheckedUpdateWithoutInspectsInput>
  }

  export type MaterialCreateNestedOneWithoutInProcessInspectRecordInput = {
    create?: XOR<MaterialCreateWithoutInProcessInspectRecordInput, MaterialUncheckedCreateWithoutInProcessInspectRecordInput>
    connectOrCreate?: MaterialCreateOrConnectWithoutInProcessInspectRecordInput
    connect?: MaterialWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutInProcessInspectedRecordInput = {
    create?: XOR<UserCreateWithoutInProcessInspectedRecordInput, UserUncheckedCreateWithoutInProcessInspectedRecordInput>
    connectOrCreate?: UserCreateOrConnectWithoutInProcessInspectedRecordInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutInProcessReviewedRecordInput = {
    create?: XOR<UserCreateWithoutInProcessReviewedRecordInput, UserUncheckedCreateWithoutInProcessReviewedRecordInput>
    connectOrCreate?: UserCreateOrConnectWithoutInProcessReviewedRecordInput
    connect?: UserWhereUniqueInput
  }

  export type MaterialUpdateOneRequiredWithoutInProcessInspectRecordNestedInput = {
    create?: XOR<MaterialCreateWithoutInProcessInspectRecordInput, MaterialUncheckedCreateWithoutInProcessInspectRecordInput>
    connectOrCreate?: MaterialCreateOrConnectWithoutInProcessInspectRecordInput
    upsert?: MaterialUpsertWithoutInProcessInspectRecordInput
    connect?: MaterialWhereUniqueInput
    update?: XOR<MaterialUpdateWithoutInProcessInspectRecordInput, MaterialUncheckedUpdateWithoutInProcessInspectRecordInput>
  }

  export type UserUpdateOneWithoutInProcessInspectedRecordNestedInput = {
    create?: XOR<UserCreateWithoutInProcessInspectedRecordInput, UserUncheckedCreateWithoutInProcessInspectedRecordInput>
    connectOrCreate?: UserCreateOrConnectWithoutInProcessInspectedRecordInput
    upsert?: UserUpsertWithoutInProcessInspectedRecordInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutInProcessInspectedRecordInput, UserUncheckedUpdateWithoutInProcessInspectedRecordInput>
  }

  export type UserUpdateOneWithoutInProcessReviewedRecordNestedInput = {
    create?: XOR<UserCreateWithoutInProcessReviewedRecordInput, UserUncheckedCreateWithoutInProcessReviewedRecordInput>
    connectOrCreate?: UserCreateOrConnectWithoutInProcessReviewedRecordInput
    upsert?: UserUpsertWithoutInProcessReviewedRecordInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutInProcessReviewedRecordInput, UserUncheckedUpdateWithoutInProcessReviewedRecordInput>
  }

  export type OperationSpecCreateNestedOneWithoutInspectInput = {
    create?: XOR<OperationSpecCreateWithoutInspectInput, OperationSpecUncheckedCreateWithoutInspectInput>
    connectOrCreate?: OperationSpecCreateOrConnectWithoutInspectInput
    connect?: OperationSpecWhereUniqueInput
  }

  export type OperationSpecUpdateOneRequiredWithoutInspectNestedInput = {
    create?: XOR<OperationSpecCreateWithoutInspectInput, OperationSpecUncheckedCreateWithoutInspectInput>
    connectOrCreate?: OperationSpecCreateOrConnectWithoutInspectInput
    upsert?: OperationSpecUpsertWithoutInspectInput
    connect?: OperationSpecWhereUniqueInput
    update?: XOR<OperationSpecUpdateWithoutInspectInput, OperationSpecUncheckedUpdateWithoutInspectInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedEnumUserStatusFilter = {
    equals?: UserStatus
    in?: Enumerable<UserStatus>
    notIn?: Enumerable<UserStatus>
    not?: NestedEnumUserStatusFilter | UserStatus
  }

  export type NestedEnumUserGroupFilter = {
    equals?: UserGroup
    in?: Enumerable<UserGroup>
    notIn?: Enumerable<UserGroup>
    not?: NestedEnumUserGroupFilter | UserGroup
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedEnumUserStatusWithAggregatesFilter = {
    equals?: UserStatus
    in?: Enumerable<UserStatus>
    notIn?: Enumerable<UserStatus>
    not?: NestedEnumUserStatusWithAggregatesFilter | UserStatus
    _count?: NestedIntFilter
    _min?: NestedEnumUserStatusFilter
    _max?: NestedEnumUserStatusFilter
  }

  export type NestedEnumUserGroupWithAggregatesFilter = {
    equals?: UserGroup
    in?: Enumerable<UserGroup>
    notIn?: Enumerable<UserGroup>
    not?: NestedEnumUserGroupWithAggregatesFilter | UserGroup
    _count?: NestedIntFilter
    _min?: NestedEnumUserGroupFilter
    _max?: NestedEnumUserGroupFilter
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedEnumRepairRecordStatusNullableFilter = {
    equals?: RepairRecordStatus | null
    in?: Enumerable<RepairRecordStatus> | null
    notIn?: Enumerable<RepairRecordStatus> | null
    not?: NestedEnumRepairRecordStatusNullableFilter | RepairRecordStatus | null
  }

  export type NestedEnumRepairTypeFilter = {
    equals?: RepairType
    in?: Enumerable<RepairType>
    notIn?: Enumerable<RepairType>
    not?: NestedEnumRepairTypeFilter | RepairType
  }

  export type NestedEnumRepairRecordStatusNullableWithAggregatesFilter = {
    equals?: RepairRecordStatus | null
    in?: Enumerable<RepairRecordStatus> | null
    notIn?: Enumerable<RepairRecordStatus> | null
    not?: NestedEnumRepairRecordStatusNullableWithAggregatesFilter | RepairRecordStatus | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumRepairRecordStatusNullableFilter
    _max?: NestedEnumRepairRecordStatusNullableFilter
  }

  export type NestedEnumRepairTypeWithAggregatesFilter = {
    equals?: RepairType
    in?: Enumerable<RepairType>
    notIn?: Enumerable<RepairType>
    not?: NestedEnumRepairTypeWithAggregatesFilter | RepairType
    _count?: NestedIntFilter
    _min?: NestedEnumRepairTypeFilter
    _max?: NestedEnumRepairTypeFilter
  }

  export type NestedEnumIncomingInspectResultFilter = {
    equals?: IncomingInspectResult
    in?: Enumerable<IncomingInspectResult>
    notIn?: Enumerable<IncomingInspectResult>
    not?: NestedEnumIncomingInspectResultFilter | IncomingInspectResult
  }

  export type NestedEnumIncomingInspectResultWithAggregatesFilter = {
    equals?: IncomingInspectResult
    in?: Enumerable<IncomingInspectResult>
    notIn?: Enumerable<IncomingInspectResult>
    not?: NestedEnumIncomingInspectResultWithAggregatesFilter | IncomingInspectResult
    _count?: NestedIntFilter
    _min?: NestedEnumIncomingInspectResultFilter
    _max?: NestedEnumIncomingInspectResultFilter
  }

  export type UserProfileCreateWithoutUserInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    fullName: string
  }

  export type UserProfileUncheckedCreateWithoutUserInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    fullName: string
  }

  export type UserProfileCreateOrConnectWithoutUserInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
  }

  export type IncomingInspectRecordCreateWithoutInspectorInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    lot: string
    description?: string | null
    result: IncomingInspectResult
    material: MaterialCreateNestedOneWithoutIncomingInspectRecordInput
    details?: MaterialSpecInspectCreateNestedManyWithoutRecordInput
    reviewer?: UserCreateNestedOneWithoutIncomingReviewedRecordsInput
  }

  export type IncomingInspectRecordUncheckedCreateWithoutInspectorInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    lot: string
    materialId: number
    description?: string | null
    reviewerId: number
    result: IncomingInspectResult
    details?: MaterialSpecInspectUncheckedCreateNestedManyWithoutRecordInput
  }

  export type IncomingInspectRecordCreateOrConnectWithoutInspectorInput = {
    where: IncomingInspectRecordWhereUniqueInput
    create: XOR<IncomingInspectRecordCreateWithoutInspectorInput, IncomingInspectRecordUncheckedCreateWithoutInspectorInput>
  }

  export type IncomingInspectRecordCreateManyInspectorInputEnvelope = {
    data: Enumerable<IncomingInspectRecordCreateManyInspectorInput>
    skipDuplicates?: boolean
  }

  export type IncomingInspectRecordCreateWithoutReviewerInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    lot: string
    description?: string | null
    result: IncomingInspectResult
    material: MaterialCreateNestedOneWithoutIncomingInspectRecordInput
    details?: MaterialSpecInspectCreateNestedManyWithoutRecordInput
    inspector?: UserCreateNestedOneWithoutIncomingInspectedRecordsInput
  }

  export type IncomingInspectRecordUncheckedCreateWithoutReviewerInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    lot: string
    materialId: number
    description?: string | null
    inspectorId: number
    result: IncomingInspectResult
    details?: MaterialSpecInspectUncheckedCreateNestedManyWithoutRecordInput
  }

  export type IncomingInspectRecordCreateOrConnectWithoutReviewerInput = {
    where: IncomingInspectRecordWhereUniqueInput
    create: XOR<IncomingInspectRecordCreateWithoutReviewerInput, IncomingInspectRecordUncheckedCreateWithoutReviewerInput>
  }

  export type IncomingInspectRecordCreateManyReviewerInputEnvelope = {
    data: Enumerable<IncomingInspectRecordCreateManyReviewerInput>
    skipDuplicates?: boolean
  }

  export type InProcessInspectRecordCreateWithoutInspectorInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    lot: string
    description?: string | null
    material: MaterialCreateNestedOneWithoutInProcessInspectRecordInput
    reviewer?: UserCreateNestedOneWithoutInProcessReviewedRecordInput
  }

  export type InProcessInspectRecordUncheckedCreateWithoutInspectorInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    lot: string
    description?: string | null
    materialId: number
    reviewerId: number
  }

  export type InProcessInspectRecordCreateOrConnectWithoutInspectorInput = {
    where: InProcessInspectRecordWhereUniqueInput
    create: XOR<InProcessInspectRecordCreateWithoutInspectorInput, InProcessInspectRecordUncheckedCreateWithoutInspectorInput>
  }

  export type InProcessInspectRecordCreateManyInspectorInputEnvelope = {
    data: Enumerable<InProcessInspectRecordCreateManyInspectorInput>
    skipDuplicates?: boolean
  }

  export type InProcessInspectRecordCreateWithoutReviewerInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    lot: string
    description?: string | null
    material: MaterialCreateNestedOneWithoutInProcessInspectRecordInput
    inspector?: UserCreateNestedOneWithoutInProcessInspectedRecordInput
  }

  export type InProcessInspectRecordUncheckedCreateWithoutReviewerInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    lot: string
    description?: string | null
    materialId: number
    inspectorId: number
  }

  export type InProcessInspectRecordCreateOrConnectWithoutReviewerInput = {
    where: InProcessInspectRecordWhereUniqueInput
    create: XOR<InProcessInspectRecordCreateWithoutReviewerInput, InProcessInspectRecordUncheckedCreateWithoutReviewerInput>
  }

  export type InProcessInspectRecordCreateManyReviewerInputEnvelope = {
    data: Enumerable<InProcessInspectRecordCreateManyReviewerInput>
    skipDuplicates?: boolean
  }

  export type UserProfileUpsertWithoutUserInput = {
    update: XOR<UserProfileUpdateWithoutUserInput, UserProfileUncheckedUpdateWithoutUserInput>
    create: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
  }

  export type UserProfileUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    fullName?: StringFieldUpdateOperationsInput | string
  }

  export type UserProfileUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    fullName?: StringFieldUpdateOperationsInput | string
  }

  export type IncomingInspectRecordUpsertWithWhereUniqueWithoutInspectorInput = {
    where: IncomingInspectRecordWhereUniqueInput
    update: XOR<IncomingInspectRecordUpdateWithoutInspectorInput, IncomingInspectRecordUncheckedUpdateWithoutInspectorInput>
    create: XOR<IncomingInspectRecordCreateWithoutInspectorInput, IncomingInspectRecordUncheckedCreateWithoutInspectorInput>
  }

  export type IncomingInspectRecordUpdateWithWhereUniqueWithoutInspectorInput = {
    where: IncomingInspectRecordWhereUniqueInput
    data: XOR<IncomingInspectRecordUpdateWithoutInspectorInput, IncomingInspectRecordUncheckedUpdateWithoutInspectorInput>
  }

  export type IncomingInspectRecordUpdateManyWithWhereWithoutInspectorInput = {
    where: IncomingInspectRecordScalarWhereInput
    data: XOR<IncomingInspectRecordUpdateManyMutationInput, IncomingInspectRecordUncheckedUpdateManyWithoutIncomingInspectedRecordsInput>
  }

  export type IncomingInspectRecordScalarWhereInput = {
    AND?: Enumerable<IncomingInspectRecordScalarWhereInput>
    OR?: Enumerable<IncomingInspectRecordScalarWhereInput>
    NOT?: Enumerable<IncomingInspectRecordScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    lot?: StringFilter | string
    materialId?: IntFilter | number
    description?: StringNullableFilter | string | null
    inspectorId?: IntFilter | number
    reviewerId?: IntFilter | number
    result?: EnumIncomingInspectResultFilter | IncomingInspectResult
  }

  export type IncomingInspectRecordUpsertWithWhereUniqueWithoutReviewerInput = {
    where: IncomingInspectRecordWhereUniqueInput
    update: XOR<IncomingInspectRecordUpdateWithoutReviewerInput, IncomingInspectRecordUncheckedUpdateWithoutReviewerInput>
    create: XOR<IncomingInspectRecordCreateWithoutReviewerInput, IncomingInspectRecordUncheckedCreateWithoutReviewerInput>
  }

  export type IncomingInspectRecordUpdateWithWhereUniqueWithoutReviewerInput = {
    where: IncomingInspectRecordWhereUniqueInput
    data: XOR<IncomingInspectRecordUpdateWithoutReviewerInput, IncomingInspectRecordUncheckedUpdateWithoutReviewerInput>
  }

  export type IncomingInspectRecordUpdateManyWithWhereWithoutReviewerInput = {
    where: IncomingInspectRecordScalarWhereInput
    data: XOR<IncomingInspectRecordUpdateManyMutationInput, IncomingInspectRecordUncheckedUpdateManyWithoutIncomingReviewedRecordsInput>
  }

  export type InProcessInspectRecordUpsertWithWhereUniqueWithoutInspectorInput = {
    where: InProcessInspectRecordWhereUniqueInput
    update: XOR<InProcessInspectRecordUpdateWithoutInspectorInput, InProcessInspectRecordUncheckedUpdateWithoutInspectorInput>
    create: XOR<InProcessInspectRecordCreateWithoutInspectorInput, InProcessInspectRecordUncheckedCreateWithoutInspectorInput>
  }

  export type InProcessInspectRecordUpdateWithWhereUniqueWithoutInspectorInput = {
    where: InProcessInspectRecordWhereUniqueInput
    data: XOR<InProcessInspectRecordUpdateWithoutInspectorInput, InProcessInspectRecordUncheckedUpdateWithoutInspectorInput>
  }

  export type InProcessInspectRecordUpdateManyWithWhereWithoutInspectorInput = {
    where: InProcessInspectRecordScalarWhereInput
    data: XOR<InProcessInspectRecordUpdateManyMutationInput, InProcessInspectRecordUncheckedUpdateManyWithoutInProcessInspectedRecordInput>
  }

  export type InProcessInspectRecordScalarWhereInput = {
    AND?: Enumerable<InProcessInspectRecordScalarWhereInput>
    OR?: Enumerable<InProcessInspectRecordScalarWhereInput>
    NOT?: Enumerable<InProcessInspectRecordScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    lot?: StringFilter | string
    description?: StringNullableFilter | string | null
    materialId?: IntFilter | number
    inspectorId?: IntFilter | number
    reviewerId?: IntFilter | number
  }

  export type InProcessInspectRecordUpsertWithWhereUniqueWithoutReviewerInput = {
    where: InProcessInspectRecordWhereUniqueInput
    update: XOR<InProcessInspectRecordUpdateWithoutReviewerInput, InProcessInspectRecordUncheckedUpdateWithoutReviewerInput>
    create: XOR<InProcessInspectRecordCreateWithoutReviewerInput, InProcessInspectRecordUncheckedCreateWithoutReviewerInput>
  }

  export type InProcessInspectRecordUpdateWithWhereUniqueWithoutReviewerInput = {
    where: InProcessInspectRecordWhereUniqueInput
    data: XOR<InProcessInspectRecordUpdateWithoutReviewerInput, InProcessInspectRecordUncheckedUpdateWithoutReviewerInput>
  }

  export type InProcessInspectRecordUpdateManyWithWhereWithoutReviewerInput = {
    where: InProcessInspectRecordScalarWhereInput
    data: XOR<InProcessInspectRecordUpdateManyMutationInput, InProcessInspectRecordUncheckedUpdateManyWithoutInProcessReviewedRecordInput>
  }

  export type UserCreateWithoutProfileInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    username: string
    hashedPassword?: string | null
    hashedRefreshToken?: string | null
    status: UserStatus
    role?: UserGroup
    incomingInspectedRecords?: IncomingInspectRecordCreateNestedManyWithoutInspectorInput
    incomingReviewedRecords?: IncomingInspectRecordCreateNestedManyWithoutReviewerInput
    inProcessInspectedRecord?: InProcessInspectRecordCreateNestedManyWithoutInspectorInput
    inProcessReviewedRecord?: InProcessInspectRecordCreateNestedManyWithoutReviewerInput
  }

  export type UserUncheckedCreateWithoutProfileInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    username: string
    hashedPassword?: string | null
    hashedRefreshToken?: string | null
    status: UserStatus
    role?: UserGroup
    incomingInspectedRecords?: IncomingInspectRecordUncheckedCreateNestedManyWithoutInspectorInput
    incomingReviewedRecords?: IncomingInspectRecordUncheckedCreateNestedManyWithoutReviewerInput
    inProcessInspectedRecord?: InProcessInspectRecordUncheckedCreateNestedManyWithoutInspectorInput
    inProcessReviewedRecord?: InProcessInspectRecordUncheckedCreateNestedManyWithoutReviewerInput
  }

  export type UserCreateOrConnectWithoutProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
  }

  export type UserUpsertWithoutProfileInput = {
    update: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
  }

  export type UserUpdateWithoutProfileInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    username?: StringFieldUpdateOperationsInput | string
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    hashedRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | UserStatus
    role?: EnumUserGroupFieldUpdateOperationsInput | UserGroup
    incomingInspectedRecords?: IncomingInspectRecordUpdateManyWithoutInspectorNestedInput
    incomingReviewedRecords?: IncomingInspectRecordUpdateManyWithoutReviewerNestedInput
    inProcessInspectedRecord?: InProcessInspectRecordUpdateManyWithoutInspectorNestedInput
    inProcessReviewedRecord?: InProcessInspectRecordUpdateManyWithoutReviewerNestedInput
  }

  export type UserUncheckedUpdateWithoutProfileInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    username?: StringFieldUpdateOperationsInput | string
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    hashedRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | UserStatus
    role?: EnumUserGroupFieldUpdateOperationsInput | UserGroup
    incomingInspectedRecords?: IncomingInspectRecordUncheckedUpdateManyWithoutInspectorNestedInput
    incomingReviewedRecords?: IncomingInspectRecordUncheckedUpdateManyWithoutReviewerNestedInput
    inProcessInspectedRecord?: InProcessInspectRecordUncheckedUpdateManyWithoutInspectorNestedInput
    inProcessReviewedRecord?: InProcessInspectRecordUncheckedUpdateManyWithoutReviewerNestedInput
  }

  export type EquipmentCreateWithoutProductLineInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    description?: string | null
    purchaseDate: Date | string
    plan?: RepairPlanCreateNestedOneWithoutEquipmentInput
    records?: RepairRecordCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentUncheckedCreateWithoutProductLineInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    description?: string | null
    purchaseDate: Date | string
    plan?: RepairPlanUncheckedCreateNestedOneWithoutEquipmentInput
    records?: RepairRecordUncheckedCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentCreateOrConnectWithoutProductLineInput = {
    where: EquipmentWhereUniqueInput
    create: XOR<EquipmentCreateWithoutProductLineInput, EquipmentUncheckedCreateWithoutProductLineInput>
  }

  export type EquipmentCreateManyProductLineInputEnvelope = {
    data: Enumerable<EquipmentCreateManyProductLineInput>
    skipDuplicates?: boolean
  }

  export type EquipmentUpsertWithWhereUniqueWithoutProductLineInput = {
    where: EquipmentWhereUniqueInput
    update: XOR<EquipmentUpdateWithoutProductLineInput, EquipmentUncheckedUpdateWithoutProductLineInput>
    create: XOR<EquipmentCreateWithoutProductLineInput, EquipmentUncheckedCreateWithoutProductLineInput>
  }

  export type EquipmentUpdateWithWhereUniqueWithoutProductLineInput = {
    where: EquipmentWhereUniqueInput
    data: XOR<EquipmentUpdateWithoutProductLineInput, EquipmentUncheckedUpdateWithoutProductLineInput>
  }

  export type EquipmentUpdateManyWithWhereWithoutProductLineInput = {
    where: EquipmentScalarWhereInput
    data: XOR<EquipmentUpdateManyMutationInput, EquipmentUncheckedUpdateManyWithoutEquipmentInput>
  }

  export type EquipmentScalarWhereInput = {
    AND?: Enumerable<EquipmentScalarWhereInput>
    OR?: Enumerable<EquipmentScalarWhereInput>
    NOT?: Enumerable<EquipmentScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    name?: StringFilter | string
    description?: StringNullableFilter | string | null
    purchaseDate?: DateTimeFilter | Date | string
    productLineId?: IntNullableFilter | number | null
  }

  export type RepairPlanCreateWithoutEquipmentInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    description?: string | null
  }

  export type RepairPlanUncheckedCreateWithoutEquipmentInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    description?: string | null
  }

  export type RepairPlanCreateOrConnectWithoutEquipmentInput = {
    where: RepairPlanWhereUniqueInput
    create: XOR<RepairPlanCreateWithoutEquipmentInput, RepairPlanUncheckedCreateWithoutEquipmentInput>
  }

  export type RepairRecordCreateWithoutEquipmentInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    description?: string | null
    status?: RepairRecordStatus | null
    type: RepairType
  }

  export type RepairRecordUncheckedCreateWithoutEquipmentInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    description?: string | null
    status?: RepairRecordStatus | null
    type: RepairType
  }

  export type RepairRecordCreateOrConnectWithoutEquipmentInput = {
    where: RepairRecordWhereUniqueInput
    create: XOR<RepairRecordCreateWithoutEquipmentInput, RepairRecordUncheckedCreateWithoutEquipmentInput>
  }

  export type RepairRecordCreateManyEquipmentInputEnvelope = {
    data: Enumerable<RepairRecordCreateManyEquipmentInput>
    skipDuplicates?: boolean
  }

  export type ProductLineCreateWithoutEquipmentInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    description?: string | null
  }

  export type ProductLineUncheckedCreateWithoutEquipmentInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    description?: string | null
  }

  export type ProductLineCreateOrConnectWithoutEquipmentInput = {
    where: ProductLineWhereUniqueInput
    create: XOR<ProductLineCreateWithoutEquipmentInput, ProductLineUncheckedCreateWithoutEquipmentInput>
  }

  export type RepairPlanUpsertWithoutEquipmentInput = {
    update: XOR<RepairPlanUpdateWithoutEquipmentInput, RepairPlanUncheckedUpdateWithoutEquipmentInput>
    create: XOR<RepairPlanCreateWithoutEquipmentInput, RepairPlanUncheckedCreateWithoutEquipmentInput>
  }

  export type RepairPlanUpdateWithoutEquipmentInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RepairPlanUncheckedUpdateWithoutEquipmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RepairRecordUpsertWithWhereUniqueWithoutEquipmentInput = {
    where: RepairRecordWhereUniqueInput
    update: XOR<RepairRecordUpdateWithoutEquipmentInput, RepairRecordUncheckedUpdateWithoutEquipmentInput>
    create: XOR<RepairRecordCreateWithoutEquipmentInput, RepairRecordUncheckedCreateWithoutEquipmentInput>
  }

  export type RepairRecordUpdateWithWhereUniqueWithoutEquipmentInput = {
    where: RepairRecordWhereUniqueInput
    data: XOR<RepairRecordUpdateWithoutEquipmentInput, RepairRecordUncheckedUpdateWithoutEquipmentInput>
  }

  export type RepairRecordUpdateManyWithWhereWithoutEquipmentInput = {
    where: RepairRecordScalarWhereInput
    data: XOR<RepairRecordUpdateManyMutationInput, RepairRecordUncheckedUpdateManyWithoutRecordsInput>
  }

  export type RepairRecordScalarWhereInput = {
    AND?: Enumerable<RepairRecordScalarWhereInput>
    OR?: Enumerable<RepairRecordScalarWhereInput>
    NOT?: Enumerable<RepairRecordScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    equimentId?: IntFilter | number
    description?: StringNullableFilter | string | null
    status?: EnumRepairRecordStatusNullableFilter | RepairRecordStatus | null
    type?: EnumRepairTypeFilter | RepairType
  }

  export type ProductLineUpsertWithoutEquipmentInput = {
    update: XOR<ProductLineUpdateWithoutEquipmentInput, ProductLineUncheckedUpdateWithoutEquipmentInput>
    create: XOR<ProductLineCreateWithoutEquipmentInput, ProductLineUncheckedCreateWithoutEquipmentInput>
  }

  export type ProductLineUpdateWithoutEquipmentInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductLineUncheckedUpdateWithoutEquipmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RepairMaterialInventoryCreateWithoutRepairMaterialInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    quantity: number
  }

  export type RepairMaterialInventoryUncheckedCreateWithoutRepairMaterialInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    quantity: number
  }

  export type RepairMaterialInventoryCreateOrConnectWithoutRepairMaterialInput = {
    where: RepairMaterialInventoryWhereUniqueInput
    create: XOR<RepairMaterialInventoryCreateWithoutRepairMaterialInput, RepairMaterialInventoryUncheckedCreateWithoutRepairMaterialInput>
  }

  export type RepairMaterialInventoryUpsertWithoutRepairMaterialInput = {
    update: XOR<RepairMaterialInventoryUpdateWithoutRepairMaterialInput, RepairMaterialInventoryUncheckedUpdateWithoutRepairMaterialInput>
    create: XOR<RepairMaterialInventoryCreateWithoutRepairMaterialInput, RepairMaterialInventoryUncheckedCreateWithoutRepairMaterialInput>
  }

  export type RepairMaterialInventoryUpdateWithoutRepairMaterialInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type RepairMaterialInventoryUncheckedUpdateWithoutRepairMaterialInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type EquipmentCreateWithoutPlanInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    description?: string | null
    purchaseDate: Date | string
    records?: RepairRecordCreateNestedManyWithoutEquipmentInput
    productLine?: ProductLineCreateNestedOneWithoutEquipmentInput
  }

  export type EquipmentUncheckedCreateWithoutPlanInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    description?: string | null
    purchaseDate: Date | string
    productLineId?: number | null
    records?: RepairRecordUncheckedCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentCreateOrConnectWithoutPlanInput = {
    where: EquipmentWhereUniqueInput
    create: XOR<EquipmentCreateWithoutPlanInput, EquipmentUncheckedCreateWithoutPlanInput>
  }

  export type EquipmentUpsertWithoutPlanInput = {
    update: XOR<EquipmentUpdateWithoutPlanInput, EquipmentUncheckedUpdateWithoutPlanInput>
    create: XOR<EquipmentCreateWithoutPlanInput, EquipmentUncheckedCreateWithoutPlanInput>
  }

  export type EquipmentUpdateWithoutPlanInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    records?: RepairRecordUpdateManyWithoutEquipmentNestedInput
    productLine?: ProductLineUpdateOneWithoutEquipmentNestedInput
  }

  export type EquipmentUncheckedUpdateWithoutPlanInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    productLineId?: NullableIntFieldUpdateOperationsInput | number | null
    records?: RepairRecordUncheckedUpdateManyWithoutEquipmentNestedInput
  }

  export type RepairMaterialCreateWithoutInventoryInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    description?: string | null
  }

  export type RepairMaterialUncheckedCreateWithoutInventoryInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    description?: string | null
  }

  export type RepairMaterialCreateOrConnectWithoutInventoryInput = {
    where: RepairMaterialWhereUniqueInput
    create: XOR<RepairMaterialCreateWithoutInventoryInput, RepairMaterialUncheckedCreateWithoutInventoryInput>
  }

  export type RepairMaterialUpsertWithoutInventoryInput = {
    update: XOR<RepairMaterialUpdateWithoutInventoryInput, RepairMaterialUncheckedUpdateWithoutInventoryInput>
    create: XOR<RepairMaterialCreateWithoutInventoryInput, RepairMaterialUncheckedCreateWithoutInventoryInput>
  }

  export type RepairMaterialUpdateWithoutInventoryInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RepairMaterialUncheckedUpdateWithoutInventoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EquipmentCreateWithoutRecordsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    description?: string | null
    purchaseDate: Date | string
    plan?: RepairPlanCreateNestedOneWithoutEquipmentInput
    productLine?: ProductLineCreateNestedOneWithoutEquipmentInput
  }

  export type EquipmentUncheckedCreateWithoutRecordsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    description?: string | null
    purchaseDate: Date | string
    productLineId?: number | null
    plan?: RepairPlanUncheckedCreateNestedOneWithoutEquipmentInput
  }

  export type EquipmentCreateOrConnectWithoutRecordsInput = {
    where: EquipmentWhereUniqueInput
    create: XOR<EquipmentCreateWithoutRecordsInput, EquipmentUncheckedCreateWithoutRecordsInput>
  }

  export type EquipmentUpsertWithoutRecordsInput = {
    update: XOR<EquipmentUpdateWithoutRecordsInput, EquipmentUncheckedUpdateWithoutRecordsInput>
    create: XOR<EquipmentCreateWithoutRecordsInput, EquipmentUncheckedCreateWithoutRecordsInput>
  }

  export type EquipmentUpdateWithoutRecordsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: RepairPlanUpdateOneWithoutEquipmentNestedInput
    productLine?: ProductLineUpdateOneWithoutEquipmentNestedInput
  }

  export type EquipmentUncheckedUpdateWithoutRecordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    productLineId?: NullableIntFieldUpdateOperationsInput | number | null
    plan?: RepairPlanUncheckedUpdateOneWithoutEquipmentNestedInput
  }

  export type MaterialSpecCreateWithoutMaterialInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    description?: string | null
    inspects?: MaterialSpecInspectCreateNestedManyWithoutSpecInput
  }

  export type MaterialSpecUncheckedCreateWithoutMaterialInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    description?: string | null
    inspects?: MaterialSpecInspectUncheckedCreateNestedManyWithoutSpecInput
  }

  export type MaterialSpecCreateOrConnectWithoutMaterialInput = {
    where: MaterialSpecWhereUniqueInput
    create: XOR<MaterialSpecCreateWithoutMaterialInput, MaterialSpecUncheckedCreateWithoutMaterialInput>
  }

  export type MaterialSpecCreateManyMaterialInputEnvelope = {
    data: Enumerable<MaterialSpecCreateManyMaterialInput>
    skipDuplicates?: boolean
  }

  export type OperationCreateWithoutMaterialInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    description?: string | null
    specs?: OperationSpecCreateNestedManyWithoutOperationInput
  }

  export type OperationUncheckedCreateWithoutMaterialInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    description?: string | null
    specs?: OperationSpecUncheckedCreateNestedManyWithoutOperationInput
  }

  export type OperationCreateOrConnectWithoutMaterialInput = {
    where: OperationWhereUniqueInput
    create: XOR<OperationCreateWithoutMaterialInput, OperationUncheckedCreateWithoutMaterialInput>
  }

  export type OperationCreateManyMaterialInputEnvelope = {
    data: Enumerable<OperationCreateManyMaterialInput>
    skipDuplicates?: boolean
  }

  export type IncomingInspectRecordCreateWithoutMaterialInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    lot: string
    description?: string | null
    result: IncomingInspectResult
    details?: MaterialSpecInspectCreateNestedManyWithoutRecordInput
    inspector?: UserCreateNestedOneWithoutIncomingInspectedRecordsInput
    reviewer?: UserCreateNestedOneWithoutIncomingReviewedRecordsInput
  }

  export type IncomingInspectRecordUncheckedCreateWithoutMaterialInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    lot: string
    description?: string | null
    inspectorId: number
    reviewerId: number
    result: IncomingInspectResult
    details?: MaterialSpecInspectUncheckedCreateNestedManyWithoutRecordInput
  }

  export type IncomingInspectRecordCreateOrConnectWithoutMaterialInput = {
    where: IncomingInspectRecordWhereUniqueInput
    create: XOR<IncomingInspectRecordCreateWithoutMaterialInput, IncomingInspectRecordUncheckedCreateWithoutMaterialInput>
  }

  export type IncomingInspectRecordCreateManyMaterialInputEnvelope = {
    data: Enumerable<IncomingInspectRecordCreateManyMaterialInput>
    skipDuplicates?: boolean
  }

  export type InProcessInspectRecordCreateWithoutMaterialInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    lot: string
    description?: string | null
    inspector?: UserCreateNestedOneWithoutInProcessInspectedRecordInput
    reviewer?: UserCreateNestedOneWithoutInProcessReviewedRecordInput
  }

  export type InProcessInspectRecordUncheckedCreateWithoutMaterialInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    lot: string
    description?: string | null
    inspectorId: number
    reviewerId: number
  }

  export type InProcessInspectRecordCreateOrConnectWithoutMaterialInput = {
    where: InProcessInspectRecordWhereUniqueInput
    create: XOR<InProcessInspectRecordCreateWithoutMaterialInput, InProcessInspectRecordUncheckedCreateWithoutMaterialInput>
  }

  export type InProcessInspectRecordCreateManyMaterialInputEnvelope = {
    data: Enumerable<InProcessInspectRecordCreateManyMaterialInput>
    skipDuplicates?: boolean
  }

  export type MaterialSpecUpsertWithWhereUniqueWithoutMaterialInput = {
    where: MaterialSpecWhereUniqueInput
    update: XOR<MaterialSpecUpdateWithoutMaterialInput, MaterialSpecUncheckedUpdateWithoutMaterialInput>
    create: XOR<MaterialSpecCreateWithoutMaterialInput, MaterialSpecUncheckedCreateWithoutMaterialInput>
  }

  export type MaterialSpecUpdateWithWhereUniqueWithoutMaterialInput = {
    where: MaterialSpecWhereUniqueInput
    data: XOR<MaterialSpecUpdateWithoutMaterialInput, MaterialSpecUncheckedUpdateWithoutMaterialInput>
  }

  export type MaterialSpecUpdateManyWithWhereWithoutMaterialInput = {
    where: MaterialSpecScalarWhereInput
    data: XOR<MaterialSpecUpdateManyMutationInput, MaterialSpecUncheckedUpdateManyWithoutSpecsInput>
  }

  export type MaterialSpecScalarWhereInput = {
    AND?: Enumerable<MaterialSpecScalarWhereInput>
    OR?: Enumerable<MaterialSpecScalarWhereInput>
    NOT?: Enumerable<MaterialSpecScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    name?: StringFilter | string
    description?: StringNullableFilter | string | null
    materialId?: IntFilter | number
  }

  export type OperationUpsertWithWhereUniqueWithoutMaterialInput = {
    where: OperationWhereUniqueInput
    update: XOR<OperationUpdateWithoutMaterialInput, OperationUncheckedUpdateWithoutMaterialInput>
    create: XOR<OperationCreateWithoutMaterialInput, OperationUncheckedCreateWithoutMaterialInput>
  }

  export type OperationUpdateWithWhereUniqueWithoutMaterialInput = {
    where: OperationWhereUniqueInput
    data: XOR<OperationUpdateWithoutMaterialInput, OperationUncheckedUpdateWithoutMaterialInput>
  }

  export type OperationUpdateManyWithWhereWithoutMaterialInput = {
    where: OperationScalarWhereInput
    data: XOR<OperationUpdateManyMutationInput, OperationUncheckedUpdateManyWithoutOperationsInput>
  }

  export type OperationScalarWhereInput = {
    AND?: Enumerable<OperationScalarWhereInput>
    OR?: Enumerable<OperationScalarWhereInput>
    NOT?: Enumerable<OperationScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    name?: StringFilter | string
    description?: StringNullableFilter | string | null
    materialId?: IntFilter | number
  }

  export type IncomingInspectRecordUpsertWithWhereUniqueWithoutMaterialInput = {
    where: IncomingInspectRecordWhereUniqueInput
    update: XOR<IncomingInspectRecordUpdateWithoutMaterialInput, IncomingInspectRecordUncheckedUpdateWithoutMaterialInput>
    create: XOR<IncomingInspectRecordCreateWithoutMaterialInput, IncomingInspectRecordUncheckedCreateWithoutMaterialInput>
  }

  export type IncomingInspectRecordUpdateWithWhereUniqueWithoutMaterialInput = {
    where: IncomingInspectRecordWhereUniqueInput
    data: XOR<IncomingInspectRecordUpdateWithoutMaterialInput, IncomingInspectRecordUncheckedUpdateWithoutMaterialInput>
  }

  export type IncomingInspectRecordUpdateManyWithWhereWithoutMaterialInput = {
    where: IncomingInspectRecordScalarWhereInput
    data: XOR<IncomingInspectRecordUpdateManyMutationInput, IncomingInspectRecordUncheckedUpdateManyWithoutIncomingInspectRecordInput>
  }

  export type InProcessInspectRecordUpsertWithWhereUniqueWithoutMaterialInput = {
    where: InProcessInspectRecordWhereUniqueInput
    update: XOR<InProcessInspectRecordUpdateWithoutMaterialInput, InProcessInspectRecordUncheckedUpdateWithoutMaterialInput>
    create: XOR<InProcessInspectRecordCreateWithoutMaterialInput, InProcessInspectRecordUncheckedCreateWithoutMaterialInput>
  }

  export type InProcessInspectRecordUpdateWithWhereUniqueWithoutMaterialInput = {
    where: InProcessInspectRecordWhereUniqueInput
    data: XOR<InProcessInspectRecordUpdateWithoutMaterialInput, InProcessInspectRecordUncheckedUpdateWithoutMaterialInput>
  }

  export type InProcessInspectRecordUpdateManyWithWhereWithoutMaterialInput = {
    where: InProcessInspectRecordScalarWhereInput
    data: XOR<InProcessInspectRecordUpdateManyMutationInput, InProcessInspectRecordUncheckedUpdateManyWithoutInProcessInspectRecordInput>
  }

  export type MaterialCreateWithoutSpecsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    description?: string | null
    operations?: OperationCreateNestedManyWithoutMaterialInput
    incomingInspectRecord?: IncomingInspectRecordCreateNestedManyWithoutMaterialInput
    inProcessInspectRecord?: InProcessInspectRecordCreateNestedManyWithoutMaterialInput
  }

  export type MaterialUncheckedCreateWithoutSpecsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    description?: string | null
    operations?: OperationUncheckedCreateNestedManyWithoutMaterialInput
    incomingInspectRecord?: IncomingInspectRecordUncheckedCreateNestedManyWithoutMaterialInput
    inProcessInspectRecord?: InProcessInspectRecordUncheckedCreateNestedManyWithoutMaterialInput
  }

  export type MaterialCreateOrConnectWithoutSpecsInput = {
    where: MaterialWhereUniqueInput
    create: XOR<MaterialCreateWithoutSpecsInput, MaterialUncheckedCreateWithoutSpecsInput>
  }

  export type MaterialSpecInspectCreateWithoutSpecInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    description?: string | null
    result: boolean
    record: IncomingInspectRecordCreateNestedOneWithoutDetailsInput
  }

  export type MaterialSpecInspectUncheckedCreateWithoutSpecInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    recordId: number
    description?: string | null
    result: boolean
  }

  export type MaterialSpecInspectCreateOrConnectWithoutSpecInput = {
    where: MaterialSpecInspectWhereUniqueInput
    create: XOR<MaterialSpecInspectCreateWithoutSpecInput, MaterialSpecInspectUncheckedCreateWithoutSpecInput>
  }

  export type MaterialSpecInspectCreateManySpecInputEnvelope = {
    data: Enumerable<MaterialSpecInspectCreateManySpecInput>
    skipDuplicates?: boolean
  }

  export type MaterialUpsertWithoutSpecsInput = {
    update: XOR<MaterialUpdateWithoutSpecsInput, MaterialUncheckedUpdateWithoutSpecsInput>
    create: XOR<MaterialCreateWithoutSpecsInput, MaterialUncheckedCreateWithoutSpecsInput>
  }

  export type MaterialUpdateWithoutSpecsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    operations?: OperationUpdateManyWithoutMaterialNestedInput
    incomingInspectRecord?: IncomingInspectRecordUpdateManyWithoutMaterialNestedInput
    inProcessInspectRecord?: InProcessInspectRecordUpdateManyWithoutMaterialNestedInput
  }

  export type MaterialUncheckedUpdateWithoutSpecsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    operations?: OperationUncheckedUpdateManyWithoutMaterialNestedInput
    incomingInspectRecord?: IncomingInspectRecordUncheckedUpdateManyWithoutMaterialNestedInput
    inProcessInspectRecord?: InProcessInspectRecordUncheckedUpdateManyWithoutMaterialNestedInput
  }

  export type MaterialSpecInspectUpsertWithWhereUniqueWithoutSpecInput = {
    where: MaterialSpecInspectWhereUniqueInput
    update: XOR<MaterialSpecInspectUpdateWithoutSpecInput, MaterialSpecInspectUncheckedUpdateWithoutSpecInput>
    create: XOR<MaterialSpecInspectCreateWithoutSpecInput, MaterialSpecInspectUncheckedCreateWithoutSpecInput>
  }

  export type MaterialSpecInspectUpdateWithWhereUniqueWithoutSpecInput = {
    where: MaterialSpecInspectWhereUniqueInput
    data: XOR<MaterialSpecInspectUpdateWithoutSpecInput, MaterialSpecInspectUncheckedUpdateWithoutSpecInput>
  }

  export type MaterialSpecInspectUpdateManyWithWhereWithoutSpecInput = {
    where: MaterialSpecInspectScalarWhereInput
    data: XOR<MaterialSpecInspectUpdateManyMutationInput, MaterialSpecInspectUncheckedUpdateManyWithoutInspectsInput>
  }

  export type MaterialSpecInspectScalarWhereInput = {
    AND?: Enumerable<MaterialSpecInspectScalarWhereInput>
    OR?: Enumerable<MaterialSpecInspectScalarWhereInput>
    NOT?: Enumerable<MaterialSpecInspectScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    recordId?: IntFilter | number
    specId?: IntFilter | number
    description?: StringNullableFilter | string | null
    result?: BoolFilter | boolean
  }

  export type MaterialCreateWithoutOperationsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    description?: string | null
    specs?: MaterialSpecCreateNestedManyWithoutMaterialInput
    incomingInspectRecord?: IncomingInspectRecordCreateNestedManyWithoutMaterialInput
    inProcessInspectRecord?: InProcessInspectRecordCreateNestedManyWithoutMaterialInput
  }

  export type MaterialUncheckedCreateWithoutOperationsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    description?: string | null
    specs?: MaterialSpecUncheckedCreateNestedManyWithoutMaterialInput
    incomingInspectRecord?: IncomingInspectRecordUncheckedCreateNestedManyWithoutMaterialInput
    inProcessInspectRecord?: InProcessInspectRecordUncheckedCreateNestedManyWithoutMaterialInput
  }

  export type MaterialCreateOrConnectWithoutOperationsInput = {
    where: MaterialWhereUniqueInput
    create: XOR<MaterialCreateWithoutOperationsInput, MaterialUncheckedCreateWithoutOperationsInput>
  }

  export type OperationSpecCreateWithoutOperationInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    description?: string | null
    inspect?: OperationSpecInspectCreateNestedManyWithoutSpecInput
  }

  export type OperationSpecUncheckedCreateWithoutOperationInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    description?: string | null
    inspect?: OperationSpecInspectUncheckedCreateNestedManyWithoutSpecInput
  }

  export type OperationSpecCreateOrConnectWithoutOperationInput = {
    where: OperationSpecWhereUniqueInput
    create: XOR<OperationSpecCreateWithoutOperationInput, OperationSpecUncheckedCreateWithoutOperationInput>
  }

  export type OperationSpecCreateManyOperationInputEnvelope = {
    data: Enumerable<OperationSpecCreateManyOperationInput>
    skipDuplicates?: boolean
  }

  export type MaterialUpsertWithoutOperationsInput = {
    update: XOR<MaterialUpdateWithoutOperationsInput, MaterialUncheckedUpdateWithoutOperationsInput>
    create: XOR<MaterialCreateWithoutOperationsInput, MaterialUncheckedCreateWithoutOperationsInput>
  }

  export type MaterialUpdateWithoutOperationsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    specs?: MaterialSpecUpdateManyWithoutMaterialNestedInput
    incomingInspectRecord?: IncomingInspectRecordUpdateManyWithoutMaterialNestedInput
    inProcessInspectRecord?: InProcessInspectRecordUpdateManyWithoutMaterialNestedInput
  }

  export type MaterialUncheckedUpdateWithoutOperationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    specs?: MaterialSpecUncheckedUpdateManyWithoutMaterialNestedInput
    incomingInspectRecord?: IncomingInspectRecordUncheckedUpdateManyWithoutMaterialNestedInput
    inProcessInspectRecord?: InProcessInspectRecordUncheckedUpdateManyWithoutMaterialNestedInput
  }

  export type OperationSpecUpsertWithWhereUniqueWithoutOperationInput = {
    where: OperationSpecWhereUniqueInput
    update: XOR<OperationSpecUpdateWithoutOperationInput, OperationSpecUncheckedUpdateWithoutOperationInput>
    create: XOR<OperationSpecCreateWithoutOperationInput, OperationSpecUncheckedCreateWithoutOperationInput>
  }

  export type OperationSpecUpdateWithWhereUniqueWithoutOperationInput = {
    where: OperationSpecWhereUniqueInput
    data: XOR<OperationSpecUpdateWithoutOperationInput, OperationSpecUncheckedUpdateWithoutOperationInput>
  }

  export type OperationSpecUpdateManyWithWhereWithoutOperationInput = {
    where: OperationSpecScalarWhereInput
    data: XOR<OperationSpecUpdateManyMutationInput, OperationSpecUncheckedUpdateManyWithoutSpecsInput>
  }

  export type OperationSpecScalarWhereInput = {
    AND?: Enumerable<OperationSpecScalarWhereInput>
    OR?: Enumerable<OperationSpecScalarWhereInput>
    NOT?: Enumerable<OperationSpecScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    name?: StringFilter | string
    description?: StringNullableFilter | string | null
    operationId?: IntFilter | number
  }

  export type OperationCreateWithoutSpecsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    description?: string | null
    material: MaterialCreateNestedOneWithoutOperationsInput
  }

  export type OperationUncheckedCreateWithoutSpecsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    description?: string | null
    materialId: number
  }

  export type OperationCreateOrConnectWithoutSpecsInput = {
    where: OperationWhereUniqueInput
    create: XOR<OperationCreateWithoutSpecsInput, OperationUncheckedCreateWithoutSpecsInput>
  }

  export type OperationSpecInspectCreateWithoutSpecInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    first: string
    inProcess: string
    final: string
  }

  export type OperationSpecInspectUncheckedCreateWithoutSpecInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    first: string
    inProcess: string
    final: string
  }

  export type OperationSpecInspectCreateOrConnectWithoutSpecInput = {
    where: OperationSpecInspectWhereUniqueInput
    create: XOR<OperationSpecInspectCreateWithoutSpecInput, OperationSpecInspectUncheckedCreateWithoutSpecInput>
  }

  export type OperationSpecInspectCreateManySpecInputEnvelope = {
    data: Enumerable<OperationSpecInspectCreateManySpecInput>
    skipDuplicates?: boolean
  }

  export type OperationUpsertWithoutSpecsInput = {
    update: XOR<OperationUpdateWithoutSpecsInput, OperationUncheckedUpdateWithoutSpecsInput>
    create: XOR<OperationCreateWithoutSpecsInput, OperationUncheckedCreateWithoutSpecsInput>
  }

  export type OperationUpdateWithoutSpecsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    material?: MaterialUpdateOneRequiredWithoutOperationsNestedInput
  }

  export type OperationUncheckedUpdateWithoutSpecsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    materialId?: IntFieldUpdateOperationsInput | number
  }

  export type OperationSpecInspectUpsertWithWhereUniqueWithoutSpecInput = {
    where: OperationSpecInspectWhereUniqueInput
    update: XOR<OperationSpecInspectUpdateWithoutSpecInput, OperationSpecInspectUncheckedUpdateWithoutSpecInput>
    create: XOR<OperationSpecInspectCreateWithoutSpecInput, OperationSpecInspectUncheckedCreateWithoutSpecInput>
  }

  export type OperationSpecInspectUpdateWithWhereUniqueWithoutSpecInput = {
    where: OperationSpecInspectWhereUniqueInput
    data: XOR<OperationSpecInspectUpdateWithoutSpecInput, OperationSpecInspectUncheckedUpdateWithoutSpecInput>
  }

  export type OperationSpecInspectUpdateManyWithWhereWithoutSpecInput = {
    where: OperationSpecInspectScalarWhereInput
    data: XOR<OperationSpecInspectUpdateManyMutationInput, OperationSpecInspectUncheckedUpdateManyWithoutInspectInput>
  }

  export type OperationSpecInspectScalarWhereInput = {
    AND?: Enumerable<OperationSpecInspectScalarWhereInput>
    OR?: Enumerable<OperationSpecInspectScalarWhereInput>
    NOT?: Enumerable<OperationSpecInspectScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isDeleted?: BoolFilter | boolean
    specId?: IntFilter | number
    first?: StringFilter | string
    inProcess?: StringFilter | string
    final?: StringFilter | string
  }

  export type MaterialCreateWithoutIncomingInspectRecordInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    description?: string | null
    specs?: MaterialSpecCreateNestedManyWithoutMaterialInput
    operations?: OperationCreateNestedManyWithoutMaterialInput
    inProcessInspectRecord?: InProcessInspectRecordCreateNestedManyWithoutMaterialInput
  }

  export type MaterialUncheckedCreateWithoutIncomingInspectRecordInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    description?: string | null
    specs?: MaterialSpecUncheckedCreateNestedManyWithoutMaterialInput
    operations?: OperationUncheckedCreateNestedManyWithoutMaterialInput
    inProcessInspectRecord?: InProcessInspectRecordUncheckedCreateNestedManyWithoutMaterialInput
  }

  export type MaterialCreateOrConnectWithoutIncomingInspectRecordInput = {
    where: MaterialWhereUniqueInput
    create: XOR<MaterialCreateWithoutIncomingInspectRecordInput, MaterialUncheckedCreateWithoutIncomingInspectRecordInput>
  }

  export type MaterialSpecInspectCreateWithoutRecordInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    description?: string | null
    result: boolean
    spec: MaterialSpecCreateNestedOneWithoutInspectsInput
  }

  export type MaterialSpecInspectUncheckedCreateWithoutRecordInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    specId: number
    description?: string | null
    result: boolean
  }

  export type MaterialSpecInspectCreateOrConnectWithoutRecordInput = {
    where: MaterialSpecInspectWhereUniqueInput
    create: XOR<MaterialSpecInspectCreateWithoutRecordInput, MaterialSpecInspectUncheckedCreateWithoutRecordInput>
  }

  export type MaterialSpecInspectCreateManyRecordInputEnvelope = {
    data: Enumerable<MaterialSpecInspectCreateManyRecordInput>
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutIncomingInspectedRecordsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    username: string
    hashedPassword?: string | null
    hashedRefreshToken?: string | null
    status: UserStatus
    role?: UserGroup
    profile?: UserProfileCreateNestedOneWithoutUserInput
    incomingReviewedRecords?: IncomingInspectRecordCreateNestedManyWithoutReviewerInput
    inProcessInspectedRecord?: InProcessInspectRecordCreateNestedManyWithoutInspectorInput
    inProcessReviewedRecord?: InProcessInspectRecordCreateNestedManyWithoutReviewerInput
  }

  export type UserUncheckedCreateWithoutIncomingInspectedRecordsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    username: string
    hashedPassword?: string | null
    hashedRefreshToken?: string | null
    status: UserStatus
    role?: UserGroup
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    incomingReviewedRecords?: IncomingInspectRecordUncheckedCreateNestedManyWithoutReviewerInput
    inProcessInspectedRecord?: InProcessInspectRecordUncheckedCreateNestedManyWithoutInspectorInput
    inProcessReviewedRecord?: InProcessInspectRecordUncheckedCreateNestedManyWithoutReviewerInput
  }

  export type UserCreateOrConnectWithoutIncomingInspectedRecordsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutIncomingInspectedRecordsInput, UserUncheckedCreateWithoutIncomingInspectedRecordsInput>
  }

  export type UserCreateWithoutIncomingReviewedRecordsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    username: string
    hashedPassword?: string | null
    hashedRefreshToken?: string | null
    status: UserStatus
    role?: UserGroup
    profile?: UserProfileCreateNestedOneWithoutUserInput
    incomingInspectedRecords?: IncomingInspectRecordCreateNestedManyWithoutInspectorInput
    inProcessInspectedRecord?: InProcessInspectRecordCreateNestedManyWithoutInspectorInput
    inProcessReviewedRecord?: InProcessInspectRecordCreateNestedManyWithoutReviewerInput
  }

  export type UserUncheckedCreateWithoutIncomingReviewedRecordsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    username: string
    hashedPassword?: string | null
    hashedRefreshToken?: string | null
    status: UserStatus
    role?: UserGroup
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    incomingInspectedRecords?: IncomingInspectRecordUncheckedCreateNestedManyWithoutInspectorInput
    inProcessInspectedRecord?: InProcessInspectRecordUncheckedCreateNestedManyWithoutInspectorInput
    inProcessReviewedRecord?: InProcessInspectRecordUncheckedCreateNestedManyWithoutReviewerInput
  }

  export type UserCreateOrConnectWithoutIncomingReviewedRecordsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutIncomingReviewedRecordsInput, UserUncheckedCreateWithoutIncomingReviewedRecordsInput>
  }

  export type MaterialUpsertWithoutIncomingInspectRecordInput = {
    update: XOR<MaterialUpdateWithoutIncomingInspectRecordInput, MaterialUncheckedUpdateWithoutIncomingInspectRecordInput>
    create: XOR<MaterialCreateWithoutIncomingInspectRecordInput, MaterialUncheckedCreateWithoutIncomingInspectRecordInput>
  }

  export type MaterialUpdateWithoutIncomingInspectRecordInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    specs?: MaterialSpecUpdateManyWithoutMaterialNestedInput
    operations?: OperationUpdateManyWithoutMaterialNestedInput
    inProcessInspectRecord?: InProcessInspectRecordUpdateManyWithoutMaterialNestedInput
  }

  export type MaterialUncheckedUpdateWithoutIncomingInspectRecordInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    specs?: MaterialSpecUncheckedUpdateManyWithoutMaterialNestedInput
    operations?: OperationUncheckedUpdateManyWithoutMaterialNestedInput
    inProcessInspectRecord?: InProcessInspectRecordUncheckedUpdateManyWithoutMaterialNestedInput
  }

  export type MaterialSpecInspectUpsertWithWhereUniqueWithoutRecordInput = {
    where: MaterialSpecInspectWhereUniqueInput
    update: XOR<MaterialSpecInspectUpdateWithoutRecordInput, MaterialSpecInspectUncheckedUpdateWithoutRecordInput>
    create: XOR<MaterialSpecInspectCreateWithoutRecordInput, MaterialSpecInspectUncheckedCreateWithoutRecordInput>
  }

  export type MaterialSpecInspectUpdateWithWhereUniqueWithoutRecordInput = {
    where: MaterialSpecInspectWhereUniqueInput
    data: XOR<MaterialSpecInspectUpdateWithoutRecordInput, MaterialSpecInspectUncheckedUpdateWithoutRecordInput>
  }

  export type MaterialSpecInspectUpdateManyWithWhereWithoutRecordInput = {
    where: MaterialSpecInspectScalarWhereInput
    data: XOR<MaterialSpecInspectUpdateManyMutationInput, MaterialSpecInspectUncheckedUpdateManyWithoutDetailsInput>
  }

  export type UserUpsertWithoutIncomingInspectedRecordsInput = {
    update: XOR<UserUpdateWithoutIncomingInspectedRecordsInput, UserUncheckedUpdateWithoutIncomingInspectedRecordsInput>
    create: XOR<UserCreateWithoutIncomingInspectedRecordsInput, UserUncheckedCreateWithoutIncomingInspectedRecordsInput>
  }

  export type UserUpdateWithoutIncomingInspectedRecordsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    username?: StringFieldUpdateOperationsInput | string
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    hashedRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | UserStatus
    role?: EnumUserGroupFieldUpdateOperationsInput | UserGroup
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    incomingReviewedRecords?: IncomingInspectRecordUpdateManyWithoutReviewerNestedInput
    inProcessInspectedRecord?: InProcessInspectRecordUpdateManyWithoutInspectorNestedInput
    inProcessReviewedRecord?: InProcessInspectRecordUpdateManyWithoutReviewerNestedInput
  }

  export type UserUncheckedUpdateWithoutIncomingInspectedRecordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    username?: StringFieldUpdateOperationsInput | string
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    hashedRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | UserStatus
    role?: EnumUserGroupFieldUpdateOperationsInput | UserGroup
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    incomingReviewedRecords?: IncomingInspectRecordUncheckedUpdateManyWithoutReviewerNestedInput
    inProcessInspectedRecord?: InProcessInspectRecordUncheckedUpdateManyWithoutInspectorNestedInput
    inProcessReviewedRecord?: InProcessInspectRecordUncheckedUpdateManyWithoutReviewerNestedInput
  }

  export type UserUpsertWithoutIncomingReviewedRecordsInput = {
    update: XOR<UserUpdateWithoutIncomingReviewedRecordsInput, UserUncheckedUpdateWithoutIncomingReviewedRecordsInput>
    create: XOR<UserCreateWithoutIncomingReviewedRecordsInput, UserUncheckedCreateWithoutIncomingReviewedRecordsInput>
  }

  export type UserUpdateWithoutIncomingReviewedRecordsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    username?: StringFieldUpdateOperationsInput | string
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    hashedRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | UserStatus
    role?: EnumUserGroupFieldUpdateOperationsInput | UserGroup
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    incomingInspectedRecords?: IncomingInspectRecordUpdateManyWithoutInspectorNestedInput
    inProcessInspectedRecord?: InProcessInspectRecordUpdateManyWithoutInspectorNestedInput
    inProcessReviewedRecord?: InProcessInspectRecordUpdateManyWithoutReviewerNestedInput
  }

  export type UserUncheckedUpdateWithoutIncomingReviewedRecordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    username?: StringFieldUpdateOperationsInput | string
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    hashedRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | UserStatus
    role?: EnumUserGroupFieldUpdateOperationsInput | UserGroup
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    incomingInspectedRecords?: IncomingInspectRecordUncheckedUpdateManyWithoutInspectorNestedInput
    inProcessInspectedRecord?: InProcessInspectRecordUncheckedUpdateManyWithoutInspectorNestedInput
    inProcessReviewedRecord?: InProcessInspectRecordUncheckedUpdateManyWithoutReviewerNestedInput
  }

  export type IncomingInspectRecordCreateWithoutDetailsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    lot: string
    description?: string | null
    result: IncomingInspectResult
    material: MaterialCreateNestedOneWithoutIncomingInspectRecordInput
    inspector?: UserCreateNestedOneWithoutIncomingInspectedRecordsInput
    reviewer?: UserCreateNestedOneWithoutIncomingReviewedRecordsInput
  }

  export type IncomingInspectRecordUncheckedCreateWithoutDetailsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    lot: string
    materialId: number
    description?: string | null
    inspectorId: number
    reviewerId: number
    result: IncomingInspectResult
  }

  export type IncomingInspectRecordCreateOrConnectWithoutDetailsInput = {
    where: IncomingInspectRecordWhereUniqueInput
    create: XOR<IncomingInspectRecordCreateWithoutDetailsInput, IncomingInspectRecordUncheckedCreateWithoutDetailsInput>
  }

  export type MaterialSpecCreateWithoutInspectsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    description?: string | null
    material: MaterialCreateNestedOneWithoutSpecsInput
  }

  export type MaterialSpecUncheckedCreateWithoutInspectsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    description?: string | null
    materialId: number
  }

  export type MaterialSpecCreateOrConnectWithoutInspectsInput = {
    where: MaterialSpecWhereUniqueInput
    create: XOR<MaterialSpecCreateWithoutInspectsInput, MaterialSpecUncheckedCreateWithoutInspectsInput>
  }

  export type IncomingInspectRecordUpsertWithoutDetailsInput = {
    update: XOR<IncomingInspectRecordUpdateWithoutDetailsInput, IncomingInspectRecordUncheckedUpdateWithoutDetailsInput>
    create: XOR<IncomingInspectRecordCreateWithoutDetailsInput, IncomingInspectRecordUncheckedCreateWithoutDetailsInput>
  }

  export type IncomingInspectRecordUpdateWithoutDetailsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    lot?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    result?: EnumIncomingInspectResultFieldUpdateOperationsInput | IncomingInspectResult
    material?: MaterialUpdateOneRequiredWithoutIncomingInspectRecordNestedInput
    inspector?: UserUpdateOneWithoutIncomingInspectedRecordsNestedInput
    reviewer?: UserUpdateOneWithoutIncomingReviewedRecordsNestedInput
  }

  export type IncomingInspectRecordUncheckedUpdateWithoutDetailsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    lot?: StringFieldUpdateOperationsInput | string
    materialId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    inspectorId?: IntFieldUpdateOperationsInput | number
    reviewerId?: IntFieldUpdateOperationsInput | number
    result?: EnumIncomingInspectResultFieldUpdateOperationsInput | IncomingInspectResult
  }

  export type MaterialSpecUpsertWithoutInspectsInput = {
    update: XOR<MaterialSpecUpdateWithoutInspectsInput, MaterialSpecUncheckedUpdateWithoutInspectsInput>
    create: XOR<MaterialSpecCreateWithoutInspectsInput, MaterialSpecUncheckedCreateWithoutInspectsInput>
  }

  export type MaterialSpecUpdateWithoutInspectsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    material?: MaterialUpdateOneRequiredWithoutSpecsNestedInput
  }

  export type MaterialSpecUncheckedUpdateWithoutInspectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    materialId?: IntFieldUpdateOperationsInput | number
  }

  export type MaterialCreateWithoutInProcessInspectRecordInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    description?: string | null
    specs?: MaterialSpecCreateNestedManyWithoutMaterialInput
    operations?: OperationCreateNestedManyWithoutMaterialInput
    incomingInspectRecord?: IncomingInspectRecordCreateNestedManyWithoutMaterialInput
  }

  export type MaterialUncheckedCreateWithoutInProcessInspectRecordInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    description?: string | null
    specs?: MaterialSpecUncheckedCreateNestedManyWithoutMaterialInput
    operations?: OperationUncheckedCreateNestedManyWithoutMaterialInput
    incomingInspectRecord?: IncomingInspectRecordUncheckedCreateNestedManyWithoutMaterialInput
  }

  export type MaterialCreateOrConnectWithoutInProcessInspectRecordInput = {
    where: MaterialWhereUniqueInput
    create: XOR<MaterialCreateWithoutInProcessInspectRecordInput, MaterialUncheckedCreateWithoutInProcessInspectRecordInput>
  }

  export type UserCreateWithoutInProcessInspectedRecordInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    username: string
    hashedPassword?: string | null
    hashedRefreshToken?: string | null
    status: UserStatus
    role?: UserGroup
    profile?: UserProfileCreateNestedOneWithoutUserInput
    incomingInspectedRecords?: IncomingInspectRecordCreateNestedManyWithoutInspectorInput
    incomingReviewedRecords?: IncomingInspectRecordCreateNestedManyWithoutReviewerInput
    inProcessReviewedRecord?: InProcessInspectRecordCreateNestedManyWithoutReviewerInput
  }

  export type UserUncheckedCreateWithoutInProcessInspectedRecordInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    username: string
    hashedPassword?: string | null
    hashedRefreshToken?: string | null
    status: UserStatus
    role?: UserGroup
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    incomingInspectedRecords?: IncomingInspectRecordUncheckedCreateNestedManyWithoutInspectorInput
    incomingReviewedRecords?: IncomingInspectRecordUncheckedCreateNestedManyWithoutReviewerInput
    inProcessReviewedRecord?: InProcessInspectRecordUncheckedCreateNestedManyWithoutReviewerInput
  }

  export type UserCreateOrConnectWithoutInProcessInspectedRecordInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInProcessInspectedRecordInput, UserUncheckedCreateWithoutInProcessInspectedRecordInput>
  }

  export type UserCreateWithoutInProcessReviewedRecordInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    username: string
    hashedPassword?: string | null
    hashedRefreshToken?: string | null
    status: UserStatus
    role?: UserGroup
    profile?: UserProfileCreateNestedOneWithoutUserInput
    incomingInspectedRecords?: IncomingInspectRecordCreateNestedManyWithoutInspectorInput
    incomingReviewedRecords?: IncomingInspectRecordCreateNestedManyWithoutReviewerInput
    inProcessInspectedRecord?: InProcessInspectRecordCreateNestedManyWithoutInspectorInput
  }

  export type UserUncheckedCreateWithoutInProcessReviewedRecordInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    username: string
    hashedPassword?: string | null
    hashedRefreshToken?: string | null
    status: UserStatus
    role?: UserGroup
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    incomingInspectedRecords?: IncomingInspectRecordUncheckedCreateNestedManyWithoutInspectorInput
    incomingReviewedRecords?: IncomingInspectRecordUncheckedCreateNestedManyWithoutReviewerInput
    inProcessInspectedRecord?: InProcessInspectRecordUncheckedCreateNestedManyWithoutInspectorInput
  }

  export type UserCreateOrConnectWithoutInProcessReviewedRecordInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInProcessReviewedRecordInput, UserUncheckedCreateWithoutInProcessReviewedRecordInput>
  }

  export type MaterialUpsertWithoutInProcessInspectRecordInput = {
    update: XOR<MaterialUpdateWithoutInProcessInspectRecordInput, MaterialUncheckedUpdateWithoutInProcessInspectRecordInput>
    create: XOR<MaterialCreateWithoutInProcessInspectRecordInput, MaterialUncheckedCreateWithoutInProcessInspectRecordInput>
  }

  export type MaterialUpdateWithoutInProcessInspectRecordInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    specs?: MaterialSpecUpdateManyWithoutMaterialNestedInput
    operations?: OperationUpdateManyWithoutMaterialNestedInput
    incomingInspectRecord?: IncomingInspectRecordUpdateManyWithoutMaterialNestedInput
  }

  export type MaterialUncheckedUpdateWithoutInProcessInspectRecordInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    specs?: MaterialSpecUncheckedUpdateManyWithoutMaterialNestedInput
    operations?: OperationUncheckedUpdateManyWithoutMaterialNestedInput
    incomingInspectRecord?: IncomingInspectRecordUncheckedUpdateManyWithoutMaterialNestedInput
  }

  export type UserUpsertWithoutInProcessInspectedRecordInput = {
    update: XOR<UserUpdateWithoutInProcessInspectedRecordInput, UserUncheckedUpdateWithoutInProcessInspectedRecordInput>
    create: XOR<UserCreateWithoutInProcessInspectedRecordInput, UserUncheckedCreateWithoutInProcessInspectedRecordInput>
  }

  export type UserUpdateWithoutInProcessInspectedRecordInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    username?: StringFieldUpdateOperationsInput | string
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    hashedRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | UserStatus
    role?: EnumUserGroupFieldUpdateOperationsInput | UserGroup
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    incomingInspectedRecords?: IncomingInspectRecordUpdateManyWithoutInspectorNestedInput
    incomingReviewedRecords?: IncomingInspectRecordUpdateManyWithoutReviewerNestedInput
    inProcessReviewedRecord?: InProcessInspectRecordUpdateManyWithoutReviewerNestedInput
  }

  export type UserUncheckedUpdateWithoutInProcessInspectedRecordInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    username?: StringFieldUpdateOperationsInput | string
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    hashedRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | UserStatus
    role?: EnumUserGroupFieldUpdateOperationsInput | UserGroup
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    incomingInspectedRecords?: IncomingInspectRecordUncheckedUpdateManyWithoutInspectorNestedInput
    incomingReviewedRecords?: IncomingInspectRecordUncheckedUpdateManyWithoutReviewerNestedInput
    inProcessReviewedRecord?: InProcessInspectRecordUncheckedUpdateManyWithoutReviewerNestedInput
  }

  export type UserUpsertWithoutInProcessReviewedRecordInput = {
    update: XOR<UserUpdateWithoutInProcessReviewedRecordInput, UserUncheckedUpdateWithoutInProcessReviewedRecordInput>
    create: XOR<UserCreateWithoutInProcessReviewedRecordInput, UserUncheckedCreateWithoutInProcessReviewedRecordInput>
  }

  export type UserUpdateWithoutInProcessReviewedRecordInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    username?: StringFieldUpdateOperationsInput | string
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    hashedRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | UserStatus
    role?: EnumUserGroupFieldUpdateOperationsInput | UserGroup
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    incomingInspectedRecords?: IncomingInspectRecordUpdateManyWithoutInspectorNestedInput
    incomingReviewedRecords?: IncomingInspectRecordUpdateManyWithoutReviewerNestedInput
    inProcessInspectedRecord?: InProcessInspectRecordUpdateManyWithoutInspectorNestedInput
  }

  export type UserUncheckedUpdateWithoutInProcessReviewedRecordInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    username?: StringFieldUpdateOperationsInput | string
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    hashedRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | UserStatus
    role?: EnumUserGroupFieldUpdateOperationsInput | UserGroup
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    incomingInspectedRecords?: IncomingInspectRecordUncheckedUpdateManyWithoutInspectorNestedInput
    incomingReviewedRecords?: IncomingInspectRecordUncheckedUpdateManyWithoutReviewerNestedInput
    inProcessInspectedRecord?: InProcessInspectRecordUncheckedUpdateManyWithoutInspectorNestedInput
  }

  export type OperationSpecCreateWithoutInspectInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    description?: string | null
    operation: OperationCreateNestedOneWithoutSpecsInput
  }

  export type OperationSpecUncheckedCreateWithoutInspectInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    description?: string | null
    operationId: number
  }

  export type OperationSpecCreateOrConnectWithoutInspectInput = {
    where: OperationSpecWhereUniqueInput
    create: XOR<OperationSpecCreateWithoutInspectInput, OperationSpecUncheckedCreateWithoutInspectInput>
  }

  export type OperationSpecUpsertWithoutInspectInput = {
    update: XOR<OperationSpecUpdateWithoutInspectInput, OperationSpecUncheckedUpdateWithoutInspectInput>
    create: XOR<OperationSpecCreateWithoutInspectInput, OperationSpecUncheckedCreateWithoutInspectInput>
  }

  export type OperationSpecUpdateWithoutInspectInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    operation?: OperationUpdateOneRequiredWithoutSpecsNestedInput
  }

  export type OperationSpecUncheckedUpdateWithoutInspectInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    operationId?: IntFieldUpdateOperationsInput | number
  }

  export type IncomingInspectRecordCreateManyInspectorInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    lot: string
    materialId: number
    description?: string | null
    reviewerId: number
    result: IncomingInspectResult
  }

  export type IncomingInspectRecordCreateManyReviewerInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    lot: string
    materialId: number
    description?: string | null
    inspectorId: number
    result: IncomingInspectResult
  }

  export type InProcessInspectRecordCreateManyInspectorInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    lot: string
    description?: string | null
    materialId: number
    reviewerId: number
  }

  export type InProcessInspectRecordCreateManyReviewerInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    lot: string
    description?: string | null
    materialId: number
    inspectorId: number
  }

  export type IncomingInspectRecordUpdateWithoutInspectorInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    lot?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    result?: EnumIncomingInspectResultFieldUpdateOperationsInput | IncomingInspectResult
    material?: MaterialUpdateOneRequiredWithoutIncomingInspectRecordNestedInput
    details?: MaterialSpecInspectUpdateManyWithoutRecordNestedInput
    reviewer?: UserUpdateOneWithoutIncomingReviewedRecordsNestedInput
  }

  export type IncomingInspectRecordUncheckedUpdateWithoutInspectorInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    lot?: StringFieldUpdateOperationsInput | string
    materialId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reviewerId?: IntFieldUpdateOperationsInput | number
    result?: EnumIncomingInspectResultFieldUpdateOperationsInput | IncomingInspectResult
    details?: MaterialSpecInspectUncheckedUpdateManyWithoutRecordNestedInput
  }

  export type IncomingInspectRecordUncheckedUpdateManyWithoutIncomingInspectedRecordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    lot?: StringFieldUpdateOperationsInput | string
    materialId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reviewerId?: IntFieldUpdateOperationsInput | number
    result?: EnumIncomingInspectResultFieldUpdateOperationsInput | IncomingInspectResult
  }

  export type IncomingInspectRecordUpdateWithoutReviewerInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    lot?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    result?: EnumIncomingInspectResultFieldUpdateOperationsInput | IncomingInspectResult
    material?: MaterialUpdateOneRequiredWithoutIncomingInspectRecordNestedInput
    details?: MaterialSpecInspectUpdateManyWithoutRecordNestedInput
    inspector?: UserUpdateOneWithoutIncomingInspectedRecordsNestedInput
  }

  export type IncomingInspectRecordUncheckedUpdateWithoutReviewerInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    lot?: StringFieldUpdateOperationsInput | string
    materialId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    inspectorId?: IntFieldUpdateOperationsInput | number
    result?: EnumIncomingInspectResultFieldUpdateOperationsInput | IncomingInspectResult
    details?: MaterialSpecInspectUncheckedUpdateManyWithoutRecordNestedInput
  }

  export type IncomingInspectRecordUncheckedUpdateManyWithoutIncomingReviewedRecordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    lot?: StringFieldUpdateOperationsInput | string
    materialId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    inspectorId?: IntFieldUpdateOperationsInput | number
    result?: EnumIncomingInspectResultFieldUpdateOperationsInput | IncomingInspectResult
  }

  export type InProcessInspectRecordUpdateWithoutInspectorInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    lot?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    material?: MaterialUpdateOneRequiredWithoutInProcessInspectRecordNestedInput
    reviewer?: UserUpdateOneWithoutInProcessReviewedRecordNestedInput
  }

  export type InProcessInspectRecordUncheckedUpdateWithoutInspectorInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    lot?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    materialId?: IntFieldUpdateOperationsInput | number
    reviewerId?: IntFieldUpdateOperationsInput | number
  }

  export type InProcessInspectRecordUncheckedUpdateManyWithoutInProcessInspectedRecordInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    lot?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    materialId?: IntFieldUpdateOperationsInput | number
    reviewerId?: IntFieldUpdateOperationsInput | number
  }

  export type InProcessInspectRecordUpdateWithoutReviewerInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    lot?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    material?: MaterialUpdateOneRequiredWithoutInProcessInspectRecordNestedInput
    inspector?: UserUpdateOneWithoutInProcessInspectedRecordNestedInput
  }

  export type InProcessInspectRecordUncheckedUpdateWithoutReviewerInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    lot?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    materialId?: IntFieldUpdateOperationsInput | number
    inspectorId?: IntFieldUpdateOperationsInput | number
  }

  export type InProcessInspectRecordUncheckedUpdateManyWithoutInProcessReviewedRecordInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    lot?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    materialId?: IntFieldUpdateOperationsInput | number
    inspectorId?: IntFieldUpdateOperationsInput | number
  }

  export type EquipmentCreateManyProductLineInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    description?: string | null
    purchaseDate: Date | string
  }

  export type EquipmentUpdateWithoutProductLineInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: RepairPlanUpdateOneWithoutEquipmentNestedInput
    records?: RepairRecordUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentUncheckedUpdateWithoutProductLineInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: RepairPlanUncheckedUpdateOneWithoutEquipmentNestedInput
    records?: RepairRecordUncheckedUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentUncheckedUpdateManyWithoutEquipmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RepairRecordCreateManyEquipmentInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    description?: string | null
    status?: RepairRecordStatus | null
    type: RepairType
  }

  export type RepairRecordUpdateWithoutEquipmentInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumRepairRecordStatusFieldUpdateOperationsInput | RepairRecordStatus | null
    type?: EnumRepairTypeFieldUpdateOperationsInput | RepairType
  }

  export type RepairRecordUncheckedUpdateWithoutEquipmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumRepairRecordStatusFieldUpdateOperationsInput | RepairRecordStatus | null
    type?: EnumRepairTypeFieldUpdateOperationsInput | RepairType
  }

  export type RepairRecordUncheckedUpdateManyWithoutRecordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumRepairRecordStatusFieldUpdateOperationsInput | RepairRecordStatus | null
    type?: EnumRepairTypeFieldUpdateOperationsInput | RepairType
  }

  export type MaterialSpecCreateManyMaterialInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    description?: string | null
  }

  export type OperationCreateManyMaterialInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    description?: string | null
  }

  export type IncomingInspectRecordCreateManyMaterialInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    lot: string
    description?: string | null
    inspectorId: number
    reviewerId: number
    result: IncomingInspectResult
  }

  export type InProcessInspectRecordCreateManyMaterialInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    lot: string
    description?: string | null
    inspectorId: number
    reviewerId: number
  }

  export type MaterialSpecUpdateWithoutMaterialInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    inspects?: MaterialSpecInspectUpdateManyWithoutSpecNestedInput
  }

  export type MaterialSpecUncheckedUpdateWithoutMaterialInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    inspects?: MaterialSpecInspectUncheckedUpdateManyWithoutSpecNestedInput
  }

  export type MaterialSpecUncheckedUpdateManyWithoutSpecsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OperationUpdateWithoutMaterialInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    specs?: OperationSpecUpdateManyWithoutOperationNestedInput
  }

  export type OperationUncheckedUpdateWithoutMaterialInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    specs?: OperationSpecUncheckedUpdateManyWithoutOperationNestedInput
  }

  export type OperationUncheckedUpdateManyWithoutOperationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IncomingInspectRecordUpdateWithoutMaterialInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    lot?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    result?: EnumIncomingInspectResultFieldUpdateOperationsInput | IncomingInspectResult
    details?: MaterialSpecInspectUpdateManyWithoutRecordNestedInput
    inspector?: UserUpdateOneWithoutIncomingInspectedRecordsNestedInput
    reviewer?: UserUpdateOneWithoutIncomingReviewedRecordsNestedInput
  }

  export type IncomingInspectRecordUncheckedUpdateWithoutMaterialInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    lot?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    inspectorId?: IntFieldUpdateOperationsInput | number
    reviewerId?: IntFieldUpdateOperationsInput | number
    result?: EnumIncomingInspectResultFieldUpdateOperationsInput | IncomingInspectResult
    details?: MaterialSpecInspectUncheckedUpdateManyWithoutRecordNestedInput
  }

  export type IncomingInspectRecordUncheckedUpdateManyWithoutIncomingInspectRecordInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    lot?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    inspectorId?: IntFieldUpdateOperationsInput | number
    reviewerId?: IntFieldUpdateOperationsInput | number
    result?: EnumIncomingInspectResultFieldUpdateOperationsInput | IncomingInspectResult
  }

  export type InProcessInspectRecordUpdateWithoutMaterialInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    lot?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    inspector?: UserUpdateOneWithoutInProcessInspectedRecordNestedInput
    reviewer?: UserUpdateOneWithoutInProcessReviewedRecordNestedInput
  }

  export type InProcessInspectRecordUncheckedUpdateWithoutMaterialInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    lot?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    inspectorId?: IntFieldUpdateOperationsInput | number
    reviewerId?: IntFieldUpdateOperationsInput | number
  }

  export type InProcessInspectRecordUncheckedUpdateManyWithoutInProcessInspectRecordInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    lot?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    inspectorId?: IntFieldUpdateOperationsInput | number
    reviewerId?: IntFieldUpdateOperationsInput | number
  }

  export type MaterialSpecInspectCreateManySpecInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    recordId: number
    description?: string | null
    result: boolean
  }

  export type MaterialSpecInspectUpdateWithoutSpecInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    result?: BoolFieldUpdateOperationsInput | boolean
    record?: IncomingInspectRecordUpdateOneRequiredWithoutDetailsNestedInput
  }

  export type MaterialSpecInspectUncheckedUpdateWithoutSpecInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    recordId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    result?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MaterialSpecInspectUncheckedUpdateManyWithoutInspectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    recordId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    result?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OperationSpecCreateManyOperationInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    name: string
    description?: string | null
  }

  export type OperationSpecUpdateWithoutOperationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    inspect?: OperationSpecInspectUpdateManyWithoutSpecNestedInput
  }

  export type OperationSpecUncheckedUpdateWithoutOperationInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    inspect?: OperationSpecInspectUncheckedUpdateManyWithoutSpecNestedInput
  }

  export type OperationSpecUncheckedUpdateManyWithoutSpecsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OperationSpecInspectCreateManySpecInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    first: string
    inProcess: string
    final: string
  }

  export type OperationSpecInspectUpdateWithoutSpecInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    first?: StringFieldUpdateOperationsInput | string
    inProcess?: StringFieldUpdateOperationsInput | string
    final?: StringFieldUpdateOperationsInput | string
  }

  export type OperationSpecInspectUncheckedUpdateWithoutSpecInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    first?: StringFieldUpdateOperationsInput | string
    inProcess?: StringFieldUpdateOperationsInput | string
    final?: StringFieldUpdateOperationsInput | string
  }

  export type OperationSpecInspectUncheckedUpdateManyWithoutInspectInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    first?: StringFieldUpdateOperationsInput | string
    inProcess?: StringFieldUpdateOperationsInput | string
    final?: StringFieldUpdateOperationsInput | string
  }

  export type MaterialSpecInspectCreateManyRecordInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    specId: number
    description?: string | null
    result: boolean
  }

  export type MaterialSpecInspectUpdateWithoutRecordInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    result?: BoolFieldUpdateOperationsInput | boolean
    spec?: MaterialSpecUpdateOneRequiredWithoutInspectsNestedInput
  }

  export type MaterialSpecInspectUncheckedUpdateWithoutRecordInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    specId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    result?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MaterialSpecInspectUncheckedUpdateManyWithoutDetailsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    specId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    result?: BoolFieldUpdateOperationsInput | boolean
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}